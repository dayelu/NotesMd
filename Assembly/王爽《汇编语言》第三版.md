*王爽《汇编语言》第三版 一书读书笔记*



[TOC]

# 1. 基础知识
## 1.1 机器语言
### 1.1.1 概念

机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字。计算机将之转换为一列高低电平以使计算机的电子期间受到驱动进行运算。

## 1.2 汇编语言
### 1.2.1 概念
1. 机器语言难以记忆和书写，与汇编语言产生。汇编语言主体是汇编指令，与机器语言的区别在于表达方法上。
2. 汇编语言由编译器翻译成机器码交给计算机执行。

### 1.2.2 语言成分
汇编语言由以下三部分组成：

1. 汇编指令：机器码对应的助记符，**有对应的机器码**。
2. 伪指令：没有对应的机器码，由编译器执行，计算机不执行。
3. 其他符号：如 `+、-、*、\` 等符号，由编译器识别，没有对应的机器码。

## 1.3 其他基本概念
1. 内存：

   1. 数据和指令存在的位置。
   2. 内存不是磁盘的容量（比如 1 TB 的硬盘），磁盘上的数据或程序如果不读入内存就无法被 CPU 使用。
   3. 每个存储器被划分为若干个存储单元，每个存储单元从 0 开始编号。

2. 计算机的最小 **信息单位** 是 **bit**（比特），一个二进制位。

3. 计算机最小的 **存储单位** 是 **Byte**，称一个 **字节**。

4. **两个字节为一个字**（word），刚好为一个 8086 CPU 寄存器的位数（16位）。

5. 单位换算：

   **8  bit = 1 Byte**

   **2 Byte = 1 Word**

   **1 KB = 1024 Byte**

   **1 MB = 1024 KB**

   **1 GB = 1024 MB**

   **1 TB = 1024 GB**

6. 内存地址空间：地址总线宽度下，可寻址范围极为 CPU 的内存地址空间。例如，一个 CPU 的地址总线宽度为 10 ,那么可寻址 $2^{10}$ 个内存单元。这 1024 个内存单元即是 CPU 的内存地址空间。

7. CPU 不能直接对外设进行控制，直接控制外设的是与这些外设相连接的扩展插槽上的接口卡。扩展插槽和接口卡通过总线与 CPU 相连，**CPU 通过 接口卡间接控制外设**。某些接口上装有 RAM，用来对大批量输入输出的数据进行暂存，例如显卡的显存。更多 CPU 控制外设的内容在后续外中断章节还会提到。

   

## 1.4 CPU 对存储器的读写

1. 必要条件：

   CPU 对存储器进行读写需要其他芯片提供以下三类信息：

   - 存储单元的地址信息
   - 器件的选择，读写命令。（控制信息）
   - 读写的数据信息。

2. 读写过程（仅以读为例）

   - CPU 通过地址总线将地址信息 3 发出。
   - CPU 通过控制总线发出读内存命令，选中存储器芯片，并通知它将要从中读取数据。
   - 存储器将 3 号单元的数据 8 通过数据线送入 CPU.

- 示意图（CPU 从三号单元读取数据的过程）
![1.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.4.png)



## 1.5 总线

### 1.5.1 概念[^1]

  总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由[导线](https://baike.baidu.com/item/导线/1413914)组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为[数据总线](https://baike.baidu.com/item/数据总线/272650)、[地址总线](https://baike.baidu.com/item/地址总线/4307936)和[控制总线](https://baike.baidu.com/item/控制总线/272568)，分别用来传输数据、数据地址和[控制信号](https://baike.baidu.com/item/控制信号/10329713)。总线是一种内部结构，它是cpu、内存、输入、[输出设备](https://baike.baidu.com/item/输出设备/10823333)传递信息的公用通道，[主机](https://baike.baidu.com/item/主机/455151)的各个部件通过总线相连接，[外部设备](https://baike.baidu.com/item/外部设备)通过相应的接口电路再与总线相连接，从而形成了[计算机硬件系统](https://baike.baidu.com/item/计算机硬件系统/8092895)。在计算机系统中，**各个部件之间传送信息的公共通路叫总线**，[微型计算机](https://baike.baidu.com/item/微型计算机/9287)是以[总线结构](https://baike.baidu.com/item/总线结构/10183496)来连接各个[功能部件](https://baike.baidu.com/item/功能部件/8514356)的。

### 1.5.2 逻辑分类

  从逻辑上分为以下三类：地址总线，控制总线，数据总线。

- **地址总线**：CPU 通过地址总线指定存储器单元。地址总线的宽度决定 CPU 的寻址范围。（更多有关地址总线的问题在后面寻址有关问题再讨论）

- **数据总线**：CPU 与 内存之间的数据传送通过数据总线进行传送。数据总线的宽度决定了 CPU 和 外界的数据传输速度。例如，8 根数据总线一次可以传输 一个字节的数据。

- **控制总线**：CPU 通过 控制总线控制外部器件。控制总线决定对外部器件的控制能力（能控制多少外部器件）。控制总线的方向是双向的，CPU 通过控制总线发送控制信息给其他器件，反之其他器件也通过控制总线发送反馈信息给  CPU.

### 1.5.3 南北桥芯片

  南北桥芯片是主板上的**总线控制器芯片**。

![1.5.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.5.3.png)

- 北桥芯片：

  北桥芯片通过前端总线直接与 CPU相连。用于高速信号，CPU 信号，RAM信号和 GPU 信号。AMD 在 K8 系列后将内存控制器集成在 CPU 中，因此 AMD系的主板上的北桥芯片不再控制内存。

- 南桥芯片


##  1.6 内存地址空间

- 基本概念：

  所有的物理存储器都被 CPU 看作**一个**由若干存储单元组成的**逻辑存储器**，也即**内存地址空间**。每个物理存储器在这个逻辑存储器中都有一个地址段，即一段地址空间。示意图如下：

- CPU 的逻辑存储器

  ![1.6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.6.png)

- 限制因素：

  内存地址空间的大小受**地址总线宽度**的限制，8086 CPU 的地址**总线宽度为 20**，即 20 跟地址线，可表示从 1 到 ($2^{20}$ -1) 的 $2^{20}$ 个不同的地址信息，即可**定位 $2^{20}$  个内存单元**，也即**可寻址** $2^{20}$  个地址空间**，则其内存地址空间大小为 1 MB**，**寻址能力**为 **1 MB**。



# 2. 初识寄存器

## 2.1 CPU 内部基本构造

CPU 的由运算器、寄存器、控制器等器件组成，这些器件靠**内部总线**相连，**外部总线**实现 CPU 和主板上其他器件的联系。CPU内部工作原理简单总结如下：

- 运算器进行信息处理。

- 寄存器进行信息存储。

- 控制器控制各种器件进行工作。

- 内部总线连接各种器件，在他们直接发送数据。

  

## 2.2 寄存器分类一览

来源 : [8086CPU各寄存器及其简介](https://blog.csdn.net/weixin_40913261/article/details/90762210)



**8086 CPU 中寄存器总共为 14 个，且均为 16 位 。**

即 **AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES** 共 14 个。

而这 14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。

### 2.2.1 通用寄存器

**数据寄存器：AX，BX，CX，DX **[^2]

| 标识 | 名称 |
| :--: |:--: |
|**AX** (Accumulator) | 累加寄存器，也称之为累加器 |
|**BX** (Base) | 基地址寄存器 |
|**CX** (Count) | 计数器寄存器 |
|**DX** (Data) | 数据寄存器 |



**指针寄存器：SP 和 BP **

|          标识          |      名称      |
| :--------------------: | :------------: |
| **SP** (Stack Pointer) | 堆栈指针寄存器 |
| **BP** (Base Pointer)  |  基指针寄存器  |

**变址寄存器：SI 和 DI **

|            标识            |      名称      |
| :------------------------: | :------------: |
|   **SI** (Source Index)    |  源变址寄存器  |
| **DI** (Destination Index) | 目的变址寄存器 |



### 2.2.2 段寄存器

|          标识          |     名称     |
| :--------------------: | :----------: |
| **CS** (Code Segment)  | 代码段寄存器 |
| **DS** (Data Segment)  | 数据段寄存器 |
| **SS** (Stack Segment) | 堆栈段寄存器 |
| **ES** (Extra Segment) | 附加段寄存器 |



### 2.2.3 控制寄存器

|             标识             |      名称      |
| :--------------------------: | :------------: |
| **IP** (Instruction Pointer) | 指令指针寄存器 |
|           **FLAG**           |   标志寄存器   |



## 2.3 寄存器的逻辑结构

- 以数据寄存器 **AX** 为例

![2.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/2.3.png)

- 2进制和16进制的转换：

  **四位二进制数 等于 一位十六进制数**。因为四位二进制数可表示从0到 $2^{4}-1$ 即 15 以内的任意一个整数，一位十六进制数可表示的范围为0到15，刚好可以一一对应。因此，一个十六位二进制数可由四位十六进数表示。

- 在 8086 CPU 中，每个寄存器都是十六位。其中 **AX，BX，CX，DX** 四个 **数据寄存器** 由于向前兼容的原因可以分成**两个独立的 8 位寄存器**。如上图 **AX** 可以分成 一个 **AH** 寄存器，用来存储 **AX** 的 **高八位**称为**高位字节**，一个 **AL** 寄存器，用来存放 **AX** 的 **低八位**称为**低位字节**。类似的还有如下几种情况：
  - **BX** 可以分为 **BL** 和 **BH**；
  - **CX** 可以分为 **CL** 和 **CH**；
  - **DX** 可以分为 **DL** 和 **DH**；

- 在使用寄存器时需要注意以下几点：
  1. 一个寄存器只能存入其位数可表示范围以内的数据。例如，一个 **AX** 寄存器能存储的最大整数为 $2^{16}-1$ ，一个 **AL** 寄存器最大能存储的整数为 $2^{8}-1$.
  2. 在使用汇编指令如果操作对象由两个时，需要注意**两个操作对象的位数必须一致**。
  3. 在使用数据寄存器时需要注意，以 **AX** 为例，**AH** 和 **AL** 是两个 **独立** 的寄存器，**AL** 独立参与操作后得到的进位不会保存在 **AH**中，而是被舍去。如果 **AX** 参与操作此时第八位产生的进位会存储在高八位之中，此时 **AX** 相对于 **AH** 和 **AL** 而言也是一个独立的寄存器。



# 3. 物理地址

## 3.1 基本概念

- 定义：

  前面说到，CPU 将所有的物理存储器看一个由若干个存储单元组成的 **逻辑存储器**。所有的内存单元构成的存储单元是一个 **一维的线性空间**。每一个内存单元在这个一维的地址空间，这个地址被称为 **物理地址**。

- 16 位结构的 CPU：

  - 运算器一次最多可以处理 16位的数据；
  - 寄存器的最大宽度为 16位；
  - 寄存器和运算器之间的通路为 16位。

- **8086 CPU 有20跟地址线可表示 $2^{20}$ 个物理地址，即具有 1 MB 的寻址能力。**



- *扩展：*
  - x 位 CPU的说法是一种商业的叫法，并不是严格的专业术语。不同架构的 CPU对此亦有不同的定义标准。比如 CISC 架构的 x86 指令集的32位和64位就与 RSIC 架构的 ARM指令集的32位和64并相同。
  - 32位CPU通常有32个地址总线，其寻址能力为 $2^{32}$，即 **4 GB**. 由于 32位架构的 CPU寻址能力的限制，此架构的 CPU的计算机并不能利用大于其寻址能力以外的物理地址。
  - x86架构指的是以8086指令集为基础后进行一系列扩展的指令的集合，其特点是向下兼容[^3]。x86-32指的是 x86架构的32位扩展。
  - x86-64架构也被称为 AMD64架构，这是由于x86架构的64位扩展是由 AMD公司率先一步实现的。Inter 公司曾自研过不兼容 x86 架构的 IA-64，但由于x86 已形成的强大生态，IA-64日渐式微，AMD64架构最终也被Inter 采用。
  - x 位的操作系统指的是支持 x 位的操作系统，其针对特定 x 位的 CPU 进行设计。



## 3.2 8086 CPU 给出物理地址的方法

-  CPU 内部物理地址的合成与传送流程：
![2.4.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/2.4.2.png)

   

   1. CPU 中相关部件提供两个16 位的地址，一个称为 **段地址**，另一个称为 **偏移地址**；
2. 段地址和偏移地址通过内部总线送入一个称为**地址加法器**的部件；
   3. 地址加法器将**两个 16位地址合成一个 20位的物理地址**；
4. 地址加法器通过内部总线将 20位物理地址送入输入输出控制电路；
   5. 输入输出控制电路将 20位物理地址送上地址总线；
6. 20 位物理地址总线传送到存储器。


- 合成方法：

  **物理地址 = 段地址（SA） \* 16 + 偏移地址（EA）**

- 含义：段地址 \* 16 定位段的**起始地址**（基础地址），用偏移地址定位段中的内存单元。
- *注意：段地址和偏移地址都是**16位**。*



## 3.3 内存的“段”

### 3.3.1 基础知识

- “段”并不存在于物理内存中，“段”是**由 CPU 划分的若干个连续的存储单元**。在后面的学习中就会知道，后面的 “数据段”，“代码段” 和 “堆栈段”都是人为划分的段。
- “段”没有硬性的规定范围，可大可小。但是需要注意的是，由于偏移地址是16位，可寻址 $2^{16}$ 个内存单元，所以**一个段的最大长度是 64 K.**

### 3.3.2 CS 和 IP

- 基础知识：
  - 段寄存器：用于存放段地址的寄存器。在8086 CPU 中有 CS、DS、SS、ES。
  - **CS**：代码段寄存器，存放代码（指令）的段地址。
  - **IP**：指令指针寄存器，存放指令的偏移地址。
- 修改 CS 和 IP 的值
  1. 8086 CPU中传送指令 `mov` 不能用于设置 CS、IP的值。
  2. `jmp` 指令可同时修改 CS、IP的值 ，`jmp SA:EA`。例如 `jmp 2AE3:1003`.
  3. `jmp` 只修改 IP寄存器的值，`jmp 某一合法寄存器`。例如：`jmp ax`.“某一合法寄存器”，表示只能用寄存器的值修改 IP.

### 3.3.3 指令执行流程

![3.2.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/3.2.2.png)

1. CS、IP  中的内容送入地址加法器（地址加法器完成：物理地址 = 段地址 *  16 + 偏移地址）;
2. 地址加法器将物理地址送入输入输出控制电路；
3. 输入输出控制电路将 20000H（CS:IP 指向的物理地址）送上地址线；
4. 内存 20000H 单元处的第一条**指令通过数据总线**被送入 CPU；
5. 输入输出控制电路将机器指令送入**指令缓冲器**；
6. IP 中的值**自动增加**指令长度的值；
7. **执行控制器**执行指令；
8. 从 1 处重复执行至止。

**Notice：** **IP 先自增然后指令再执行**。

# 4. Debug 程序

- Debug 是 DOS、Windows （自 Windows 10 之后不再提供此程序）都提供的实模式（8086 方式）程序的调试工具。
- 使用方法：打开命令行（cmd），在命令行界面手动输入 “debug”  即可进入。
- 使用到的命令与功能：

| 命令 |                 功能                 |
| :--: | :----------------------------------: |
|  R   |        查看、修改寄存器的内容        |
|  D   |            查看内存的内容            |
|  E   |           改写内存中的内容           |
|  U   |   将内存中的机器指令翻译成汇编指令   |
|  T   |           执行一条机器指令           |
|  A   | 以汇编的格式在内存中写入一条机器指令 |

## 4.1 命令的用法

- R 命令

|   指令格式   |                  命令用法                  |                          |
| :----------: | :----------------------------------------: | :----------------------: |
|      r       |          无参数，查看寄存器的内容          |            r             |
| r *register* | 以部分寄存器名作为参数，修改寄存器的内容。 | r ax ,  r cs , r ip 等等 |

**Tips** ： 在使用 R 命令修改寄存器内容时，在指令输入后按下回车键会出现一个 “:” 符号作为内容输入的提示，当输入完成后再次回车即可修改内容，可用 R 指令再次验证内容是否改变。



- D 命令

常用方法：`d 段地址[段寄存器]:偏移地址1 [偏移地址2]`

例如：`d 1000:9`，`d 1000:9 f`，`d ds:0 f`



当 D 命令只有一个参数时，会显示一个默认的 段地址（这个段地址来自哪里，目前无法确定），这个参数将作为显示首行内存信息的偏移地址



- E 命令

常用方法：

1. `e 段地址:偏移地址 data1 data2 data3 ... `

例如：`e 1000:0 0 1 2 3 4 5`

2. 提问方式修改从某一地址开始的内存单元的内容，步骤如下：

首先按 `e 段地址:偏移地址` 的格式输入物理地址（起始地址）后按下回车，之后debug程序会显示起始地址，和第一单元的原始内容，让后光标停在 `.` 的后面以此提示用户输入想要修改的内容，不输入内容直接按空格则不会修改原始内容。无论输入与否只要按下空格则会进入下一个地址，显示下一个地址的原始内容，后面再次出现 `.` 提示符号，直至用户按下回车完成内存该写。如下图：

![4.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.1.png)

3. 写入单个字符和字符串

写入单个字符 ：`e 1000:0 1 'a' 2 'b' 3 'c'`

写入字符串： `e 1000:0 1 "a+b" 2 "c++" 3 "dayelu"`



**Tips**：E 命令还可以通过写入指令对应的机器码来写入指令。



- U 命令

常用方法： `u 段地址:偏移地址1 [偏移地址2]`

使用方法如下图：

![4.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.2.png)



- T 命令

使用指南：

要想使用 T 指令执行自己想要执行的指令有两种方法：一种方法是首先要将汇编指令写入 `CS:IP ` 处，由于这是汇编指令的起点；另一种方法是将指令写入想要写入地址处，然后再通过认为改变 CS寄存器和 IP寄存器的地址来执行指令。以下以第二种为例：

1. 如上图 首先从物理地址 `1000:0` 处写入汇编指令。
2. 用 R 指令将 `CS:IP` 地址 设置为 `1000:0`.
3. 使用 T 命令对汇编指令进行单步执行。

操作如图：

![4.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.3.png)



- A 命令

使用 E 命令可以写入机器指令，但是这样写入很不方便，因此 Debug 提供了 A 命令用于直接像内存写入汇编指令。

使用方法：`a 段地址:偏移地址`，操作如下图：

![4.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.4.png)

- [ ] 使用 `a 段地址:偏移地址` 的办法可以直接指定 `CS:IP` 所指向的位置，也就是代码段的位置，从此处开始输入指令。

  

  除此之外还可以直接以 输入 a指令后回车的方式从预设的 `CS:IP`  处开始输入指令。

  事实整明并非如此，当 `CS:IP` 改变 a 命令的回车默认位置并不会改变，也就是说它是一个预定值。这跟上面 D 命令的情况也类似，其段地址也是个预定值，并不会随着 CS 或者 DS 寄存器进行改变。



​		诡异的时，当我推出debug程序再次进入时，`CS`，`DS `和 A 命令，D 命令的预设值都会一模一样！！！

​	

​		这说明 debug 程序也会有欺骗的嫌疑，这些程序的原因未必会出现 汇编语言的中，因此，过分纠结这些工具好像属实没必要！！！！

​		

# 5. 寄存器（内存访问）

## 5.1 内存种字的存储

在 CPU 种用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节。如图所示：

![5.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/5.1.png)

假设从地址 0 处开始存放 2000（**4E20H**），用 地址为0 和 1 两个内存单元存放。**高地址 1** 存放**4E**，**低地址 0** 存放 **20** .

**字单元**：存放一个字型数据（16位）的内存单元，由**两个地址连续的内存单元**组成。**高**地址内存单元中存放字型数据的**高**字节位，**低**地址内存单元存放字型数据的**低**字节位。这种方式有时也被称为“**高高低低**”原则，属于**小端模式**。



关于更多 “**大小端模式**” 的相关问题详见博客 [详解大端模式和小端模式]( https://www.cnblogs.com/wpgraceii/p/11395719.html)



## 5.2 DS 和 [address]

**CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址**，在 80806 CPU 中，内存地址由段地址和偏移地址组成。

**DS 寄存器：**在 8086 CPU 中通常用 **DS 寄存器存放要访问数据的段地址**。例如;

```assembly
mov bx,1000H	; 1
mov ds,bx		; 2
mov al,[0]		; 3
```

**解析：**

将 地址为 10000H 的内存单元（8位，一个字节）里的值送入 al 寄存器中。

由于 **8086 CPU 不支持将 数据 直接送入段寄存器中**，送所以只能将 地址为 10000H 内存单元的段地址，即 **1000H** 先送入 **bx** 寄存器中，再由 **bx** 传送给 段寄存器 **DS**.如上述步骤1，2.

**[...]** 表示一个内存单元，**[ ]** **中的数值表示内存单元的偏移地址**，其**段地址默认存储于 段寄存器 DS 中**，8086 CPU 执行指令时会自动从 DS 中取出。由于al 是8位寄存器，所以这里步骤3 就表示将内存单元 **1000H:00H** 中的值传送给 寄存器 al。



## 5.3 mov、add、sub 指令

### 5.3.1 mov 指令形式

1. 与段寄存器无关的指令语句

|              形式              |    例子    |
| :----------------------------: | :--------: |
|   **mov ** *register*,*data*   | mov ax,8AH |
| **mov ** *register*,*register* | mov ax,bx  |
|  **mov ** *register*,*[···]*   | mov ax,[0] |
|   **mov ** [···],*register*    | mov [0],ax |

2. 与段寄存器相关的指令语句

|                  形式                   |   例子    |
| :-------------------------------------: | :-------: |
| **mov ** *register*, *segment register* | mov ds,ax |
| **mov **  *segment register*,*register* | mov ax,ds |
| **mov ** *segment register*,*[···]* | mov ax,1000H<br >mov ds,ax<br >mov ds,[0] |
| **mov ** [···],*segment register* | mov ax,1000H<br >mov ds,ax<br >mov [0],ds |



### 5.3.2 add 指令和 sub 指令

**add 加法指令，sub 减法指令**，与 **mov指令** 类似，**将两个数值计算结果储存在 指令操作的第一个操作对象里面（寄存器或内存单元）**，格式有以下分别四种。


|              形式              |    例子    |
| :----------------------------: | :--------: |
|   **add ** *register*,*data*   | add ax,8AH |
| **add ** *register*,*register* | add ax,bx  |
|  **add ** *register*,*[···]*   | add ax,[0] |
|   **add ** [···],*register*    | add [0],ax |
|   **sub ** *register*,*data*   | sub ax,8AH |
| **sub ** *register*,*register* | sub ax,bx  |
|  **sub ** *register*,*[···]*   | sub ax,[0] |
|   **sub ** [···],*register*    | sub [0],ax |



# 6 8086 CPU 栈机制

## 6.1 基本概念

- **栈的基本操作**：
  
  - **入栈**：将一个新元素放入栈顶。
  - **出栈**：从栈顶取出一个元素。
  
- 栈的特点：

  栈顶元素总是最后入栈，需要出栈时，又最先被栈中取出。栈的这种操作原则被称为：**LIFO（Last In First Out，后进先出）**。

- **关于栈顶和栈底的区分**：

  可以**将栈想象成一个瓶子**，向瓶子里塞物品（假设瓶子是规则的筒状，并且物品刚好每次只能塞进去一个），**瓶底就是栈底**，靠近瓶口的物品的位置就是栈顶。

- 基本的 **入栈和出栈指令**：**PUSH（入栈）和 POP（出栈）**

- 8086 CPU 的入栈和出栈都是**以字（16 位）为单位**进行的。

- 8086 CPU **确定栈顶元素位置的方式**：

  - **SS (Stack Segment)  堆栈段寄存器** ：**存放栈的段地址**。

  - **SP (Stack Pointer)  堆栈指针寄存器**：**存放栈的偏移地址**。

    **任意时刻，SS:IP 指向栈顶元素。**



## 6.2 出入栈操作的完整过程

- **入栈**过程，**栈顶从高地址向低地址方向增长**，以**push ax**为例，步骤如下：

  
  
  1.  **SP = SP - 2，SS:SP 指向当前栈顶前面的字单元，以当前栈顶前面的字单元为新的栈顶**。
  2.  **将 ax 中的内容送入 SS:SP 指向的内存单元处**，SS:SP 此时指向新栈顶。
  
  
  
    操作过程如下图，图片来自 *《汇编语言》第三版，59页，作者王爽*

![6.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.1.png)

- 出栈操作，与入栈操作刚好相反，以 **pop ax** 为例，步骤如下：

  
  
1. **将 SS:SP 指向的内存单元处的数据送入 ax 中**；
  2. **SP = SP + 2 ,SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。**

  

   操作过程如下图，图片来自 *《汇编语言》第三版，61页，作者王爽*

![6.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.2.png)

  - 注意 ：上图中，出站后，**SS:SP 指向新的栈顶 1000EH**，pop 操作前的栈顶元素，~~1000CH 处的2266H 依然存在~~，但是它已不在栈中。当再次执行 push 等入栈指令后， SS:SP 移动至 1000CH 处，并在里面写入新数据，~~覆盖当前数据~~。
  
    
    
    ~~这与外存的读写方式类似 ，删除数据的时候并不会对存储单元就行真的擦除操作，只是将其索引删去，使得这部分数据无法被检索到。当有新的数据写入时将会把这些数据覆盖。当发出删除操作指令之后就立马对数据作类似清零的操作会增加计算机的负载，增加时延，没有必要。以上属于个人理解。~~ 
    
    我没说过这句话。
    
    以上**注意**纯属**谣言！！！**，注意内容来自，本参考书籍王爽老师的《汇编语言》第三版，上面说到执行pop指令之后，被弹出去之前的栈顶元素依然与地址，当再次有入栈操后才会被覆盖掉。经亲手实验证实，在 pop 指令执行之后，该地址的内容会被栈顶上面的字元素填充，有图有真相：
    
    ![6.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.3.png)
    
    ![6.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.4.png)



## 6.3 答疑解惑

### 6.3.1 栈与内存图的画法

1. **关于内存的画法**
   通过参考国内外的相关书籍，可以初步做出以下结论：

   如果规定只能化成一个竖直形状的图形，**内存地址是从高到低还是低到高的标识法**其实都没有任何问题，**没有硬性的规定**。这只是一个模型而已，随便你怎么画好了，内存条等等这些硬件才不在乎你把它化成什么样子。但是不管怎么画都需要遵守相关的准则，例如下面要谈到的 x86体系结构下**CPU提供的栈机制**的画法 。

2. **关于栈的画法**

   至于栈的最原始定义是什么无从考证，栈只是一种数据结构而已。所以当你画栈的内存模型时，如果没有特殊限制说明，你画了一个栈并规定好栈顶之后，你**不需要过分纠结**入栈时，新元素是应该放在栈顶的上方还是下方，即规定**入栈的方向**。如果没有特殊的限制说明，你自己规定就好了，你规定入栈的方向在栈顶的上方，那元素就只能从此进入。再次强调，栈只是一个数据结构，你了解他的基本原理就够了，你只需知道**栈是一个受限的线性表，只能从一个方向填充和删除元素并且遵循 LIFO 原则就够**了。但是当遇到特定情况时需要遵守相关原则，例如下面要谈到的 x86体系结构下**CPU提供的栈机制**的画法 。

3. **x86 体系CPU 提供的栈机制的画法**

   前面提到，在没有规定下，无论内存地址的增长方向还是栈的入栈方向再没有特殊规定下可以随心所欲地画。但是，在特定硬件体系结构下，如本标题，栈和内存有特定的联系时，就不能随心所欲了。

   通过查阅国内外相关书籍，初步聊到 x86 体系 CPU 对栈的规定：

   1. **栈的"生长"方向是从高地址到低地址**。（*The stack will grow as more data is stored in it, and it will grow in the downward direction,
      from higher addresses to lower addresses.*）
   2. **入栈操作（执行 push 指令）时，栈顶的地址总是随着元素的增加而由高到低**（*The stack pointer rsp will decrease every time you put data on the stack.*[^4]），这句话本意应解释为：**“每次向栈中增加数据时，栈指针寄存器 的值将会减小**”，二者意义并无冲突。

   

所以关于栈的画法，内存是从上到下或者下到上增加都没关系，只是在 特定条件下，例如 x86 体系的CPU 的限制下，注意入栈的方向与内存的法相对应其法则就够了。现选取国外相关图书中**内存地址增加方向不同**的内存图画法如下，以供进一步理解：



- 入栈操作，**内存向下减小**，来自 *Assembly Language for x86 Processors, 7th Edition* 一书 141 页，作者 KIP R. IRVINE

![6.5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.5.png)

  - **内存向下增加**，Intel 64, registers and stack，英特尔 CPU 结构图，来自 *Low-Level Programming* 一书 15 页，作者 Igor Zhirkov.

    ![6.6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.6.png)





### 6.3.2 一个关于 SP 的伪命题

- *SP 寄存器指向栈顶元素的哪个内存单元*? 以以下图为例，《汇编语言》第三版，59页，作者王爽。引出以下问题：

![6.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.1.png)

- 疑问：如上图第三部分，SP 是指向 66 还是 22 ？

- 解析：冷静了很久，才发现这是伪命题！因为， SP 是 堆栈指针寄存器，**单个 SP 是不能确定物理地址的**，更不用说确定 栈顶元素的物理地址。再次强调**任何时候，SS:SP 指向栈顶元素。** 由于 SS:SP 指向栈顶元素，所以可以确定 SS:IP 指向的是 66 而不是 22。因为根据 “**高高低低原则**” ，高地址存放高字节，低地址存放低字节，当 SS:IP 指向的是 66 时，高地址是 1000DH 存放 22，低地址是 1000CH 存放 66，所以 SS:SP 指向的字型数据是 2266H 。

  反之，如果 SS:IP 指向的是 22，那么 SS:SP 指向的字型数据就是 2322H 而不是 2266H 了。

  

- 困惑来源：在伪命题成立的情况下，误以为，pop 和 push 操作都是以字型数据为操作对象，所以无论 SP 指向 66 还是 22 pop 的都有可能操作的是 2266H ，会影响最终结果，以致一错再错。最后才通过分析 pop 指令执行时，SP 寄存器的变化才重回正轨。

  

  至于为什么会把 栈指令寄存器 SP 当成了 SS:SP 呢？原因就是来自 *Assembly Language for x86 Processors, 7th Edition* 一书 141 页的这张图相关的一系列图。

  ![6.5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.5.png)

  
  
  ​	图中的寄存器 ESP 直接指向了内存单元！也就是说它一个寄存器就可以指向物理地址！这让我对 ESP 和 SP 之间产生了混淆，完全忘记了 我学的目前还是 8086汇编，而 ESP 寄存器属于 x86 汇编，与之类似的 还有属于 x64汇编的 RSP 。通过搜索才知道“**ESP为栈指针，用于指向栈的栈顶**”，**不需要像 8086 汇编中 两个寄存器合成 栈顶元素的物理地址。** 因此铸成大错。



## 6.4  空栈和栈顶超界问题

- 空栈状态，图片来自 *《汇编语言》第三版，60页，作者王爽*

  ![6.7](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.7.png)

  **若 10000H ~ 1000FH为栈空间**，栈底位置内存单元的地址为 1000FH ，当栈为空时，SS:SP 应该指向何处？

  由于当向栈空间添加一个元素之后，由于入栈操作的操作数是字型数据，所以 SS:SP 必然指向1000EH。因此反推之，当栈空时，SS:SP 指向不属于栈空间的栈底内存单元的下一个位置，即 10010H.**空栈也可以理解成栈中唯一的元素出栈**。



- 栈顶超界

  前面提到栈的空间时，都有一个“假设”的前提，那么 8086 CPU 有没有防止栈满时继续入栈导致出现栈顶超界问题的机制呢？

  答案是，并没有。**8086 CPU 并没有检测和限制栈的越界问题**。**8086 CPU 只考虑当前栈顶的位置，当前需要执行那一条指令**。**当栈满时继续进行入栈操作时，将会覆盖掉栈顶元素之上栈空间之外的一个字单元**。因此这是搬砖人员需要考虑问题。

  所以在编程时**尽量使用最大栈空间**防止入栈数据太多而导致的超界问题 ；同样在进行出栈时也需要注意当前栈是否为空，以防止出现栈空时继续出栈造成的越界问题。



## 6.5 push 和 pop 指令

- 指令使用方式：

|   指令格式    |              意义              |                     示例                     |
| :-----------: | :----------------------------: | :------------------------------------------: |
|  push 寄存器  |     将一个寄存器的数据入栈     |                   push ax                    |
|  pop 寄存器   |   出栈，用一个寄存器接收数据   |                    pop ax                    |
| push 段寄存器 |    将一个段寄存器的数据入栈    |                   push ds                    |
| pop 段寄存器  |  出栈，用一个段寄存器接收数据  |                    pop ds                    |
| push 内存单元 |    将一个内存单元处的字入栈    | mov ax,1000H<br >mov ds,ax<br >push [0]<br > |
| pop 内存单元  | 出栈，用一个内存字单元接收数据 | mov ax,1000H<br >mov ds,ax<br >pop [2]<br >  |



- 编程示例：

  - 要求：
    1. 将 10000H ~ 1000FH 这段空间当作栈，初始状态栈空；
    2. 设置 AX = 001AH，BX = 001BH；
    3. 将 AX、BX 中的数据入栈；
    4. 将 AX 、BX 清零；
    5. 从栈中恢复 AX、BX 原来的内容。

  

  - 代码示例：

    ```assembly
    mov ax,1000H
    mov ss,ax
    mov sp,0010H	;初始化栈顶，栈的情况如下图（a）所示
    
    mov ax,001AH
    mov bx,001BH
    
    push ax
    push bx		;ax,bx 入栈，栈的情况如下图（b）所示
    
    sub ax，ax
    sub bx，bx	;将ax清零用 mov ax,0 或者 sub ax,ax 都可以，前者机器码 2 字节，后者三字节。
    
    pop bx
    pop ax	;从栈中恢复 ax、bx 的数据，当前栈顶是 bx 中原来的内容， ax 原来的内容在栈顶下面，所以先 pop bx 再 pop ax
    ```

    ![6.8](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.8.png)

- 总结：

  push、pop 指令实质上一种**内存传送指令**，可以**在寄存器和内存之间传送数据**。

  push、pop 等栈操作指令**修改的只是 SP** ，因此，**栈顶的变化范围最大为 0 ~ FFFFH**。





- [x] 通过debug 程序验证 “pop 操作之后 数据仍在内存” 的正确性
- [ ] 吸收第三章 实验的知识。(这个实验跟后面的内容有联系，待学习完后面再战)

然后向下面这样



# 7. 第一个源程序

## 7.1 源程序示例

- 源程序 *1.asm*

```assembly
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	
	mov ax,4c00H
	int 21H

codesg ends	;名为 codesg 的段到此结束

end
```



1. 伪指令

   汇编语言源程序包含 **汇编指令** 和 **伪指令** 两种指令。

   **汇编指令**是有对应机器码的指令，最终**被 CPU 执行**。

   **伪指令**没有对应的机器指令，最终不被 CPU 所执行，而是**被编译器执行**。

   

   上述源程序中出现的伪指令有如下几种：

   

   - **segment 和 ends**

      segment 和 ends 是**可编译源程序**中必须被用到的两个**成对使用**的伪指令。这对指令的功能是定义一个段，**segment** 标记一个**段的开始**，**ends** 标记一个**段的结束**。使用格式如下：
    ```
   段名 segment
   ：
   段名 ends   
    ```

   - **end**

     整个汇编源程序的结束标志。编译器执行到此即结束编译。

   

   - **assume**

     这条伪指令的含义为“假设”，假设某一段寄存器和程序中的某一个用 segment...ends 定义的段相关联。

   

2. **标号**

   汇编源程序中除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。



3. **程序返回**

   在一个**单任务系统**中（以 DOS为例），一个程序 P2 在可执行文件中，则必须有一个正在运行的程序 P1，将 P2 从可执行文件中加载到内存后，将 **CPU** 的**控制权**将给 P2， P2 才能得以运行。P2 开始运行后，P1 暂停运行。

   而当 P2 运行完毕后，应该将 **CPU** 的**控制权**交还给使它得以运行的程序 P1，此后，P1继续运行。

   

   一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，这个过程被称为 “**程序返回**”。

   ```assembly
mov ax,4c00H
   int 21H
   ```
   
   这两条指令所实现的功能就是 **程序返回**。



## 7.2 源程序的编译、连接和执行

- 工具：masm5.0 汇编编译器，Overlay Linked3.60 连接器

- 步骤：以 *1.asm* 为例

  1. **编译** 源文件（.asm），生成目标文件（.obj）

     ```
     C:\masm>masm 1.asm;
     ```

  2. **连接** 目标文件（.obj）,生成可执行文件（.exe）
     
     ```
     C:\masm>link 1.obj;
     ```

  3. 执行
  
     ```
     C:\masm> 1.exe
     ```



- 注意：
  1. 编译和连接命令后面**分号（;）**不可省略。
  2. 以上三个步骤中文件后缀名（如 .asm , .obj , .exe等）均可省略。



## 7.3 程序执行过程的追踪

- DOS 中 .EXE 文件的简单加载过程，如下图：*王爽《汇编语言》第三版，92页*

  ![7.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.1.png)

  由于有 `PSP` 区的存在，通过 `Debug` 程序我们可以发现，`DS` 段寄存的地址 与 `CS` 段寄存器的地址有这样的关系：

  **`DS`地址 + `10H` = `CS` 地址**

  当然这在没有其他段（比如数据段和栈段）或者其他段不在程序开头定义时成立。如果其他段在程序开头定义还需要加上其他段空间大小，参考实验五。

  

- 追踪工具：Debug 程序

  由于 Debug 程序可以将程序加载入内存，**设置 CS:IP 指向程序的入口**，但是，**Debug 程序 不放弃对 CPU 的控制**，所以可以对程序执行过程就行追踪。

  

- 追踪过程，以源程序 1.asm 生成的可执行文件 1.exe 为例，如下图：

  ![7.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.1-1597756911155.png)

  ![7.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.2.png)

  

- 步骤说明：

  1. 在命令提示符中输入`debug 1.exe` 后回车，Debug 将从将程序从 1.exe 加载入内存中，进行相关初始化后，设置 **CS:IP** 指向程序的入口。
  2. 使用 T 命令单步执行，直到下个指令为 `INT 21` 时，**使用 P 命令结束**程序。
  3. 使用 Q 命令退出 Debug 程序，将返回到 command （命令行终端）中，因为 Debug 是由 command 加载运行的。



- 过程解析：

  在 DOS 中用  `debug 1.exe`  运行 Debug 对 1.exe 进行跟踪时，

  程序**加载顺序**是：command 加载 Debug $\longrightarrow$ Debug 加载 1.exe 

  程序**返回顺序**是：从 1.exe 中的程序返回到 Debug $\longrightarrow$ 从 Debug 返回到 command。

  

## 实验三

- 源程序：t1.asm

```asm
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,2000H
	mov ss,ax
	mov sp,0
	add sp,10

	pop ax
	pop bx
	push ax 
	push bx
	pop ax
	pop bx
	
	mov ax,4c00H
	int 21H

codesg ends	;名为 codesg 的段到此结束

end
```

- Debug 追踪，如下图

![7x1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x1.png)

![7x2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x2.png)

![7x3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x3.png)



- 查看 PSP 区的内容

![7x4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x4.png)



- [ ] 其中玄机如何，暂未参透，待来日回首。



# 8. [BX] 和 LOOP 指令

## 8.1 [BX]

和 `[0]`一样，`[BX]` 同样也表示一个内存单元，段地址在 DS 寄存器中，偏移地址 在 BX 寄存器中。如下：

```assembly
mov ax,[bx]
```

将一个内存单元的地址送入 ax。这个内存单元的长度位 2（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

- 约定符号：

  为了方便下文的描述，做如下规定：

  1. 符号 `()` 表示一个内存单元或者寄存器的内容。例如：(ax) 表示寄存器 ax 的内容。
  2. `idata` 表示常量。例如：`mov ax,[idata]` 代表 `mov ax,[1]、mov ax,[2]` 等。

- 有例题如下：

- 代码：

```assembly
mov ax,2000H
mov ds,ax
mov bx,1000H
mov ax,[bx]

inc bx	; 表示 将bx存储的数据加一，类似于 C语言的自增（++）
inc bx
mov [bx],ax

inc bx
inc bx
mov [bx],ax

inc bx
mov [bx],al

inc bx
mov [bx],al
```

- 内存变化图：图片来源王汇编。97，99 两页

![8.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.1.png)



## 8.2 LOOP 指令

loop 为循环指令。

- 指令格式：`loop 标号`。
- 操作步骤：
  1. `(cx) = (cx) - 1`
  2. 判断 `cx ` 中的值，不为零则转至表好处执行，为零则向下执行。

- `loop ` 指令用来实现循环的功能，**`cx`** 中存放 **循环次数**。

- 示例：计算 $2^{12}$

```assembly
assume cs:code
code segment
	mov ax,2
	mov cx,11

s:	add ax,ax
	loop s
	
	mov ax,4c00h
	int 21h

code ends
end
```

- 解析：

  `add ax,ax` 等价于 `(ax) = (ax) * 2`，由于此例，（ax）可以看作底数是2 的幂运算，乘以 2 就相当于指数加一。所以，可以将 `(cx) ` 设置为 11 来实现。



## 8.3 Debug 程序跟踪 loop 指令实验

- 要求：

  计算`ffff:0006` 单元中的数乘以 3，结果存放在 `dx` 中。

- 源程序：

```assembly
assume cs:code
code segment
	mov ax,0ffffh ; ffff:0006 单元处数值最大值为2^8-1,
    			  ; 不会大于 IP寄存器可存的
    			  ; 最大数值 2^16-1, 因此不会有溢出行为。 
	mov ds,ax
	mov bx,6	; 以上，设置 ds:bx 指向 ffff:6
	
	mov al,[bx]
	mov ah,0	; 以上，设置(al)=((ds*16)+(bx)),(ah)=0
	
	mov dx,0	; 累加器清零
	mov cx,3	; 循环三次、
	
s:	add dx,ax
	loop s		; 以上累加计算(ax)*3
	
	mov ax,4c00h
	int 21h		; 程序返回

code ends
end
```

- 注意：

  **在汇编源程序中 ，数据 不能以字母开头！** 所以本例中，`mov ax,0ffffh` ，十六进制数 `ffffh` 需要写成  `0ffffh`。

- 调试

  ![8.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.2.png)

  如上图所示，使用 `Debug` 对已生成的可执行文件进行调试。

  1. 通过使用 **`U`** 命令查看汇编指令，我们发现，此时在汇编源程中的 **标号 s** 变成了 `0012H` ，没错，正是源程序中 **标号 s** 所在行的那条汇编指令的起始位置。

  2. 直接使用 **`G`** 命令将偏移地址跳转至 `0012H` ，即  **标号 s** 所在的位置。也可以说是 循环体开始的位置。然后使用 **`T`** 命令不停地进行 单步调试，直至到执行 `int 21` 指令后，用 **`P`** 命令退出调试。如下图：

     ![8.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.3.png)

     从上图程序运行的过程我们看出，每次执行完 **`loop`** 指令后，CX 的值会自动减一，然后会判断其值是否会大于零；若大于零，则会 **向上** 跳转到标号的所在位置继续从上往下执行；若等于零则继续 **向下** 执行。

  3. 当循环次数增多，使用 **`T`**  命令进行单步调试就显得不可行，于是我们可以使用 **P** 命令。如上所见，**P** 命令可以用来终结调试，不仅如此，当执行到 **`loop`** 指令时，我们使用 **P** 命令 后，`Debug` 程序就会自动重复执行标号和 **`loop`** 指令之间，以及 **`loop`** 指令 在内的诸多指令，如下图;

     ![8.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.4.png)



## 8.4 Debug 和 masm 对指令的不同处理

- 对于汇编指令 **`mov ax,[idata]`** ，

  在 `Debug` 程序中，表示将 `ds:[idata]` 中的内容送入 AX 中。

  在 masm 中则会被解释为，将 `idata` 送入 AX 中。

- 在 masm 源程序中有两种方法表示，这种内存单元：
  
  1. 将偏移地址送入 bx 寄存器中，使用 **`ds:[bx]` ** 表示内存单元。
  2. 使用 **段前缀**：**`ds:[0]`** 显示地给出段地址，这种形式表示一个内存单元。
  
- 下面给出 masm 源程序 的具体例子，增强区分：

  `mov ax,[0]` 	====>>>	`(ax) = 0`

  `mov ax,[bx]` 	====>>>	`(ax) = (ds:bx)`

  `mov ax,ds:[0]` 	====>>>	`(ax) = (ds:0)`

  `mov ax,ds:[bx]` 	====>>>	`(ax) = (ds:bx)`



## 8.5 loop 和 [bx] 的联合应用

- 要求：

  计算 `ffff:0 ~ ffff:b` 单元中的数据之和，结果存储在 `dx` 中。

- 分析：

  每个内存单元的可存储的最大数值为 $2^{8}-1=255$，12 个这样的数之和 $255\times 12=$ 3060,不会大于一个字可存储的最大数值 $2^{16}-1=65535$ .因此，`ds`寄存器可存下，不会发生溢出问题。

- 源程序1：

```asm
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax	; 设置(ds)=ffffh
	mov dx,0	; 初始化累加寄存器，(dx)=0

	mov al,ds:[0]
	mov ah,0	; (ax)=((ds)*16+0)=(ffff0h)
	add dx,ax	; 向dx中加上 ffff:0 单元的数值

	mov al,ds:[1]
	mov ah,0	; (ax)=((ds)*16+1)=(ffff1h)
	add dx,ax	; 向dx中加上 ffff:1 单元的数值

	mov al,ds:[2]
	mov ah,0	; (ax)=((ds)*16+2)=(ffff2h)
	add dx,ax	; 向dx中加上 ffff:2 单元的数值

	mov al,ds:[3]
	mov ah,0	; (ax)=((ds)*16+3)=(ffff3h)
	add dx,ax	; 向dx中加上 ffff:3 单元的数值

	mov al,ds:[4]
	mov ah,0	; (ax)=((ds)*16+4)=(ffff4h)
	add dx,ax	; 向dx中加上 ffff:4 单元的数值

	mov al,ds:[5]
	mov ah,0	; (ax)=((ds)*16+5)=(ffff5h)
	add dx,ax	; 向dx中加上 ffff:5 单元的数值


	mov al,ds:[6]
	mov ah,0	; (ax)=((ds)*16+6)=(ffff6h)
	add dx,ax	; 向dx中加上 ffff:6 单元的数值

	mov al,ds:[7]
	mov ah,0	; (ax)=((ds)*16+7)=(ffff7h)
	add dx,ax	; 向dx中加上 ffff:7 单元的数值

	mov al,ds:[8]
	mov ah,0	; (ax)=((ds)*16+8)=(ffff8h)
	add dx,ax	; 向dx中加上 ffff:8 单元的数值

	mov al,ds:[9]
	mov ah,0	; (ax)=((ds)*16+9)=(ffff9h)
	add dx,ax	; 向dx中加上 ffff:9 单元的数值

	mov al,ds:[0ah]
	mov ah,0	; (ax)=((ds)*16+0ah)=(ffffah)
	add dx,ax	; 向dx中加上 ffff:a 单元的数值

	mov al,ds:[0bh]
	mov ah,0	; (ax)=((ds)*16+0bh)=(ffffbh)
	add dx,ax	; 向dx中加上 ffff:b 单元的数值

	mov ax,4c00h
	int 21h		; 程序返回

code ends
end
```

- 解析：（~~不只是为何，以上程序无法在 masm 中通过编译。没关系，知道大概的意思就行，不必太纠结于工具而浪费宝贵的时间！~~ 编译不通过的原因，竟然是，文件名中不能含特殊字符，于是将 "." 换成下划线就ok了。）

  以 `AX`  作为累加寄存器进行累加，重复十二次。当然，当内存范围更大时，这样的编程方式显然不可取。于是，刚刚学到的 **`loop`** 指令就可排上用场了。改进如下：

- 源程序2：

```asm
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,0ffffh
	mov ds,ax
	mov bx,0	; 初始化 ds:bx 指向 ffff:0

	mov dx,0	; 初始化累加器 dx
	mov cx,12	; 初始化训话计数器 cx
	
s:	mov al,[bx]
	mov ah,0
	add dx,ax
	inc bx		; bx 自增，指向下一个内存单元
	loop s
	
	mov ax,4c00h
	int 21h

codesg ends	;名为 codesg 的段到此结束

end
```



## 8.6 安全的内存空间和段前缀

- 安全的内存空间

  1. 在 8086 模式中，随意向一段内存空间写入内容是很危险的，因为这段空间可能存放着很重要的数据或这代码。

  2. 在 DOS 方式（实模式）下，一般情况，`0:200 ~ 0:2ff` 空间没有系统或其他程序的数据或代码。

- 段前缀

  前面我们已经在 **8.4 Debug 和 `masm` 对指令的不同处理** 一小节中看到，要想 `masm` 正确处理 `mov ax,[idata]` 类似的指令需要用 `bx` 做中转，或者显示地加上段寄存器，如 `mov ax,ds:[8]` 这种形式。

  此处的 **`ds:`** 就是**段前缀**，用于 **显示地指明内存单元的段地址**，类似的还有：**`cs:`** ，**`ss:`** ，**`es:`**.

## 实验四

- 编程，向内存 `0:200 ~ 0:23F` 依次传送数据 `0~63(3FH)`，程序中只能使用 9 条指令，9 条指令包括 `mov ax,4c00h` 和 `int 21h`。

  ```assembly
  assume CS:code
  code segment
  	MOV AX,0020h
  	MOV DS,AX
  	MOV bx,0
  	MOV CX,64
  
  s:	MOV [bx],bx
  	INC bx
  	LOOP s
  
  	MOV AX,4c00h
  	INT 21h
  
  code ends
  end
  ```

- 下面的程序的功能是将 `mov ax,4c00h` 之前的指令复制到内存 `0:200` 处，补全程序，上机调试，跟追运行结果。

  ```assembly
  assume CS:code
  code segment
  	MOV AX,___
  	MOV DS,AX
  	MOV AX,0020h
  	MOV ES,AX
  	MOV bx,0
  	MOV CX,___
  
  s:	MOV AL,[bx]
  	MOV ES:[bx],AL
  	INC bx
  	LOOP s
  
  	MOV AX,4c00h
  	INT 21h
  
  code ends
  end
  ```

  ~~这个问题很奇怪,`MOV AX,4c00h`到底前面问题的的程序里的指令还是什么别的？是在此之前的一条还是若干条指令，到底是啥意思？吾无奈阅读理解能力低下，并不能理解其深意。so，未完待续。。。。。~~



# 9. 包含多个段的程序

## 9.1 在代码段中使用数据和栈

- 直接看源程序9.1：

```assembly
assume CS:codesg
codesg segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		; 用 dw 定义 16 个字型数据，在程序加载之后，
		; 将取得 16 个字的内存空间，存放这 16 个数据。
		; 在后面的程序中将这段空间当做栈来使用

start:	MOV AX,CS
	MOV SS,AX
	MOV sp,30h	; 将设置栈顶 ss:sp 指向 cs:30h

	MOV bx,0
	MOV CX,8

s:	PUSH CS:[bx]
	ADD bx,2
	LOOP s		; 以上将代码段 0~15 单元中的
				; 8 个字型数据依次入栈

	MOV bx,0
	MOV CX,8

s0:	POP CS:[bx]
	ADD bx,2
	LOOP s0		; 以上依次出栈 8 个字型数据
				; 到代码段 0~15 单元中

	MOV AX,4c00h
	INT 21h

codesg ends
end start
```

- 解析：
  1. 此处我们用到了一个新的伪指令 **`dw`（define word）** 用来定义字型数据。此处定义了 8 个字型数据（数据之间用逗号隔开）。
  
  2. 注意此处在程序的第一条指令前加上了一个标号 **start** ，并且其在程序的末尾 **`end start`** 中再次出现。
  
  3. 所以需要说明伪指令 **end** 的作用：第一，通知编译器结束程序；第二，告诉编译器程序的入口在什么地方。**`end start`** 即告诉编译器程序的入口在标号 **start** 处。
  
  4. 上例中，指令 `MOV sp,30h` 的作用是将设置栈顶 `ss:sp` 指向 `cs:30h`，为什么是 `30h`？
  
     首先，我们用伪指令 `dw` 定义的连个段空间，这两个段的地址是相邻的，连续的。
  
     其次，两个段定义的空间分为别，8 个 和 16 个字，加起来就是 24 个字，也就是 48 个字节，也即 48 个内存单元，也就是 16 进制是 `30h` 了。所以就需要将 `ss:sp` 指向这段内存的最底部作为栈顶了。



## 9.2 将数据、代码、栈放入不同的段

上菜：

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,20h	; 设置栈顶 ss:sp 指向 stack:20h

	MOV AX,data
	MOV DS,AX	; ds 指向 data 段
	MOV bx,0	; ds:bx 指向 data 段中段第一个单元

	MOV CX,8
s:	PUSH [bx]
	ADD bx,2
	LOOP s		; 将以上 data 段中段 0~15 单元
			; 中的 8 个字型数据依次入栈

	MOV bx,0
	MOV CX,8
s0:	POP [bx]
	ADD bx,2
	LOOP s0		; 以上依次出栈 8 个字型数据到 
			; data 段的 0~15 单元中
	MOV AX,4c00h
	INT 21h

code ends
end start
```

- 从上例中可以看出，定义一个段与定义代码段没有区别，知识段名不同。

- 对段地址的引用

  在程序中 **段名** 代表 **段地址**，相当于一个标号。所以， `mov ax,data` 的含义就是将 **段名** 为 `data` 的 **段的段地址** 送入 `ax`.

- 一个段中的数据的段地址可有段名来表示，偏移地址就要看它哎段中的位置了。如上例中数据 `0abch` 的地址就是：`data:6`.

- 将上例中的  `data:6` 单元中的数据送入 `bx` 中，需要用以下程序：

  ```assembly
  mov ax,data
  mov ds,ax
  mov bx,ds:[6]
  ```

  而不能：

  ```assembly
  mov ds,data		; 错误
  mov bx,ds:[6]
  ```

  因为，**8086 CPU 不允许将一个数值直接送入 段寄存器！！！**

- “数据段”，“栈段”，“代码段”全都是我们自己的安排，那么：

  1. 这三个段分别用 `data`,`stack`,`code` 三个有具体含义的段名，CPU 是否就会因为这些段名按我们的意愿，把`data` 段中的内容当作数据段去执行？

     当然不会，这三个段名完全是我们方便阅读程序而取的段名，其完全可以用 `a`,`b`,`c` 这种没有具体含义的段名代替！

  2. 在源程序中，我们使用伪指令 **`assume CS:code,DS:data,SS:stack`** 将 `code` 段与 `cs`寄存器，`data`段与 `ds` 寄存器，`stack` 段 与 `ss` 寄存器 分别关联。那么 CPU 又是否会按照我们的想法 比如，将 `cs` 指向 `code`， 来处理这些段？

     也不会！再此，我们只知道，伪指令 **`assume`** 会将你定义的具有一定用途的段和相关寄存器联系起来。

  3.  CPU 如何使用我们定义的段与伪指令无关，而是由具体的汇编指令控制。

     本例中，我们用 `end start` 指令将程序的入口指定在 我们所定义的 `code` 段的第一条指令处。此就相当于 `code` 段相当于实际的代码段；而后

     ```assembly
     start:	MOV AX,stack
     		MOV SS,AX
     		MOV SP,20h	; 设置栈顶 ss:sp 指向 stack:20h
     ```

     三条指令将 我们定义的 `stack` **段的段地址** 送入 `ss` 寄存器中，并将 `ss:sp` 指向栈顶。此时，`stack` 段方才相当于一个栈空间，或者说一个栈段。由此可见，这个段的定义完全由我们使用汇编指令手动完成。

     将 `code` 段 定义为 数据段 也类似，由以下三条指令完成：

     ```assembly
     MOV AX,data
     MOV DS,AX	; ds 指向 data 段
     MOV bx,0	; ds:bx 指向 data 段中段第一个单元
     ```



## 实验五

- 第 (1) 题，源程序1

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	DW 0,0,0,0,0,0,0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends
end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.



- 第 (2) 题，源程序2

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h
data ends

stack segment
	DW 0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends
end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.

4. 对于如下定义的段：

   ```assembly
   name segment
   ...
   name ends
   ```

   如果段中的数据占 N 个字节，则程序加载后，该段的实际占有空间为 **16 字节**。



- 第 (3) 题，源程序 3

```assembly
assume CS:code,DS:data,SS:stack

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends

data segment
	DW 0123h,0456h
data ends

stack segment
	DW 0,0
stack ends

end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.



- 第 (4) 题，问：如果将 (1) (2) (3) 中最后一条伪指令 `end start` 改为 `end` （也就是不指明程序入口），那个程序仍可以正确执行？说明原因。

  *实践前的猜想* ：~~熟悉做题的套路的人都直到应该是第三个。因为就它跟前两个不一样。~~

  应该是是第三个，因为根据前面写程序的经验，在没有程序入口标号之前，所有段都是在代码段里执行的。而且当时并没有程序入口标号，更别提使用 `end` 伪指令指明程序入口，程序一样会从代码段执行，因此答案应该是源程序3.

  验证：结果与猜想基本一直，下面讨论一些细节问题。

  1. 以修改后的 源程序2 和 源程序 3 为例。与猜想一致，在没有指定程序入口后，代码段就有所不同。

     使用 `u cs:0` 命令后发现 源程序 2 的结果并不是直接指向 代码段的汇编指令，而 源程序 3 则是。

  2. 使用 `u cs:8` 依然看到代码段的汇编指令。猜想是，代码段和数据段总共加起来八个字节，如果按照定义的数据的大小，使用此命令后应该是能看到代码段的汇编指令的，为何？

     由此联想到 第 (2) 题 的第四小问：**如果段中的数据占 N 个字节，则程序加载后，该段的实际占有空间为 \_\_\_\_字节 **。按 第 (2) 题 的推断是 **16 字节**。于是，验证如下，先看看修改后的 源程序 3 的调试结果：

     ![ex5_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex5_1.png)

     再来看看 源程序 2：

     ![ex5_2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex5_2.png)

  - 结论：
    1. 如果段中的数据占 N 个字节，则程序加载后，该段的实际占有空间为 **16 字节**。
    2. 实验题要做，不做会漏掉很多知识点和细节问题。脚踏实地做实验有利于融会贯通。



- 第 (5) 题 编写 `code` 段的代码，将 a 段 和 b 段 的数据依次相加，结果存到 c 段中。

  我的答案：

  ```assembly
  assume CS:code
  a segment
  	DB 1,2,3,4,5,6,7,8
  a ends
  
  b segment
  	DB 1,2,3,4,5,6,7,8
  b ends
  
  c segment
  	DB 0,0,0,0,0,0,0,0
  c ends
  
  code segment
  
  start:	SUB bx,bx
  	MOV CX,8
  	
  s:	MOV AX,a
  	MOV DS,AX
  	SUB DX,DX
  	MOV DL,DS:[bx]
  
  	MOV AX,b
  	MOV DS,AX
  	SUB AX,AX
  	MOV AL,DS:[bx]
  	ADD DX,	AX
  
  	MOV AX,c
  	MOV DS,AX
  	MOV DS:[bx],DL
  
  	INC bx
  	LOOP s
  
  	MOV AX,4C00H
  	INT 21H
  
  code ends
  end start
  ```

  用了 16 条指令，`AX，BX，CX，DX` 四个16位通用寄存器，和 `AL，DL` 两个 8 位通用寄存器。暂时到这里，有时间想象怎么改进。



- 第 (6) 题：编写 `code` 段的代码，用 `push` 指令将 `a` 段中的前 8 个字型数据，逆序存储到 `b` 段中。

  我的答案：

  ```assembly
  assume CS:code
  a segment
  	DW 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
  a ends
  
  b segment
  	DW 0,0,0,0,0,0,0,0
  b ends
  
  code segment
  
  start:	MOV AX,a
  	MOV DS,AX
  	SUB bx,bx
  	MOV CX,8
  
  	MOV AX,b
  	MOV SS,AX
  	MOV sp,10h
  
  s:	PUSH [bx]
  	ADD bx,2
  	LOOP s
  
  	MOV AX,4C00H
  	INT 21H
  
  code ends
  end start
  ```

  从结果看没有什么问题，需要注意由于面向的是 字单元，因此相比上一个题目，数据的的偏移地址每次应增加 2，而不是一；类似的，栈顶指针应拨回 16 个内存单元，而不是 8 个。



# 10. 更灵活的定位内存地址的方法

## 10.1 `and` 和 `or` 指令

1. **`and`** 指令，逻辑 **与** 指令，按位进行与运算。

   该指令可将操作对象的相应位设为 0 ，其他位不变。例如：

   ```assembly
   and al,1011111B	; 将 al 的第六位置零
   and al,0111111B	; 将 al 的第七位置零
   and al,1111110B	; 将 al 的第零位置零
   ```

2. **`or`** 指令，逻辑 **或** 指令，按位进行或运算。

   该指令可将操作对象相应位设为 1，其他位不变。例如：

   ```assembly
   and al,0100000B	; 将 al 的第六位置一
   and al,1000000B	; 将 al 的第七位置一
   and al,0000001B	; 将 al 的第零位置一
   ```


> **注意** ： 
>
> **原书是从零开始计位**，本册子因为打了个马虎眼少看到个零，只能硬着头皮从一开始计位。
>
> 值得吐槽的是，在这里例子中王老师的书没有任何的提示。而在后面的 **大小写转换问题** 时，关于控制大小写字符的二进制位时，王老师才说 是第五位并在括号后面标注 **位数从 0 开始计算**。致使看书不仔细的我一直纠结到底是第六位还是第五位。。。。

## 10.2 关于ASCII 码

- 编码与解码：

  将信息存入计算机中需要对其进行编码，反之，取来时需要对其进行解码。编码和解码采用同一规则时，计算机便可对数据进行自由存取。而 **最早** 出现的编码规则就是 `ASCII`编码。关于更多编解码的问题可以参考博文 [【字符编码】彻底理解字符编码](https://www.cnblogs.com/leesf456/p/5317574.html)。

- 文本编辑器 编辑文本时 显示 文本内容 的过程：

  以键盘输入字符 `a` 并显示在屏幕上的过程为例：

  1. 按下键盘的 `A` 键，这个按键信息被送入计算机，计算机用 `ASCII` 码的规则对其进行编码，将其转换为 `61H`（`ASCII` 编码中，用 `61H` 表示 `a`） 存储再内容的指定空间中；
  2. 文本编辑器软件从内存中取出 `61H`，将其送到到显卡的显存中；
  3. 工作在文本模式下的显卡，用 `ASCII` 码的规则解释显存的内容，`61H` 被当作字符 `a` ，显卡驱动显示器，将字符 “a” 的图像画在屏幕上。

  

## 10.3 以字符形式给出的数据

- 在汇编程序我们可以用 `'.....'` 的方式指明数据是字符的形式给出的，编译器将把他们转换为相对应的 `ASCII` 码。如下例：

  ```assembly
  assume CS:code,DS:data
  data segment
  	DB 'Unix'
  	DB 'foRK'
  data ends
  
  code segment
  
  start:	MOV AL,'a'
  	MOV BL,'b'
  	MOV AX,4C00H
  	INT 21H
  code ends
  end start
  ```

- 调试信息：

  ![10_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/10_1.png)

  从以上信息我们可以看出，

  1. `DS` 段地址 + `10H` 就是数据段的段地址。
  2. 虽然 有两个字符串的定义，但是由于这个字符串都在同一数据段中，因此它们的内存地址是连续的，而不是分属两个段。
  3. 英文字母在内存中以 `ASCII` 码的形式存储。

## 10.4  大小写转换问题

- 部分大小写字母的 `ASCII` 码对比：

| 大写 | 十六进制 |  二进制  | 小写 | 十六进制 |  二进制  |
| :--: | :------: | :------: | :--: | :------: | :------: |
|  A   |    41    | 01000001 |  a   |    61    | 01100001 |
|  B   |    42    | 01000010 |  b   |    62    | 01100010 |
|  C   |    43    | 01000011 |  c   |    63    | 01100011 |
|  D   |    44    | 01000100 |  d   |    64    | 01100100 |
|  E   |    45    | 01000101 |  e   |    65    | 01100101 |

- 以上，发现规律：**大写字母** `ASCII` 码 **+ `20H =`**  对应的 **小写字母** 的 `ASCII` 码。

- 换而言之，字母的 `ASCII`码 **二进制** 的 **第六位** 决定这个是大小还是小写。

- 将 **大写字母** 的`ASCII`码 **二进制** **第六位** 置一（**`or al,00100000B`**）即可变成小写字母。

- 将 **小写字母** 的`ASCII`码 **二进制** **第六位** 置零（**`and al,11011111B`**）即可变成大写字母。

  （假设字母存储于寄存器 `al` 中，并且，二进制位 **从一开始计数！从一开始计数！！从一开始计数！！！**）

- 编程题：将第一个字符串转化为大写，第二个字符串转换为小写。

  ```assembly
  assume cs:code,ds:data
  data segment
  	db 'BaSiC'
  	db 'iNfOrMaTiOn'
  data ends
  
  code segment
  
  start:	mov ax,data
  		mov ds,ax	; 设置 ds 指向 data 段
  
  		mov bx,0	; 设置 (bx) = 0, bx 指向 'BaSiC' 的第一个字母
  		mov cx,5	; 设置循环次数 5, 因为 'BaSiC' 有五个字母
  
  s:		mov al,[bx]			; 将 ASCII 码从 ds:bx 所指向的单元取出
  		and al,11011111B	; 将 al 中的 ASCII 码的第六位置零，变成大写字母
  		mov [bx],al			; 将转化后的 ASCII 码写回源单元
  		inc bx				; (bx) 加一， ds:bx 指向下一个字母
  		loop s
  
  		mov bx,5			; 设置 (bx) = 5, ds:bx 指向 'iNfOrMaTiOn' 的第一个字母
  		mov cx,11			; 设置循环次数 11，因为 'iNfOrMaTiOn' 有十一个字母
  
  s0:		mov al,[bx]
  		or al,00100000B		;将 al 中的 ASCII 码的第六位置零，变成小写字母
  		mov [bx],al
  		inc bx
  		loop s0
  	
  		mov ax,4C00H
  		int 21H
  code ends
  end start
  ```




## 10.5 更多寻址方式

### 10.5.1 `[bx+idata]`

试看如下指令：

```assembly
mov ax,[bx+200]
```

表示：将一个字内存单元送入寄存器 `AX` 中，这个字单元的段地址在 段寄存器 `DS` 中，偏移地址为 `(bx)` 加上立即数（immediate data）200.

可用前面我们规定的规则对其进行解释：`(ax) = ( (ds)*16 + (bx)+200 )`.

这条指令还有其他常用格式：

```assembly
mov ax,[200+bx]
mov ax,200[bx]		; 是不是跟数组的形式很相似？
mov ax,[bx].200		; 跟结构体是不是有丁点关系？
```

- `[bx+idata]` 的应用：将下列程序中的`code`段中 第一个字符串转化为大写，第二个字符串转化为小写。

  1. 方法一，使用 `[bx]` ：

     ```assembly
     assume cs:code,ds:data
     data segment
     	db 'BaSiC'
     	db 'MinIX'
     data ends
     
     code segment
     
     start:	mov ax,data
     		mov ds,ax	
     
     		mov bx,0	
     		mov cx,5	
     
     s:		mov al,[bx]			
     		and al,11011111b	
     		mov [bx],al	
     		inc bx				
     		loop s
     
     		mov bx,5			
     		mov cx,5		
     
     s0:		mov al,[bx]
     		or al,00100000b
     		mov [bx],al
     		inc bx
     		loop s0
     	
     		mov ax,4C00H
     		int 21H
     code ends
     end start
     ```

  2. 方法二，使用 `[bx+idata]`

     ```assembly
     assume cs:code,ds:data
     data segment
     	db 'BaSiC'
     	db 'MinIX'
     data ends
     
     code segment
     
     start:	mov ax,data
     		mov ds,ax	
     
     		mov bx,0	
     		mov cx,5	
     
     s:		mov al,[bx]		; or  mov al,0[bx]	
     		and al,11011111b	
     		mov [bx],al		; or  mov 0[bx],al
     
     		mov al,[5+bx]	; or  mov al,5[bx]
     		or al,00100000b
     		mov [5+bx],al	; or  mov 5[bx],al
     		
     		inc bx		
     		loop s
     
     		mov ax,4C00H
     		int 21H
     code ends
     end start
     ```

     *说实话，要不是两个字符串都刚好长度为 5的话，即使 `[bx+idata]` 这种方式也不能使程序更简洁。。。*

- 以上程序类比 C 语言描述：

  ```c
  char a[5] = "BaSiC";
  char b[5] = "MinIX";
  
  void main(){
      int i = 5;
      do{
          a[i] = a[i] & 0xDF;
          b[i] = b[i] | 0x20;
      }while(i<5);
  }
  ```

  类比一下：

  C 语言：	`a[i]`，	`b[i]`

  汇编语言：`0[bx]`，`5[bx]`

  结论是：*`[bx+idata]` 方式为高级语言实现数组提供了便利机制。* 这就是复杂指令集的特征，不保证硬件的简单性，而保持指令的简洁性，因此更接近高级语言。



### 10.5.2 SI 和 DI

**SI 和 DI** 是 8086 CPU 中和 **BX** 功能相近的寄存器，**SI 和 DI 不能分成两个 8 位寄存器**。

示例1：`#1,#2,#3` 实现相同的功能

```assembly
mov bx,0
mov ax,[bx]		; #1

mov si,0
mov ax,[si]		; #2

mov di,0
mov ax,[di]		; #3
```
示例2：`#1,#2,#3` 也是实现相同的功能

```assembly
mov bx,0
mov ax,[bx+123]		; #1

mov si,0
mov ax,[si+123]		; #2

mov di,0
mov ax,[di+123]		; #3
```



### 10.5.3 `[bx+si]` 和 `[bx+di]`

`[bx+si]` : 段地址为 `(ds)` ,偏移地址为 `((bx)+(si))` 的内存单元。或者说，地址为 `(ds)*16 +((bx)+(si)) ` 的内存单元。

可以有其他格式：

```assembly
mov ax,[bx][si]		; 等价于 mov ax,[bx+si]
mov ax,[bx][di]		; 等价于 mov ax,[bx+di]
```



### 10.5.4 `[bx+si+idata]` 和 `[bx+di+idata]`

二者相似，以`mov ax,[bx+si+idata]` 示例，

`[bx+si+idata]` 表示一个内存单元，它的地址是 `(ds)*16 + ((bx)+(si)+idata)`，将其值送入 寄存器 `ax` 中。

也可写作以下常用格式：

```assembly
mov ax,[bx+200+si]
mov ax,[200+bx+si]
mov ax,200[bx][si]
mov ax,[bx].200[si]
mov ax,[bx][si].200
```



### 10.5.5 不同寻址方式的应用

- 源程序10_5，将 `dataseg` 段中每个单词改为大写字母，（*原书 问题 7.7，154页*）

  ```assembly
  assume cs:code,ds:data
  data segment
  	db 'ibm             '	; 每个字符串长度都为 16，以空格补缺
  	db 'dec             '
  	db 'dos             '
  	db 'vax             '
  data ends
  
  code segment
  
  start:	mov ax,data
  		mov ds,ax	
  
  		mov bx,0	
  		mov cx,4
  
  s0:		mov dx,cx		; 将外层循环 cx 的值保存在 dx 中
  		mov si,0
  		mov cx,3
  
  s:		mov al,[bx+si]
  		and al,11011111b
  		mov [bx+si],al
  		inc si
  		loop s
  
  		add bx,16
  		mov cx,dx
  		loop s0		; 外层循环 loop 指令将 cx 中的计数值减一
  
  		mov ax,4C00H
  		int 21H
  code ends
  end start
  ```

  由于此程序中使用了比较多的寄存器，对于更复杂的情况不具有代表性，因此，本书做了如下改进：源程序10_6

  ```assembly
  assume cs:code,ds:data,ss:stack
  data segment
  	db 'ibm             '	; 每个字符串长度都为 16，以空格补缺
  	db 'dec             '
  	db 'dos             '
  	db 'vax             '
  data ends
  
  stack segment
  	dw 0,0,0,0,0,0,0,0
  stack ends
  
  code segment
  
  start:	mov ax,stack
  		mov ss,ax
  		mov sp,16
  		
  		mov ax,data
  		mov ds,ax
  		mov bx,0
  
  		mov cx,4
  
  s0:		push cx		; 将外层循环 cx 的值压栈
  		mov si,0
  		mov cx,3
  
  s:		mov al,[bx+si]
  		and al,11011111b
  		mov [bx+si],al
  		inc si
  		loop s
  
  		add bx,16
  		pop cx		; 从栈顶弹出原 cx 的值，恢复 cx
  		loop s0		; 外层循环 loop 指令将 cx 中的计数值减一
  
  		mov ax,4C00H
  		int 21H
  code ends
  end start
  ```

  和上一个程序不一样，此程序并没有外层循环的变量 `(cx)` 储存在寄存器中，而是先放在预先定义好的栈空间里。由此引出一些汇编的固有规则：

  1. 尽可能**少**地**使用寄存器**，因此寄存器数量有限，资源很昂贵。
  2. 一般来说数据需要**暂存**时，尽量使**用栈**。

  附图两张：

  源程序 10_5，调试图

  ![10_5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/10_5.png)

  源程序 10_6 调试图

  ![10_6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/10_6.png)



## 实验六

问题 7.9 将 `data` 中的每个单词的前四个字母改为大写字母。

```assembly
assume cs:code,ds:data,ss:stack
stack segment
	dw 0,0,0,0,0,0,0,0
stack ends

data segment
	db '1. dispaly      '		; 每个字符串长度都为 16，空格补缺
	db '2. brows        '		; 小数点与 单词之间用一个空格隔开
	db '3. replace      '
	db '4. modify       '
data ends

code segment

start:	mov ax,stack
		mov ss,ax
		mov sp,16
		
		mov ax,data
		mov ds,ax
		mov bx,0

		mov cx,4

s0:		push cx		; 将外层循环 cx 的值压栈
		mov si,0
		mov cx,4

s:		mov al,[3+bx+si]
		and al,11011111b
		mov [3+bx+si],al
		inc si
		loop s

		add bx,16
		pop cx		; 从栈顶弹出原 cx 的值，恢复 cx
		loop s0		; 外层循环 loop 指令将 cx 中的计数值减一

		mov ax,4C00H
		int 21H
code ends
end start
```

~~这个题目没有多做思考，完全套用源程序10_6，看到对栈如此娴熟地使用，不得不心生佩服，妙，实在是妙啊。这要让我不参考，闷头去想，估计一上午就没了。。。~~



# 11. 数据处理的两个基本问题

定义两个描述性符号：

`reg` 表示一个寄存器，`reg` 的集合包括：`ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di`；

`sreg` 表示一个段寄存器，`sreg` 的集合包括：`ds, ss, cs, es`.

## 11.1 `bx、si、di、` 和  `bp`

1. 在 8086 CPU 中，**只有这四个** 寄存器 **可以** 用在 "[...]" 中来进行内存单元的 **寻址**。如下例：

   ```assembly
   mov ax,[bx]
   mov ax,[bx+si]
   mov ax,[bx+di]
   mov ax,[bp]
   mov ax,[bp+si]
   mov ax,[bp+di]
   ```

   下面的指令都是 **错误** 的：

   ```assembly
   mov ax,[cx]		# error
   mov ax,[ax]		# error
   mov ax,[dx]		# error
   mov ax,[ds]		# error
   ```

   

2. 这四个寄存器可以 **单个出现**：**`[bx]`，`[bp]`、`[si]`、`[di]`**;

   或 **只能** 以四种组合出现：`bx` 和 `si` 、`bx` 和 `di` 、`bp` 和 `si` 、`bp` 和 `di`.

   |      |            `si`            |            `di`            |
   | :--: | :------------------------: | :------------------------: |
   | `bx` | `[bx+si]`、`[bx+si+idata]` | `[bx+di]`、`[bx+di+idata]` |
   | `bp` | `[bp+si]`、`[bp+si+idata]` | `[bp+di]`、`[bp+di+idata]` |



3. 只要在 `[...]` 中使用寄存器 **`bp`** ，而指令中 **没有**显示地**给出段**地址，**段地址** 就 **默认在**栈段寄存器 **`ss`** 中。如下例：

   ```assembly
   mov ax,[bp]		; 段地址默认在 ss 中
   mov ax,[bp+si]	; 段地址默认在 ss 中
   mov ax,ds:[bp]	; 段地址显示地给出在 ds 中
   ```

   



## 11.2 机器指令处理的数据在什么地方

1. 绝大部分机器指令都是进行 **数据处理** 指令，处理大致可分为 3 类：**读取**、**写入**、**运算**。

2. 机器指令不关心数据的值几何，只关心 **指令执行前一刻**，它将要处理的**数据所在**的**位置**。

3. 指令执行前，所要处理的数据可以存在以下 **三** 个地方：

   CPU 内部，内存，端口。

   如下例：

   |   机器码   |   汇编指令   | 指令执行前数据的位置  |
   | :--------: | :----------: | :-------------------: |
   | `8E1E0000` | `mov bx,[0]` |  内存，`ds[0]` 单元   |
   |   `89C3`   | `mov bx,ax`  | CPU 内部，`ax` 寄存器 |
   |  `BB0100`  |  `mov bx,1`  | CPU 内部，指令缓冲器  |



## 11.3 汇编语言中数据位置的表达

汇编语言用 3 个概念来表达数据的位置：

1. **立即数** （`idata`）

   对于直接**包含在** 机器 **指令中** 的数据（执行前在 CPU 的 **指令缓冲器** 中），在汇编语言中被称为  **立即数**。 在汇编指令中直接给出。如下例：

   ```assembly
   mov ax,1
   mov bx,200h
   mov bx,010000b
   mov al,'a'		; 单个字符也属于立即数
   ```

   - 注意：

      单个字符也属于立即数，但是汇编指令中还是会以 `ascii ` 码的形式存储，跟数值没有什么区别，因此，除了`push` 这类特殊指令外，在没有寄存器参的指令中也写需要使用 `X ptr` 向编译器指明操作对象所占的字节数。

     

2. **寄存器**

   指令要处理的**数据在寄存器中**，在汇编指令中给处相应的寄存器名。如下例：

   ```assembly
   mov ax,bx
   mov ds,ax
   push bx
   mov ds:[0],bx		;ds:[0] 是存在内存中的吧
   push ds
   mov ss,ax
   mov sp,ax
   ```

   

3. 段地址（**SA**） 和 偏移地址（**EA**）

   指令要处理的数据存在**内存**中，在汇编指令中可用 **[X]** 的格式给出**EA**，**SA** 在某个段寄存器中。存放段地址的寄存器可以是默认的，比如：

   ```assembly
   mov ax,[bx+si+8]	; 段地址默认在 ds 中
   mov ax,[bp+si+8]	; 段地址默认在 ss 中
   mov ax,ds:[bp]		; 段地址显示地给出在 ds 中
   mov ax,es:[bx]		; 段地址显示地给出在 es 中
   ```



## 11.4 寻址方式

用 **偏移地址** 来定位内存的方法被称为 **寻址方式**。分为以下几种：

### 11.4.1 直接寻址

|     名称     | 寻址方式  |        含义        | 常用格式举例 |
| :----------: | :-------: | :----------------: | :----------: |
| **直接寻址** | `[idata]` | `SA=idata,EA=(ds)` |  `[idata]`   |

### 11.4.2 寄存器间接寻址

| 寻址方式 |       含义        | 常用格式举例 |
| :------: | :---------------: | :----------: |
|  `[bx]`  | `SA=(bx),EA=(ds)` |    `[bx]`    |
|  `[si]`  | `SA=(si),EA=(ds)` |    `[si]`    |
|  `[di]`  | `SA=(di),EA=(ds)` |    `[di]`    |
|  `[bp]`  | `SA=(bp),EA=(ss)` |    `[bp]`    |

### 11.4.3 寄存器相对寻址

|   寻址方式   |          含义           |            常用格式举例             |
| :----------: | :---------------------: | :---------------------------------: |
| `[bx+idata]` | `SA=(bx)+idata,EA=(ds)` |      用于结构体：`[bx].idata`       |
| `[si+idata]` | `SA=(si)+idata,EA=(ds)` | 用于数组：`idata[si]` ，`idata[di]` |
| `[di+idata]` | `SA=(di)+idata,EA=(ds)` |     用于二维数组：`[di][idta]`      |
| `[bp+idata]` | `SA=(bp)+idata,EA=(ss)` |                 ——                  |

### 11.4.4 基址变址寻址

| 寻址方式  |          含义          |       常用格式举例       |
| :-------: | :--------------------: | :----------------------: |
| `[bx+si]` | `SA=(bx)+(si),EA=(ds)` | 用于二维数组：`[bx][si]` |
| `[bx+di]` | `SA=(si)+(di),EA=(ds)` |            ——            |
| `[bp+si]` | `SA=(bp)+(di),EA=(ds)` |            ——            |
| `[bp+di]` | `SA=(bp)+(di),EA=(ss)` |            ——            |

### 11.4.5 相对基址变址寻址

|    寻址方式     |             含义             |                    常用格式举例                    |
| :-------------: | :--------------------------: | :------------------------------------------------: |
| `[bx+si+idata]` | `SA=(bx)+(si)+idata,EA=(ds)` |           用于二维数组：`idata[bx][si]`            |
| `[bx+di+idata]` | `SA=(si)+(di)+idata,EA=(ds)` | 用于表格（结构）中的数据项：<br />`[bx].idata[si]` |
| `[bp+si+idata]` | `SA=(bp)+(di)+idata,EA=(ds)` |                         ——                         |
| `[bp+di+idata]` | `SA=(bp)+(di)+idata,EA=(ss)` |                         ——                         |



## 11.5 指令要处理的数据有多长

在 8086 CPU 指令中，可以处理两种尺寸的数据：**`byte`** 和 **`word`**. 所以在指令中要指明，要进行的是字操作还是字节操作。以下是处理方法：

1. 通过 **寄存器名** 指明要处理的数据的尺寸。如下例：

   ```assembly
   mov ax,1		; 字操作
   mov bx,ds:[0]	; 字操作
   
   mov al,8		; 字节操作
   mov bl,ds:[0]	; 字节操作
   ```

   

2. 在没有寄存器名的情况下，用操作符 **`X ptr`** 指明内存单元的长度，**`X`**  在汇编指令中可以是 **word** 或 **byte** . 如下例：

    ```assembly
   mov word ptr ds:[0],1	; 字操作
   inc word ptr [bx]		; 字操作
   add word ptr [bx],2		; 字操作
   
   mov byte ptr ds:[0],1	; 字节操作
   inc byte ptr [bx]		; 字节操作
   add byte ptr [bx],2		; 字节操作
   ```

   
   
3. 其他方法，某些指令默认访问的是字单元还是字节单元，如 出栈操作 **`pop`** 和 入栈操作 **`push`**，就规定是字操作。例如：

    ```assembly
    push [100H]		; 将 (ds)*16 + 100H 处的字单元压入栈中。
    ```



## 11.6 寻址方式的综合应用

下面通过一个问题来讨论以下寻址方式的作用。

关于 DEC 公司的一条记录（1982年）如下：

公司名称：DEC

总裁姓名：Ken Olsen

排名：137

收入：40（亿美元）

著名产品：PDP（小型机）

这些数据在内存种以如下图的方式存放：

![11_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/11_1-1599730523302.png)

假设这些数据被存放在 `seg` 段中，从偏移地址 60H 的起始位置开始。

到 1988 年 该公司的信息有了如下变化：

(1) Ken Olsen 在富豪榜上的排名升至 38 位；

(2) DEC 的收入增加了 70 亿美元；

(3) 该公司的著名产品已变为 VAX 系列计算机。

于是，我们要对这三条信息进行相应的修改，以汇编语言的形式，我们有如下程序：

```assembly
mov ax.seg
mov ds,ax
mov bx,60h	; 确定记录地址：ds;bx

mov word ptr [bx+0ch],38	; 排名字段改为 38
add word ptr [bx+0eh],70	; 收入字段增加 70

mov si,0			; 用 si 来定位产品字符串中的字符
mov byte ptr [bx+10h+si],'V'
inc si
mov byte ptr [bx+10h+si],'A'
inc si
mov byte ptr [bx+10h+si],'X'
```

用 C 语言描述这个程序：

```c
struct company {	/* 定义一个公司记录的结构体 */
    char cn[3];		/* 公司名称 */
    char hn[9];		/* 总裁姓名 */
    int pm;			/* 排   行 */
    int st;			/* 收   入 */
    char cp[3];		/* 著名产品 */
}

/* 定义一个公司记录的结构体变量，内存中将存有一条公司的记录 */
struct company dec = {"DEC","Ken Olsen",137,40,"PDP"}

int main()
{
    int i;
    dec.pm = 38;
    dec.st += 70;
    i = 0;
    dec.cp[i] = 'V';
    i++；
    dec.cp[i] = 'A';
    i++;
    dec.cp[i] = 'X';
    return;
}
```

接下来按 C 语言的风格对上面的汇编程序进行修改，好好体会一下：

```assembly
mov ax.seg
mov ds,ax
mov bx,60h	; 确定记录地址：ds;bx

mov word ptr [bx].0ch,38	; 排名字段改为 38
add word ptr [bx].0eh,70	; 收入字段增加 70

mov si,0			; 用 si 来定位产品字符串中的字符
mov byte ptr [bx].10h[si],'V'
inc si
mov byte ptr [bx].10h[si],'A'
inc si
mov byte ptr [bx].10h[si],'X'
```



## 11.7 div 指令

`div` 就是除法指令，其中操作对象的关系如下表示：

| 除数  |                 被除数                  |  商  | 余数 |
| :---: | :-------------------------------------: | :--: | :--: |
| 8 位  |           16 位，默认存 `AX`            | `AL` | `AH` |
| 16 位 | 32 位，`DX` 存高 16 位，`AX` 存低 16 位 | `AX` | `DX` |

- 格式如下：

  ```
  div reg
  div 内存单元
  ```

  `reg` 和 内存单元 里存放的都是 除数。

- 实例如下：

  ```assembly
  div byte ptr es:[9]		; 除数是 (es:[9]), 被除数是 (ax)
  div word ptr [bx+si+8]	; 除数是 (ds:[bx+si+8]),
  						; 被除数是 (DX)*1000H + (AX)
  ```

概念就这么多，要想熟练多加练习吧。



## 11.8 伪指令 `dd` 和 `dup` 操作符

​	和 `db`,`dw` 类似，`dd` 也是由编译器识别的伪指令。

**`dd`** 是用来定义 **`dword`** (double word, 双字) 型数据的。如下例：

```assembly
data segment
	dw 1	; 占一个字节
	dd 1	; 占两个字节
data ends
```

第一个数据在 `data:0` 处，

第二个数据在 `data:2` 处，占两个字节。

---

**`dup`** 是一个操作符，和 **`dd`** 一样，由编译器识别处理。它用来与伪指令 `db`,`dw`,`dd` 等数据定义的伪指令配合使用，用来进行 **数据的重复**。如下例：

```assembly
db 3 dup (0)	; 定义了 3 个字节，他们的值都是零，相当于 db 0,0,0
db 3 dup (1,2,3) ; 定义了 9 个字节，相当于 db 1,2,3,1,2,3,1,2,3
db 3 dup ('abc') ; 定义了 9 个字节，相当于 db 'abcabcabc'
```



## 实验七

题目：

Power idea 公司从 1975 年成立一直到 1995 年的基本情况如下。

| 年份 | 收入（千美元） | 雇员（人） | 人均收入（美元） |
| :--: | :------------: | :--------: | :--------------: |
| 1975 |       16       |     3      |        ？        |
| 1976 |       22       |     7      |        ？        |
| ...  |                |            |                  |
| 1995 |    5937000     |   17800    |        ?         |

下面的程序中已经定义好了这些数据：

```assembly
data segment
	db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
	db '1984','1985',1986','1987','1988','1989','1990','1991','1992'
	db '1993','1994','1995'
	; 以上是表示 21 年的字符串
	
	dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
    ;以上是表示21年公司总收入的21个dword型数据
    
    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
    dw 11542,14430,15257,17800
    ;以上是表示21年公司雇员人数的21个word型数据
data ends

table segment
	db 21 dup ('year summary')
table ends
```

编程，将 data 段中的数据按如下格式写入到 table 段中，并计算 21 年中的人均收入（取整），结果也按照下面的格式保存在 table 段中。

![ex7](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex7.png)

我的答案：

```assembly
assume CS:code

data segment
	db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
	db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
	db '1993','1994','1995'
	; 以上是表示 21 年的字符串
	
	dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
    ;以上是表示21年公司总收入的21个dword型数据
    
    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
    dw 11542,14430,15257,17800
    ;以上是表示21年公司雇员人数的21个word型数据
data ends

table segment
	db 21 dup ('year summ ne ?? ')
table ends

code segment
	
start:	mov ax,data
		mov ds,ax

		mov ax,table
		mov es,ax

		mov bx,0
		MOV DI,0
		mov si,0
		mov cx,21

s:		mov ax,ds:[bx]
		mov es:[si],ax
		mov ax,ds:[2+bx]
		mov es:[2+si],ax				; 0~3 列，年份

		mov BYTE ptr es:[4+si],' '		; 4 列，空格

		mov ax,ds:[54h+bx]
		mov es:[5+si],ax
		mov dx,ds:[56h+bx]
		mov es:[7+si],dx				; 5~8 列，被除数，收入	
		
		div WORD ptr ds:[0a8h+di]
		mov es:[0dh+si],ax				; d~e 列，商，人均收入取整

		mov BYTE ptr es:[9+si],' '		; 9 列，空格

		mov ax,ds:[0a8h+di]
		mov es:[0ah+si],ax				; a~b 除数，雇员

		MOV BYTE ptr es:[0ch+si],' '	; c 列，空格

		MOV BYTE ptr es:[0fh+si],' '	; f 列，空格
		
		ADD DI,2
		ADD bx,4
		add si,10h

		loop s

		MOV AX,4C00H
		INT 21H

code ends
end start
```

- 编程总结：

1. 拼写错误，比如段定义语句拼写错误。
2. 未指明操作对象所占字节大小。比如 `MOV BYTE ptr es:[0ch+si],' '` 经常性忽视掉 `byte ptr` 标记。
3. `assume` 伪指令，比如，`ds:data`，但是忽略了 `table` 段也在数据段中；定义了栈段却没有用 `assume` 伪指令关联。导致报错不断。

- 思考：

  没有什么巧妙的设计思路，就是乱堆，几乎用掉了所有能用到的寄存器。没有用到栈。暂且如此，待*(bu)*来*(ke)*日*(neng)*优化。结果如下图：

  ![ex7_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex7_1.png)



# 12. 转移指令的原理








#  Question & No answer

## 1. 关于8086 CPU 最大寻址范围的问题

根据 8086 CPU 和成物理地址的方式，我们可以知道 8086 CPU 的寻址能力为 $2^{20}$，也就是 1 M，其寻址范围应为 `00000 ~ FFFFF`，用段地址和偏移地址表示为 `0000:0000 ~ F000:FFFF`. 但是使用 Debug 程序无论是 D 命令访问，A 或 E 命令写入 在这范围之外的物理地址如 `F001:FFFF`，都不会被 Debug 告知有什么错误，还能返回结果。这是为何？

Debug程序 使用的环境为 xp 系统的虚拟机。



## 2. 关于 SP + 2 的值 赋给 SP 后 SP 的值

 本书**问题3.11** 说到，“SP 原来为FFFEH，加二后 SP = 0”，对此心中存疑，于是打开虚拟机上的 xp 系统，用 debug 程序进行了测试，结果如下图

![x1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/x1.png)

结果没有任何问题，哈哈，但是上一次结果并不是这样滴。

因为 SP 是 16 位寄存器，所以 SP + 2 的值赋给 SP 其结果溢出后会舍去溢出的不放呢，所以结果如此。

# Study Conclusion

1. 学习有主线和副线，要明确主线。

   在学习的过程中往往会遇到很多陌生的名词和知识点，这些东西对于后面的学习可能会有暂时阻碍。努力地去清除这些阻碍本无可厚非，但是不要将好奇心无限放大，越走越远，偏离学习的主线。以往的学习经验告诉我，这非但不会使我变得博学，而是变得更肤浅并浪费大把时间。记住，不要本末倒置。

2. 注重基础的学习，而不是工具和框架。

   新奇的东西确实会吸引眼球，让人有获得的欲望。但是不要忘记，再华丽花哨的东西都不是凭空而来的，它是在旧事物的基础上发展而来的。例如，看上去吸引眼球的逆向，有各种工具和方法，但是不变的是其核心是汇编指令，所有的逆向相关的书籍都会有汇编指令的内容，有些是 x86，有些是 x64，但是不管x86 还是x64 其基础都不会脱离 实模式。所以，应该把百分之八十的时间花在基础和底层知识的学习上，其余时间用来学习工具和框架才对。

   



[^1]: 本参考书出于教学考虑，将总线简单定义为 “连接CPU和其他芯片的导线”，不能解答某些疑问，故引用百科[总线](https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF)词条。
[^2]: 此分类与本参考书略微不同，本参考书描述上似乎将通用寄存器的范围限制在本小节所参考博文 [8086CPU各寄存器及其简介](https://blog.csdn.net/weixin_40913261/article/details/90762210)的数据寄存器之内，与百科锁定并由[“科普中国”科学百科词条编写与应用工作项目](https://baike.baidu.com/science) 所审核的 [通用寄存器](https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/283978?fr=aladdin) 词条不一致，遂以更符合权威部门所审定的参考博文为主。

[^3]:一个程序或者类库更新到较新的版本后，用旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。--百度词条[向下兼容](https://baike.baidu.com/item/%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9?fromtitle=%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9&fromid=94553)。

[^4]: 这两句话都引自 《Beginning x64 Assembly Programming: From Novice to AVX Professional》 一书，作者 Jo Van Hoey.
[^4]: 