*王爽《汇编语言》第三版 一书读书笔记*



[TOC]

# 1. 基础知识
## 1.1 机器语言
### 1.1.1 概念

机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字。计算机将之转换为一列高低电平以使计算机的电子期间受到驱动进行运算。

## 1.2 汇编语言
### 1.2.1 概念
1. 机器语言难以记忆和书写，与汇编语言产生。汇编语言主体是汇编指令，与机器语言的区别在于表达方法上。
2. 汇编语言由编译器翻译成机器码交给计算机执行。

### 1.2.2 语言成分
汇编语言由以下三部分组成：

1. 汇编指令：机器码对应的助记符，**有对应的机器码**。
2. 伪指令：没有对应的机器码，由编译器执行，计算机不执行。
3. 其他符号：如 `+、-、*、\` 等符号，由编译器识别，没有对应的机器码。

## 1.3 其他基本概念
1. 内存：

   1. 数据和指令存在的位置。
   2. 内存不是磁盘的容量（比如 1 TB 的硬盘），磁盘上的数据或程序如果不读入内存就无法被 CPU 使用。
   3. 每个存储器被划分为若干个存储单元，每个存储单元从 0 开始编号。

2. 计算机的最小 **信息单位** 是 **bit**（比特），一个二进制位。

3. 计算机最小的 **存储单位** 是 **Byte**，称一个 **字节**。

4. **两个字节为一个字**（word），刚好为一个 8086 CPU 寄存器的位数（16位）。

5. 单位换算：

   **8  bit = 1 Byte**

   **2 Byte = 1 Word**

   **1 KB = 1024 Byte**

   **1 MB = 1024 KB**

   **1 GB = 1024 MB**

   **1 TB = 1024 GB**

6. 内存地址空间：地址总线宽度下，可寻址范围极为 CPU 的内存地址空间。例如，一个 CPU 的地址总线宽度为 10 ,那么可寻址 $2^{10}$ 个内存单元。这 1024 个内存单元即是 CPU 的内存地址空间。

7. CPU 不能直接对外设进行控制，直接控制外设的是与这些外设相连接的扩展插槽上的接口卡。扩展插槽和接口卡通过总线与 CPU 相连，**CPU 通过 接口卡间接控制外设**。某些接口上装有 RAM，用来对大批量输入输出的数据进行暂存，例如显卡的显存。更多 CPU 控制外设的内容在后续外中断章节还会提到。

   

## 1.4 CPU 对存储器的读写

1. 必要条件：

   CPU 对存储器进行读写需要其他芯片提供以下三类信息：

   - 存储单元的地址信息
   - 器件的选择，读写命令。（控制信息）
   - 读写的数据信息。

2. 读写过程（仅以读为例）

   - CPU 通过地址总线将地址信息 3 发出。
   - CPU 通过控制总线发出读内存命令，选中存储器芯片，并通知它将要从中读取数据。
   - 存储器将 3 号单元的数据 8 通过数据线送入 CPU.

- 示意图（CPU 从三号单元读取数据的过程）
![1.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.4.png)



## 1.5 总线

### 1.5.1 概念[^1]

  总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由[导线](https://baike.baidu.com/item/导线/1413914)组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为[数据总线](https://baike.baidu.com/item/数据总线/272650)、[地址总线](https://baike.baidu.com/item/地址总线/4307936)和[控制总线](https://baike.baidu.com/item/控制总线/272568)，分别用来传输数据、数据地址和[控制信号](https://baike.baidu.com/item/控制信号/10329713)。总线是一种内部结构，它是cpu、内存、输入、[输出设备](https://baike.baidu.com/item/输出设备/10823333)传递信息的公用通道，[主机](https://baike.baidu.com/item/主机/455151)的各个部件通过总线相连接，[外部设备](https://baike.baidu.com/item/外部设备)通过相应的接口电路再与总线相连接，从而形成了[计算机硬件系统](https://baike.baidu.com/item/计算机硬件系统/8092895)。在计算机系统中，**各个部件之间传送信息的公共通路叫总线**，[微型计算机](https://baike.baidu.com/item/微型计算机/9287)是以[总线结构](https://baike.baidu.com/item/总线结构/10183496)来连接各个[功能部件](https://baike.baidu.com/item/功能部件/8514356)的。

### 1.5.2 逻辑分类

  从逻辑上分为以下三类：地址总线，控制总线，数据总线。

- **地址总线**：CPU 通过地址总线指定存储器单元。地址总线的宽度决定 CPU 的寻址范围。（更多有关地址总线的问题在后面寻址有关问题再讨论）

- **数据总线**：CPU 与 内存之间的数据传送通过数据总线进行传送。数据总线的宽度决定了 CPU 和 外界的数据传输速度。例如，8 根数据总线一次可以传输 一个字节的数据。

- **控制总线**：CPU 通过 控制总线控制外部器件。控制总线决定对外部器件的控制能力（能控制多少外部器件）。控制总线的方向是双向的，CPU 通过控制总线发送控制信息给其他器件，反之其他器件也通过控制总线发送反馈信息给  CPU.

### 1.5.3 南北桥芯片

  南北桥芯片是主板上的**总线控制器芯片**。

![1.5.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.5.3.png)

- 北桥芯片：

  北桥芯片通过前端总线直接与 CPU相连。用于高速信号，CPU 信号，RAM信号和 GPU 信号。AMD 在 K8 系列后将内存控制器集成在 CPU 中，因此 AMD系的主板上的北桥芯片不再控制内存。

- 南桥芯片


##  1.6 内存地址空间

- 基本概念：

  所有的物理存储器都被 CPU 看作**一个**由若干存储单元组成的**逻辑存储器**，也即**内存地址空间**。每个物理存储器在这个逻辑存储器中都有一个地址段，即一段地址空间。示意图如下：

- CPU 的逻辑存储器

  ![1.6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.6.png)

- 限制因素：

  内存地址空间的大小受**地址总线宽度**的限制，8086 CPU 的地址**总线宽度为 20**，即 20 跟地址线，可表示从 1 到 ($2^{20}$ -1) 的 $2^{20}$ 个不同的地址信息，即可**定位 $2^{20}$  个内存单元**，也即**可寻址** $2^{20}$  个地址空间**，则其内存地址空间大小为 1 MB**，**寻址能力**为 **1 MB**。



# 2. 初识寄存器

## 2.1 CPU 内部基本构造

CPU 的由运算器、寄存器、控制器等器件组成，这些器件靠**内部总线**相连，**外部总线**实现 CPU 和主板上其他器件的联系。CPU内部工作原理简单总结如下：

- 运算器进行信息处理。

- 寄存器进行信息存储。

- 控制器控制各种器件进行工作。

- 内部总线连接各种器件，在他们直接发送数据。

  

## 2.2 寄存器分类一览

来源 : [8086CPU各寄存器及其简介](https://blog.csdn.net/weixin_40913261/article/details/90762210)



**8086 CPU 中寄存器总共为 14 个，且均为 16 位 。**

即 **AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES** 共 14 个。

而这 14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。

### 2.2.1 通用寄存器

**数据寄存器：AX，BX，CX，DX **[^2]
| 标识 | 名称 |
| :--: |:--: |
|**AX** (Accumulator) | 累加寄存器，也称之为累加器 |
|**BX** (Base) | 基地址寄存器 |
|**CX** (Count) | 计数器寄存器 |
|**DX** (Data) | 数据寄存器 |



**指针寄存器：SP 和 BP **
|          标识          |      名称      |
| :--------------------: | :------------: |
| **SP** (Stack Pointer) | 堆栈指针寄存器 |
| **BP** (Base Pointer)  |  基指针寄存器  |

**变址寄存器：SI 和 DI **
|            标识            |      名称      |
| :------------------------: | :------------: |
|   **SI** (Source Index)    |  源变址寄存器  |
| **DI** (Destination Index) | 目的变址寄存器 |



### 2.2.2 段寄存器

|          标识          |     名称     |
| :--------------------: | :----------: |
| **CS** (Code Segment)  | 代码段寄存器 |
| **DS** (Data Segment)  | 数据段寄存器 |
| **SS** (Stack Segment) | 堆栈段寄存器 |
| **ES** (Extra Segment) | 附加段寄存器 |



### 2.2.3 控制寄存器

|             标识             |      名称      |
| :--------------------------: | :------------: |
| **IP** (Instruction Pointer) | 指令指针寄存器 |
|           **FLAG**           |   标志寄存器   |



## 2.3 寄存器的逻辑结构

- 以数据寄存器 **AX** 为例

![2.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/2.3.png)

- 2进制和16进制的转换：

  **四位二进制数 等于 一位十六进制数**。因为四位二进制数可表示从0到 $2^{4}-1$ 即 15 以内的任意一个整数，一位十六进制数可表示的范围为0到15，刚好可以一一对应。因此，一个十六位二进制数可由四位十六进数表示。

- 在 8086 CPU 中，每个寄存器都是十六位。其中 **AX，BX，CX，DX** 四个 **数据寄存器** 由于向前兼容的原因可以分成**两个独立的 8 位寄存器**。如上图 **AX** 可以分成 一个 **AH** 寄存器，用来存储 **AX** 的 **高八位**称为**高位字节**，一个 **AL** 寄存器，用来存放 **AX** 的 **低八位**称为**低位字节**。类似的还有如下几种情况：
  - **BX** 可以分为 **BL** 和 **BH**；
  - **CX** 可以分为 **CL** 和 **CH**；
  - **DX** 可以分为 **DL** 和 **DH**；

- 在使用寄存器时需要注意以下几点：
  1. 一个寄存器只能存入其位数可表示范围以内的数据。例如，一个 **AX** 寄存器能存储的最大整数为 $2^{16}-1$ ，一个 **AL** 寄存器最大能存储的整数为 $2^{8}-1$.
  2. 在使用汇编指令如果操作对象由两个时，需要注意**两个操作对象的位数必须一致**。
  3. 在使用数据寄存器时需要注意，以 **AX** 为例，**AH** 和 **AL** 是两个 **独立** 的寄存器，**AL** 独立参与操作后得到的进位不会保存在 **AH**中，而是被舍去。如果 **AX** 参与操作此时第八位产生的进位会存储在高八位之中，此时 **AX** 相对于 **AH** 和 **AL** 而言也是一个独立的寄存器。



# 3. 物理地址

## 3.1 基本概念

- 定义：

  前面说到，CPU 将所有的物理存储器看一个由若干个存储单元组成的 **逻辑存储器**。所有的内存单元构成的存储单元是一个 **一维的线性空间**。每一个内存单元在这个一维的地址空间，这个地址被称为 **物理地址**。

- 16 位结构的 CPU：

  - 运算器一次最多可以处理 16位的数据；
  - 寄存器的最大宽度为 16位；
  - 寄存器和运算器之间的通路为 16位。

- **8086 CPU 有20跟地址线可表示 $2^{20}$ 个物理地址，即具有 1 MB 的寻址能力。**



- *扩展：*
  - x 位 CPU的说法是一种商业的叫法，并不是严格的专业术语。不同架构的 CPU对此亦有不同的定义标准。比如 CISC 架构的 x86 指令集的32位和64位就与 RSIC 架构的 ARM指令集的32位和64并相同。
  - 32位CPU通常有32个地址总线，其寻址能力为 $2^{32}$，即 **4 GB**. 由于 32位架构的 CPU寻址能力的限制，此架构的 CPU的计算机并不能利用大于其寻址能力以外的物理地址。
  - x86架构指的是以8086指令集为基础后进行一系列扩展的指令的集合，其特点是向下兼容[^3]。x86-32指的是 x86架构的32位扩展。
  - x86-64架构也被称为 AMD64架构，这是由于x86架构的64位扩展是由 AMD公司率先一步实现的。Inter 公司曾自研过不兼容 x86 架构的 IA-64，但由于x86 已形成的强大生态，IA-64日渐式微，AMD64架构最终也被Inter 采用。
  - x 位的操作系统指的是支持 x 位的操作系统，其针对特定 x 位的 CPU 进行设计。



## 3.2 8086 CPU 给出物理地址的方法

-  CPU 内部物理地址的合成与传送流程：
![2.4.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/2.4.2.png)

   

   1. CPU 中相关部件提供两个16 位的地址，一个称为 **段地址**，另一个称为 **偏移地址**；
2. 段地址和偏移地址通过内部总线送入一个称为**地址加法器**的部件；
   3. 地址加法器将**两个 16位地址合成一个 20位的物理地址**；
4. 地址加法器通过内部总线将 20位物理地址送入输入输出控制电路；
   5. 输入输出控制电路将 20位物理地址送上地址总线；
6. 20 位物理地址总线传送到存储器。


- 合成方法：

  **物理地址 = 段地址（SA） \* 16 + 偏移地址（EA）**

- 含义：段地址 \* 16 定位段的**起始地址**（基础地址），用偏移地址定位段中的内存单元。
- *注意：段地址和偏移地址都是**16位**。*



## 3.3 内存的“段”

### 3.3.1 基础知识

- “段”并不存在于物理内存中，“段”是**由 CPU 划分的若干个连续的存储单元**。在后面的学习中就会知道，后面的 “数据段”，“代码段” 和 “堆栈段”都是人为划分的段。
- “段”没有硬性的规定范围，可大可小。但是需要注意的是，由于偏移地址是16位，可寻址 $2^{16}$ 个内存单元，所以**一个段的最大长度是 64 K.**

### 3.3.2 CS 和 IP

- 基础知识：
  - 段寄存器：用于存放段地址的寄存器。在8086 CPU 中有 CS、DS、SS、ES。
  - **CS**：代码段寄存器，存放代码（指令）的段地址。
  - **IP**：指令指针寄存器，存放指令的偏移地址。
- 修改 CS 和 IP 的值
  1. 8086 CPU中传送指令 `mov` 不能用于设置 CS、IP的值。
  2. `jmp` 指令可同时修改 CS、IP的值 ，`jmp SA:EA`。例如 `jmp 2AE3:1003`.
  3. `jmp` 只修改 IP寄存器的值，`jmp 某一合法寄存器`。例如：`jmp ax`.“某一合法寄存器”，表示只能用寄存器的值修改 IP.

### 3.3.3 指令执行流程

![3.2.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/3.2.2.png)

1. CS、IP  中的内容送入地址加法器（地址加法器完成：物理地址 = 段地址 *  16 + 偏移地址）;
2. 地址加法器将物理地址送入输入输出控制电路；
3. 输入输出控制电路将 `20000H`（`CS:IP` 指向的物理地址）送上地址线；
4. 内存 `20000H` 单元处的第一条**指令通过数据总线**被送入 CPU；
5. 输入输出控制电路将机器指令送入**指令缓冲器**；
6. `IP` 中的值**自动增加**指令长度的值；
7. **执行控制器**执行指令；
8. 从 1 处重复执行至止。

**Notice：** **`IP` 先自动增加然后指令再执行！**

**Notice：** **`IP` 先自动增加然后指令再执行！！**

**Notice：** **`IP` 先自动增加然后指令再执行！！！**



# 4. Debug 程序

- Debug 是 DOS、Windows （自 Windows 10 之后不再提供此程序）都提供的实模式（8086 方式）程序的调试工具。
- 使用方法：打开命令行（cmd），在命令行界面手动输入 “debug”  即可进入。
- 使用到的命令与功能：

| 命令 |                 功能                 |
| :--: | :----------------------------------: |
|  R   |        查看、修改寄存器的内容        |
|  D   |            查看内存的内容            |
|  E   |           改写内存中的内容           |
|  U   |   将内存中的机器指令翻译成汇编指令   |
|  T   |           执行一条机器指令           |
|  A   | 以汇编的格式在内存中写入一条机器指令 |

## 4.1 命令的用法

- R 命令

|   指令格式   |                  命令用法                  |                          |
| :----------: | :----------------------------------------: | :----------------------: |
|      r       |          无参数，查看寄存器的内容          |            r             |
| r *register* | 以部分寄存器名作为参数，修改寄存器的内容。 | r ax ,  r cs , r ip 等等 |

**Tips** ： 在使用 R 命令修改寄存器内容时，在指令输入后按下回车键会出现一个 “:” 符号作为内容输入的提示，当输入完成后再次回车即可修改内容，可用 R 指令再次验证内容是否改变。



- D 命令

常用方法：`d 段地址[段寄存器]:偏移地址1 [偏移地址2]`

例如：`d 1000:9`，`d 1000:9 f`，`d ds:0 f`



当 D 命令只有一个参数时，会显示一个默认的 段地址（这个段地址来自哪里，目前无法确定），这个参数将作为显示首行内存信息的偏移地址



- E 命令

常用方法：

1. `e 段地址:偏移地址 data1 data2 data3 ... `

例如：`e 1000:0 0 1 2 3 4 5`

2. 提问方式修改从某一地址开始的内存单元的内容，步骤如下：

首先按 `e 段地址:偏移地址` 的格式输入物理地址（起始地址）后按下回车，之后debug程序会显示起始地址，和第一单元的原始内容，让后光标停在 `.` 的后面以此提示用户输入想要修改的内容，不输入内容直接按空格则不会修改原始内容。无论输入与否只要按下空格则会进入下一个地址，显示下一个地址的原始内容，后面再次出现 `.` 提示符号，直至用户按下回车完成内存该写。如下图：

![4.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.1.png)

3. 写入单个字符和字符串

写入单个字符 ：`e 1000:0 1 'a' 2 'b' 3 'c'`

写入字符串： `e 1000:0 1 "a+b" 2 "c++" 3 "dayelu"`



**Tips**：E 命令还可以通过写入指令对应的机器码来写入指令。



- U 命令

常用方法： `u 段地址:偏移地址1 [偏移地址2]`

使用方法如下图：

![4.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.2.png)



- T 命令

使用指南：

要想使用 T 指令执行自己想要执行的指令有两种方法：一种方法是首先要将汇编指令写入 `CS:IP ` 处，由于这是汇编指令的起点；另一种方法是将指令写入想要写入地址处，然后再通过认为改变 CS寄存器和 IP寄存器的地址来执行指令。以下以第二种为例：

1. 如上图 首先从物理地址 `1000:0` 处写入汇编指令。
2. 用 R 指令将 `CS:IP` 地址 设置为 `1000:0`.
3. 使用 T 命令对汇编指令进行单步执行。

操作如图：

![4.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.3.png)



- A 命令

使用 E 命令可以写入机器指令，但是这样写入很不方便，因此 Debug 提供了 A 命令用于直接像内存写入汇编指令。

使用方法：`a 段地址:偏移地址`，操作如下图：

![4.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.4.png)

- [ ] 使用 `a 段地址:偏移地址` 的办法可以直接指定 `CS:IP` 所指向的位置，也就是代码段的位置，从此处开始输入指令。

  

  除此之外还可以直接以 输入 a指令后回车的方式从预设的 `CS:IP`  处开始输入指令。

  事实整明并非如此，当 `CS:IP` 改变 a 命令的回车默认位置并不会改变，也就是说它是一个预定值。这跟上面 D 命令的情况也类似，其段地址也是个预定值，并不会随着 CS 或者 DS 寄存器进行改变。



​		诡异的时，当我推出debug程序再次进入时，`CS`，`DS `和 A 命令，D 命令的预设值都会一模一样！！！

​	

​		这说明 debug 程序也会有欺骗的嫌疑，这些程序的原因未必会出现 汇编语言的中，因此，过分纠结这些工具好像属实没必要！！！！

​		

# 5. 寄存器（内存访问）

## 5.1 内存种字的存储

在 CPU 种用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节。如图所示：

![5.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/5.1.png)

假设从地址 0 处开始存放 2000（**4E20H**），用 地址为0 和 1 两个内存单元存放。**高地址 1** 存放**4E**，**低地址 0** 存放 **20** .

**字单元**：存放一个字型数据（16位）的内存单元，由**两个地址连续的内存单元**组成。**高**地址内存单元中存放字型数据的**高**字节位，**低**地址内存单元存放字型数据的**低**字节位。这种方式有时也被称为“**高高低低**”原则，属于**小端模式**。



关于更多 “**大小端模式**” 的相关问题详见博客 [详解大端模式和小端模式]( https://www.cnblogs.com/wpgraceii/p/11395719.html)



## 5.2 DS 和 [address]

**CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址**，在 80806 CPU 中，内存地址由段地址和偏移地址组成。

**DS 寄存器：**在 8086 CPU 中通常用 **DS 寄存器存放要访问数据的段地址**。例如;

```assembly
mov bx,1000H	; 1
mov ds,bx		; 2
mov al,[0]		; 3
```

**解析：**

将 地址为 10000H 的内存单元（8位，一个字节）里的值送入 al 寄存器中。

由于 **8086 CPU 不支持将 数据 直接送入段寄存器中**，送所以只能将 地址为 10000H 内存单元的段地址，即 **1000H** 先送入 **bx** 寄存器中，再由 **bx** 传送给 段寄存器 **DS**.如上述步骤1，2.

**[...]** 表示一个内存单元，**[ ]** **中的数值表示内存单元的偏移地址**，其**段地址默认存储于 段寄存器 DS 中**，8086 CPU 执行指令时会自动从 DS 中取出。由于al 是8位寄存器，所以这里步骤3 就表示将内存单元 **1000H:00H** 中的值传送给 寄存器 al。



## 5.3 mov、add、sub 指令

### 5.3.1 mov 指令形式

1. 与段寄存器无关的指令语句

|           形式            |          例子           |
| :-----------------------: | :---------------------: |
|   `mov  register,data`    |      `mov ax,8AH`       |
| `mov  register,register`  |       `mov ax,bx`       |
|   `mov  register,[···]`   |      `mov ax,[0]`       |
|   `mov  [···],register`   |      `mov [0],ax`       |
| `mov [...],word ptr data` | `mov [bx],word ptr 10H` |

- 注： 最后一种形式，即用 `mov` 指令 把数据直接送入内存单元是可以的，但是要指明数据的大小，`X ptr` 标号后面会学到的。

2. 与段寄存器相关的指令语句

|                  形式                   |   例子    |
| :-------------------------------------: | :-------: |
| `mov  register, segment register` | `mov ds,ax` |
| `mov segment register,register` | `mov ax,ds` |
| `mov  segment register,[···]` | `mov ax,1000H`<br >`mov ds,ax`<br >`mov ds,[0]` |
| `mov  [···],segment register` | `mov ax,1000H`<br >`mov ds,ax`<br >`mov [0],ds` |



### 5.3.2 add 指令和 sub 指令

**add 加法指令，sub 减法指令**，与 **mov指令** 类似，**将两个数值计算结果储存在 指令操作的第一个操作对象里面（寄存器或内存单元）**，格式有以下分别四种。

|              形式              |     例子     |
| :----------------------------: | :----------: |
|   **add ** *register*,*data*   | `add ax,8AH` |
| **add ** *register*,*register* | `add ax,bx`  |
|  **add ** *register*,*[···]*   | `add ax,[0]` |
|   **add ** [···],*register*    | `add [0],ax` |
|   **sub ** *register*,*data*   | `sub ax,8AH` |
| **sub ** *register*,*register* | `sub ax,bx`  |
|  **sub ** *register*,*[···]*   | `sub ax,[0]` |
|   **sub ** [···],*register*    | `sub [0],ax` |


# 6 8086 CPU 栈机制

## 6.1 基本概念

- **栈的基本操作**：
  
  - **入栈**：将一个新元素放入栈顶。
  - **出栈**：从栈顶取出一个元素。
  
- 栈的特点：

  栈顶元素总是最后入栈，需要出栈时，又最先被栈中取出。栈的这种操作原则被称为：**LIFO（Last In First Out，后进先出）**。

- **关于栈顶和栈底的区分**：

  可以**将栈想象成一个瓶子**，向瓶子里塞物品（假设瓶子是规则的筒状，并且物品刚好每次只能塞进去一个），**瓶底就是栈底**，靠近瓶口的物品的位置就是栈顶。

- 基本的 **入栈和出栈指令**：**PUSH（入栈）和 POP（出栈）**

- 8086 CPU 的入栈和出栈都是**以字（16 位）为单位**进行的。

- 8086 CPU **确定栈顶元素位置的方式**：

  - **SS (Stack Segment)  堆栈段寄存器** ：**存放栈的段地址**。

  - **SP (Stack Pointer)  堆栈指针寄存器**：**存放栈的偏移地址**。

    **任意时刻，SS:IP 指向栈顶元素。**



## 6.2 出入栈操作的完整过程

- **入栈**过程，**栈顶从高地址向低地址方向增长**，以**push ax**为例，步骤如下：

  
  
  1.  **SP = SP - 2，`SS:SP` 指向当前栈顶前面的字单元，以当前栈顶前面的字单元为新的栈顶**。
  2.  **将 ax 中的内容送入 `SS:SP` 指向的内存单元处**，`SS:SP` 此时指向新栈顶。
  
  
  
    操作过程如下图，图片来自 *《汇编语言》第三版，59页，作者王爽*

![6.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.1.png)

- 出栈操作，与入栈操作刚好相反，以 **pop ax** 为例，步骤如下：

  
  
1. **将 `SS:SP` 指向的内存单元处的数据送入 ax 中**；
  2. **SP = SP + 2 ,`SS:SP` 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。**

  

   操作过程如下图，图片来自 *《汇编语言》第三版，61页，作者王爽*

![6.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.2.png)

  - 注意 ：上图中，出站后，**SS:SP 指向新的栈顶 1000EH**，pop 操作前的栈顶元素，~~1000CH 处的2266H 依然存在~~，但是它已不在栈中。当再次执行 push 等入栈指令后， SS:SP 移动至 1000CH 处，并在里面写入新数据，~~覆盖当前数据~~。
  
    
    
    ~~这与外存的读写方式类似 ，删除数据的时候并不会对存储单元就行真的擦除操作，只是将其索引删去，使得这部分数据无法被检索到。当有新的数据写入时将会把这些数据覆盖。当发出删除操作指令之后就立马对数据作类似清零的操作会增加计算机的负载，增加时延，没有必要。以上属于个人理解。~~ 
    
    我没说过这句话。
    
    以上**注意**纯属**谣言！！！**，注意内容来自，本参考书籍王爽老师的《汇编语言》第三版，上面说到执行pop指令之后，被弹出去之前的栈顶元素依然与地址，当再次有入栈操后才会被覆盖掉。经亲手实验证实，在 pop 指令执行之后，该地址的内容会被栈顶上面的字元素填充，有图有真相：
    
    ![6.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.3.png)
    
    ![6.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.4.png)



## 6.3 答疑解惑

### 6.3.1 栈与内存图的画法

1. **关于内存的画法**
   通过参考国内外的相关书籍，可以初步做出以下结论：

   如果规定只能化成一个竖直形状的图形，**内存地址是从高到低还是低到高的标识法**其实都没有任何问题，**没有硬性的规定**。这只是一个模型而已，随便你怎么画好了，内存条等等这些硬件才不在乎你把它化成什么样子。

   但是不管怎么画都需要遵守相关的准则，例如下面要谈到的 `x86` 体系结构下**CPU提供的栈机制** 的画法 。
   
2. **关于栈的画法**

   至于栈的最原始定义是什么无从考证，栈只是一种数据结构而已。

   所以当你画栈的内存模型时，如果没有特殊限制说明，你画了一个栈并规定好栈顶之后，你**不需要过分纠结**入栈时，新元素是应该放在栈顶的上方还是下方，即规定**入栈的方向**。

   如果没有特殊的限制说明，你自己规定就好了，你规定入栈的方向在栈顶的上方，那元素就只能从此进入。

   再次强调，栈只是一个数据结构，你了解他的基本原理就够了，你只需知道 **栈是一个受限的线性表，只能从一个方向填充和删除元素并且遵循 LIFO 原则就够**了。

   但是当遇到特定情况时需要遵守相关原则，例如下面要谈到的 `x86`体系结构下**CPU提供的栈机制**的画法 。

3. **`x86` 体系CPU 提供的栈机制的画法**

   前面提到，在没有规定下，无论内存地址的增长方向还是栈的入栈方向再没有特殊规定下可以随心所欲地画。但是，在特定硬件体系结构下，如本标题，栈和内存有特定的联系时，就不能随心所欲了。

   通过查阅国内外相关书籍，初步聊到 `x86` 体系 CPU 对栈的规定：

   1. **栈的"生长"方向是从高地址到低地址**。（*The stack will grow as more data is stored in it, and it will grow in the downward direction,
      from higher addresses to lower addresses.*）
   2. **入栈操作（执行 push 指令）时，栈顶的地址总是随着元素的增加而由高到低**（*The stack pointer rsp will decrease every time you put data on the stack.*[^4]），这句话本意应解释为：**“每次向栈中增加数据时，栈指针寄存器 的值将会减小**”，二者意义并无冲突。

   

所以关于栈的画法，内存是从上到下或者下到上增加都没关系，只是在 特定条件下，例如 `x86` 体系的CPU 的限制下，注意入栈的方向与内存的法相对应其法则就够了。现选取国外相关图书中**内存地址增加方向不同**的内存图画法如下，以供进一步理解：



- 入栈操作，**内存向下减小**，来自 *Assembly Language for x86 Processors, 7th Edition* 一书 141 页，作者 KIP R. IRVINE

![6.5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.5.png)

  - **内存向下增加**，Intel 64, registers and stack，英特尔 CPU 结构图，来自 *Low-Level Programming* 一书 15 页，作者 Igor Zhirkov.

    ![6.6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.6.png)





### 6.3.2 一个关于 SP 的伪命题

- *SP 寄存器指向栈顶元素的哪个内存单元*? 以以下图为例，《汇编语言》第三版，59页，作者王爽。引出以下问题：

![6.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.1.png)

- 疑问：如上图第三部分，SP 是指向 66 还是 22 ？

- 解析：冷静了很久，才发现这是伪命题！因为， SP 是 堆栈指针寄存器，**单个 SP 是不能确定物理地址的**，更不用说确定 栈顶元素的物理地址。再次强调**任何时候，`SS:SP` 指向栈顶元素。** 由于 `SS:SP` 指向栈顶元素，所以可以确定 `SS:SP` 指向的是 66 而不是 22。因为根据 “**高高低低原则**” ，高地址存放高字节，低地址存放低字节，当 `SS:SP` 指向的是 66 时，高地址是 `1000DH` 存放 22，低地址是 `1000CH` 存放 66，所以 `SS:SP` 指向的字型数据是 `2266H` 。

  反之，如果 `SS:IP` 指向的是 22，那么 `SS:SP` 指向的字型数据就是 `2322H` 而不是 `2266H` 了。

  

- 困惑来源：在伪命题成立的情况下，误以为，pop 和 push 操作都是以字型数据为操作对象，所以无论 SP 指向 66 还是 22 pop 的都有可能操作的是 2266H ，会影响最终结果，以致一错再错。最后才通过分析 pop 指令执行时，SP 寄存器的变化才重回正轨。

  

  至于为什么会把 栈指令寄存器 SP 当成了 SS:SP 呢？原因就是来自 *Assembly Language for x86 Processors, 7th Edition* 一书 141 页的这张图相关的一系列图。

  ![6.5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.5.png)

  
  
  ​	图中的寄存器 ESP 直接指向了内存单元！也就是说它一个寄存器就可以指向物理地址！这让我对 ESP 和 SP 之间产生了混淆，完全忘记了 我学的目前还是 8086汇编，而 ESP 寄存器属于 x86 汇编，与之类似的 还有属于 x64汇编的 RSP 。通过搜索才知道“**ESP为栈指针，用于指向栈的栈顶**”，**不需要像 8086 汇编中 两个寄存器合成 栈顶元素的物理地址。** 因此铸成大错。



## 6.4  空栈和栈顶超界问题

- 空栈状态，图片来自 *《汇编语言》第三版，60页，作者王爽*

  ![6.7](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.7.png)

  **若 10000H ~ 1000FH为栈空间**，栈底位置内存单元的地址为 1000FH ，当栈为空时，SS:SP 应该指向何处？

  由于当向栈空间添加一个元素之后，由于入栈操作的操作数是字型数据，所以 SS:SP 必然指向1000EH。因此反推之，当栈空时，SS:SP 指向不属于栈空间的栈底内存单元的下一个位置，即 10010H.**空栈也可以理解成栈中唯一的元素出栈**。



- 栈顶超界

  前面提到栈的空间时，都有一个“假设”的前提，那么 8086 CPU 有没有防止栈满时继续入栈导致出现栈顶超界问题的机制呢？

  答案是，并没有。**8086 CPU 并没有检测和限制栈的越界问题**。**8086 CPU 只考虑当前栈顶的位置，当前需要执行那一条指令**。**当栈满时继续进行入栈操作时，将会覆盖掉栈顶元素之上栈空间之外的一个字单元**。因此这是搬砖人员需要考虑问题。

  所以在编程时**尽量使用最大栈空间**防止入栈数据太多而导致的超界问题 ；同样在进行出栈时也需要注意当前栈是否为空，以防止出现栈空时继续出栈造成的越界问题。



## 6.5 push 和 pop 指令

- 指令使用方式：

|   指令格式    |              意义              |                     示例                     |
| :-----------: | :----------------------------: | :------------------------------------------: |
|  push 寄存器  |     将一个寄存器的数据入栈     |                   push ax                    |
|  pop 寄存器   |   出栈，用一个寄存器接收数据   |                    pop ax                    |
| push 段寄存器 |    将一个段寄存器的数据入栈    |                   push ds                    |
| pop 段寄存器  |  出栈，用一个段寄存器接收数据  |                    pop ds                    |
| push 内存单元 |    将一个内存单元处的字入栈    | mov ax,1000H<br >mov ds,ax<br >push [0]<br > |
| pop 内存单元  | 出栈，用一个内存字单元接收数据 | mov ax,1000H<br >mov ds,ax<br >pop [2]<br >  |



- 编程示例：

  - 要求：
    1. 将 10000H ~ 1000FH 这段空间当作栈，初始状态栈空；
    2. 设置 AX = 001AH，BX = 001BH；
    3. 将 AX、BX 中的数据入栈；
    4. 将 AX 、BX 清零；
    5. 从栈中恢复 AX、BX 原来的内容。

  

  - 代码示例：

    ```assembly
    mov ax,1000H
    mov ss,ax
    mov sp,0010H	;初始化栈顶，栈的情况如下图（a）所示
    
    mov ax,001AH
    mov bx,001BH
    
    push ax
    push bx		;ax,bx 入栈，栈的情况如下图（b）所示
    
    sub ax，ax
    sub bx，bx	;将ax清零用 mov ax,0 或者 sub ax,ax 都可以，前者机器码 2 字节，后者三字节。
    
    pop bx
    pop ax	;从栈中恢复 ax、bx 的数据，当前栈顶是 bx 中原来的内容， ax 原来的内容在栈顶下面，所以先 pop bx 再 pop ax
    ```

    ![6.8](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.8.png)

- 总结：

  push、pop 指令实质上一种**内存传送指令**，可以**在寄存器和内存之间传送数据**。

  push、pop 等栈操作指令**修改的只是 SP** ，因此，**栈顶的变化范围最大为 0 ~ FFFFH**。





- [x] 通过debug 程序验证 “pop 操作之后 数据仍在内存” 的正确性
- [ ] 吸收第三章 实验的知识。(这个实验跟后面的内容有联系，待学习完后面再战)

然后向下面这样



# 7. 第一个源程序

## 7.1 源程序示例

- 源程序 *1.asm*

```assembly
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	
	mov ax,4c00H
	int 21H

codesg ends	;名为 codesg 的段到此结束

end
```



1. 伪指令

   汇编语言源程序包含 **汇编指令** 和 **伪指令** 两种指令。

   **汇编指令**是有对应机器码的指令，最终**被 CPU 执行**。

   **伪指令**没有对应的机器指令，最终不被 CPU 所执行，而是**被编译器执行**。

   

   上述源程序中出现的伪指令有如下几种：

   

   - **segment 和 ends**

      segment 和 ends 是**可编译源程序**中必须被用到的两个**成对使用**的伪指令。这对指令的功能是定义一个段，**segment** 标记一个**段的开始**，**ends** 标记一个**段的结束**。使用格式如下：
    ```
   段名 segment
   ：
   段名 ends   
    ```

   - **end**

     整个汇编源程序的结束标志。编译器执行到此即结束编译。

   

   - **assume**

     这条伪指令的含义为“假设”，假设某一段寄存器和程序中的某一个用 segment...ends 定义的段相关联。

   

2. **标号**

   汇编源程序中除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。



3. **程序返回**

   在一个**单任务系统**中（以 DOS为例），一个程序 P2 在可执行文件中，则必须有一个正在运行的程序 P1，将 P2 从可执行文件中加载到内存后，将 **CPU** 的**控制权**将给 P2， P2 才能得以运行。P2 开始运行后，P1 暂停运行。

   而当 P2 运行完毕后，应该将 **CPU** 的**控制权**交还给使它得以运行的程序 P1，此后，P1继续运行。

   

   一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，这个过程被称为 “**程序返回**”。

   ```assembly
mov ax,4c00H
   int 21H
   ```
   
   这两条指令所实现的功能就是 **程序返回**。



## 7.2 源程序的编译、连接和执行

- 工具：masm5.0 汇编编译器，Overlay Linked3.60 连接器

- 步骤：以 *1.asm* 为例

  1. **编译** 源文件（.asm），生成目标文件（.obj）

     ```
     C:\masm>masm 1.asm;
     ```

  2. **连接** 目标文件（.obj）,生成可执行文件（.exe）
     
     ```
     C:\masm>link 1.obj;
     ```

  3. 执行
  
     ```
     C:\masm> 1.exe
     ```



- 注意：
  1. 编译和连接命令后面**分号（;）**不可省略。
  2. 以上三个步骤中文件后缀名（如 .asm , .obj , .exe等）均可省略。



## 7.3 程序执行过程的追踪

- DOS 中 .EXE 文件的简单加载过程，如下图：*王爽《汇编语言》第三版，92页*

  ![7.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.1.png)

  由于有 `PSP` 区的存在，通过 `Debug` 程序我们可以发现，`DS` 段寄存的地址 与 `CS` 段寄存器的地址有这样的关系：

  **`DS`地址 + `10H` = `CS` 地址**

  当然这在没有其他段（比如数据段和栈段）或者其他段不在程序开头定义时成立。如果其他段在程序开头定义还需要加上其他段空间大小，参考实验五。

  

- 追踪工具：Debug 程序

  由于 Debug 程序可以将程序加载入内存，**设置 CS:IP 指向程序的入口**，但是，**Debug 程序 不放弃对 CPU 的控制**，所以可以对程序执行过程就行追踪。

  

- 追踪过程，以源程序 1.asm 生成的可执行文件 1.exe 为例，如下图：

  ![7.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.1-1597756911155.png)

  ![7.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.2.png)

  

- 步骤说明：

  1. 在命令提示符中输入`debug 1.exe` 后回车，Debug 将从将程序从 1.exe 加载入内存中，进行相关初始化后，设置 **CS:IP** 指向程序的入口。
  2. 使用 T 命令单步执行，直到下个指令为 `INT 21` 时，**使用 P 命令结束**程序。
  3. 使用 Q 命令退出 Debug 程序，将返回到 command （命令行终端）中，因为 Debug 是由 command 加载运行的。



- 过程解析：

  在 DOS 中用  `debug 1.exe`  运行 Debug 对 1.exe 进行跟踪时，

  程序**加载顺序**是：command 加载 Debug $\longrightarrow$ Debug 加载 1.exe 

  程序**返回顺序**是：从 1.exe 中的程序返回到 Debug $\longrightarrow$ 从 Debug 返回到 command。

  

## 实验 3 编程、编译、连接、跟踪

- 源程序：`t1.asm`

```asm
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,2000H
	mov ss,ax
	mov sp,0
	add sp,10

	pop ax
	pop bx
	push ax 
	push bx
	pop ax
	pop bx
	
	mov ax,4c00H
	int 21H

codesg ends	;名为 codesg 的段到此结束

end
```

- Debug 追踪，如下图

![7x1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x1.png)

![7x2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x2.png)

![7x3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x3.png)



- 查看 PSP 区的内容

![7x4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x4.png)



- [ ] 其中玄机如何，暂未参透，待来日回首。



# 8. [BX] 和 LOOP 指令

## 8.1 [BX]

和 `[0]`一样，`[BX]` 同样也表示一个内存单元，段地址在 DS 寄存器中，偏移地址 在 BX 寄存器中。如下：

```assembly
mov ax,[bx]
```

将一个内存单元的地址送入 ax。这个内存单元的长度位 2（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

- 约定符号：

  为了方便下文的描述，做如下规定：

  1. 符号 `()` 表示一个内存单元或者寄存器的内容。例如：(ax) 表示寄存器 ax 的内容。
  2. `idata` 表示常量。例如：`mov ax,[idata]` 代表 `mov ax,[1]、mov ax,[2]` 等。

- 有例题如下：

- 代码：

```assembly
mov ax,2000H
mov ds,ax
mov bx,1000H
mov ax,[bx]

inc bx	; 表示 将bx存储的数据加一，类似于 C语言的自增（++）
inc bx
mov [bx],ax

inc bx
inc bx
mov [bx],ax

inc bx
mov [bx],al

inc bx
mov [bx],al
```

- 内存变化图：图片来源王汇编。97，99 两页

![8.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.1.png)



## 8.2 LOOP 指令

loop 为循环指令。

- 指令格式：`loop 标号`。
- 操作步骤：
  1. `(cx) = (cx) - 1`
  2. 判断 `cx ` 中的值，不为零则转至表好处执行，为零则向下执行。

- `loop ` 指令用来实现循环的功能，**`cx`** 中存放 **循环次数**。

- 示例：计算 $2^{12}$

```assembly
assume cs:code
code segment
	mov ax,2
	mov cx,11

s:	add ax,ax
	loop s
	
	mov ax,4c00h
	int 21h

code ends
end
```

- 解析：

  `add ax,ax` 等价于 `(ax) = (ax) * 2`，由于此例，（ax）可以看作底数是2 的幂运算，乘以 2 就相当于指数加一。所以，可以将 `(cx) ` 设置为 11 来实现。



## 8.3 Debug 程序跟踪 loop 指令实验

- 要求：

  计算`ffff:0006` 单元中的数乘以 3，结果存放在 `dx` 中。

- 源程序：

```assembly
assume cs:code
code segment
	mov ax,0ffffh ; ffff:0006 单元处数值最大值为2^8-1,
    			  ; 不会大于 IP寄存器可存的
    			  ; 最大数值 2^16-1, 因此不会有溢出行为。 
	mov ds,ax
	mov bx,6	; 以上，设置 ds:bx 指向 ffff:6
	
	mov al,[bx]
	mov ah,0	; 以上，设置(al)=((ds*16)+(bx)),(ah)=0
	
	mov dx,0	; 累加器清零
	mov cx,3	; 循环三次、
	
s:	add dx,ax
	loop s		; 以上累加计算(ax)*3
	
	mov ax,4c00h
	int 21h		; 程序返回

code ends
end
```

- 注意：

  **在汇编源程序中 ，数据 不能以字母开头！** 所以本例中，`mov ax,0ffffh` ，十六进制数 `ffffh` 需要写成  `0ffffh`。

- 调试

  ![8.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.2.png)

  如上图所示，使用 `Debug` 对已生成的可执行文件进行调试。

  1. 通过使用 **`U`** 命令查看汇编指令，我们发现，此时在汇编源程中的 **标号 s** 变成了 `0012H` ，没错，正是源程序中 **标号 s** 所在行的那条汇编指令的起始位置。

  2. 直接使用 **`G`** 命令将偏移地址跳转至 `0012H` ，即  **标号 s** 所在的位置。也可以说是 循环体开始的位置。然后使用 **`T`** 命令不停地进行 单步调试，直至到执行 `int 21` 指令后，用 **`P`** 命令退出调试。如下图：

     ![8.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.3.png)

     从上图程序运行的过程我们看出，每次执行完 **`loop`** 指令后，CX 的值会自动减一，然后会判断其值是否会大于零；若大于零，则会 **向上** 跳转到标号的所在位置继续从上往下执行；若等于零则继续 **向下** 执行。

  3. 当循环次数增多，使用 **`T`**  命令进行单步调试就显得不可行，于是我们可以使用 **P** 命令。如上所见，**P** 命令可以用来终结调试，不仅如此，当执行到 **`loop`** 指令时，我们使用 **P** 命令 后，`Debug` 程序就会自动重复执行标号和 **`loop`** 指令之间，以及 **`loop`** 指令 在内的诸多指令，如下图;

     ![8.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.4.png)



## 8.4 Debug 和 masm 对指令的不同处理

- 对于汇编指令 **`mov ax,[idata]`** ，

  在 `Debug` 程序中，表示将 `ds:[idata]` 中的内容送入 AX 中。

  在 masm 中则会被解释为，将 `idata` 送入 AX 中。

- 在 masm 源程序中有两种方法表示，这种内存单元：
  
  1. 将偏移地址送入 bx 寄存器中，使用 **`ds:[bx]` ** 表示内存单元。
  2. 使用 **段前缀**：**`ds:[0]`** 显示地给出段地址，这种形式表示一个内存单元。
  
- 下面给出 masm 源程序 的具体例子，增强区分：

  `mov ax,[0]` 	====>>>	`(ax) = 0`

  `mov ax,[bx]` 	====>>>	`(ax) = (ds:bx)`

  `mov ax,ds:[0]` 	====>>>	`(ax) = (ds:0)`

  `mov ax,ds:[bx]` 	====>>>	`(ax) = (ds:bx)`



## 8.5 loop 和 [bx] 的联合应用

- 要求：

  计算 `ffff:0 ~ ffff:b` 单元中的数据之和，结果存储在 `dx` 中。

- 分析：

  每个内存单元的可存储的最大数值为 $2^{8}-1=255$，12 个这样的数之和 $255\times 12=$ 3060,不会大于一个字可存储的最大数值 $2^{16}-1=65535$ .因此，`ds`寄存器可存下，不会发生溢出问题。

- 源程序1：

```asm
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax	; 设置(ds)=ffffh
	mov dx,0	; 初始化累加寄存器，(dx)=0

	mov al,ds:[0]
	mov ah,0	; (ax)=((ds)*16+0)=(ffff0h)
	add dx,ax	; 向dx中加上 ffff:0 单元的数值

	mov al,ds:[1]
	mov ah,0	; (ax)=((ds)*16+1)=(ffff1h)
	add dx,ax	; 向dx中加上 ffff:1 单元的数值

	mov al,ds:[2]
	mov ah,0	; (ax)=((ds)*16+2)=(ffff2h)
	add dx,ax	; 向dx中加上 ffff:2 单元的数值

	mov al,ds:[3]
	mov ah,0	; (ax)=((ds)*16+3)=(ffff3h)
	add dx,ax	; 向dx中加上 ffff:3 单元的数值

	mov al,ds:[4]
	mov ah,0	; (ax)=((ds)*16+4)=(ffff4h)
	add dx,ax	; 向dx中加上 ffff:4 单元的数值

	mov al,ds:[5]
	mov ah,0	; (ax)=((ds)*16+5)=(ffff5h)
	add dx,ax	; 向dx中加上 ffff:5 单元的数值


	mov al,ds:[6]
	mov ah,0	; (ax)=((ds)*16+6)=(ffff6h)
	add dx,ax	; 向dx中加上 ffff:6 单元的数值

	mov al,ds:[7]
	mov ah,0	; (ax)=((ds)*16+7)=(ffff7h)
	add dx,ax	; 向dx中加上 ffff:7 单元的数值

	mov al,ds:[8]
	mov ah,0	; (ax)=((ds)*16+8)=(ffff8h)
	add dx,ax	; 向dx中加上 ffff:8 单元的数值

	mov al,ds:[9]
	mov ah,0	; (ax)=((ds)*16+9)=(ffff9h)
	add dx,ax	; 向dx中加上 ffff:9 单元的数值

	mov al,ds:[0ah]
	mov ah,0	; (ax)=((ds)*16+0ah)=(ffffah)
	add dx,ax	; 向dx中加上 ffff:a 单元的数值

	mov al,ds:[0bh]
	mov ah,0	; (ax)=((ds)*16+0bh)=(ffffbh)
	add dx,ax	; 向dx中加上 ffff:b 单元的数值

	mov ax,4c00h
	int 21h		; 程序返回

code ends
end
```

- 解析：（~~不只是为何，以上程序无法在 masm 中通过编译。没关系，知道大概的意思就行，不必太纠结于工具而浪费宝贵的时间！~~ 编译不通过的原因，竟然是，文件名中不能含特殊字符，于是将 "." 换成下划线就ok了。）

  以 `AX`  作为累加寄存器进行累加，重复十二次。当然，当内存范围更大时，这样的编程方式显然不可取。于是，刚刚学到的 **`loop`** 指令就可排上用场了。改进如下：

- 源程序2：

```asm
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,0ffffh
	mov ds,ax
	mov bx,0	; 初始化 ds:bx 指向 ffff:0

	mov dx,0	; 初始化累加器 dx
	mov cx,12	; 初始化训话计数器 cx
	
s:	mov al,[bx]
	mov ah,0
	add dx,ax
	inc bx		; bx 自增，指向下一个内存单元
	loop s
	
	mov ax,4c00h
	int 21h

codesg ends	;名为 codesg 的段到此结束

end
```



## 8.6 安全的内存空间和段前缀

- 安全的内存空间

  1. 在 8086 模式中，随意向一段内存空间写入内容是很危险的，因为这段空间可能存放着很重要的数据或这代码。

  2. 在 DOS 方式（实模式）下，一般情况，`0:200 ~ 0:2ff` 空间没有系统或其他程序的数据或代码。

- 段前缀

  前面我们已经在 **8.4 Debug 和 `masm` 对指令的不同处理** 一小节中看到，要想 `masm` 正确处理 `mov ax,[idata]` 类似的指令需要用 `bx` 做中转，或者显示地加上段寄存器，如 `mov ax,ds:[8]` 这种形式。

  此处的 **`ds:`** 就是**段前缀**，用于 **显示地指明内存单元的段地址**，类似的还有：**`cs:`** ，**`ss:`** ，**`es:`**.
  
  

## 实验 4 `[bx]` 和 `loop` 的使用

- 编程，向内存 `0:200 ~ 0:23F` 依次传送数据 `0~63(3FH)`，程序中只能使用 9 条指令，9 条指令包括 `mov ax,4c00h` 和 `int 21h`。

  ```assembly
  assume CS:code
  code segment
  	MOV AX,0020h
  	MOV DS,AX
  	MOV bx,0
  	MOV CX,64
  
  s:	MOV [bx],bx
  	INC bx
  	LOOP s
  
  	MOV AX,4c00h
  	INT 21h
  
  code ends
  end
  ```

- 下面的程序的功能是将 `mov ax,4c00h` 之前的指令复制到内存 `0:200` 处，补全程序，上机调试，跟追运行结果。

  ```assembly
  assume CS:code
  code segment
  	MOV AX,___
  	MOV DS,AX
  	MOV AX,0020h
  	MOV ES,AX
  	MOV bx,0
  	MOV CX,___
  
  s:	MOV AL,[bx]
  	MOV ES:[bx],AL
  	INC bx
  	LOOP s
  
  	MOV AX,4c00h
  	INT 21h
  
  code ends
  end
  ```

  ~~这个问题很奇怪,`MOV AX,4c00h`到底前面问题的的程序里的指令还是什么别的？是在此之前的一条还是若干条指令，到底是啥意思？吾无奈阅读理解能力低下，并不能理解其深意。so，未完待续。。。。。~~



# 9. 包含多个段的程序

## 9.1 在代码段中使用数据和栈

- 直接看源程序9.1：

```assembly
assume CS:codesg
codesg segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		; 用 dw 定义 16 个字型数据，在程序加载之后，
		; 将取得 16 个字的内存空间，存放这 16 个数据。
		; 在后面的程序中将这段空间当做栈来使用

start:	MOV AX,CS
	MOV SS,AX
	MOV sp,30h	; 将设置栈顶 ss:sp 指向 cs:30h

	MOV bx,0
	MOV CX,8

s:	PUSH CS:[bx]
	ADD bx,2
	LOOP s		; 以上将代码段 0~15 单元中的
				; 8 个字型数据依次入栈

	MOV bx,0
	MOV CX,8

s0:	POP CS:[bx]
	ADD bx,2
	LOOP s0		; 以上依次出栈 8 个字型数据
				; 到代码段 0~15 单元中

	MOV AX,4c00h
	INT 21h

codesg ends
end start
```

- 解析：
  1. 此处我们用到了一个新的伪指令 **`dw`（define word）** 用来定义字型数据。此处定义了 8 个字型数据（数据之间用逗号隔开）。
  
  2. 注意此处在程序的第一条指令前加上了一个标号 **start** ，并且其在程序的末尾 **`end start`** 中再次出现。
  
  3. 所以需要说明伪指令 **end** 的作用：第一，通知编译器结束程序；第二，告诉编译器程序的入口在什么地方。**`end start`** 即告诉编译器程序的入口在标号 **start** 处。
  
  4. 上例中，指令 `MOV sp,30h` 的作用是将设置栈顶 `ss:sp` 指向 `cs:30h`，为什么是 `30h`？
  
     首先，我们用伪指令 `dw` 定义的连个段空间，这两个段的地址是相邻的，连续的。
  
     其次，两个段定义的空间分为别，8 个 和 16 个字，加起来就是 24 个字，也就是 48 个字节，也即 48 个内存单元，也就是 16 进制是 `30h` 了。所以就需要将 `ss:sp` 指向这段内存的最底部作为栈顶了。



## 9.2 将数据、代码、栈放入不同的段

上菜：

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,20h	; 设置栈顶 ss:sp 指向 stack:20h

	MOV AX,data
	MOV DS,AX	; ds 指向 data 段
	MOV bx,0	; ds:bx 指向 data 段中段第一个单元

	MOV CX,8
s:	PUSH [bx]
	ADD bx,2
	LOOP s		; 将以上 data 段中段 0~15 单元
			; 中的 8 个字型数据依次入栈

	MOV bx,0
	MOV CX,8
s0:	POP [bx]
	ADD bx,2
	LOOP s0		; 以上依次出栈 8 个字型数据到 
			; data 段的 0~15 单元中
	MOV AX,4c00h
	INT 21h

code ends
end start
```

- 从上例中可以看出，定义一个段与定义代码段没有区别，知识段名不同。

- 对段地址的引用

  在程序中 **段名** 代表 **段地址**，相当于一个标号。所以， `mov ax,data` 的含义就是将 **段名** 为 `data` 的 **段的段地址** 送入 `ax`.

- 一个段中的数据的段地址可有段名来表示，偏移地址就要看它哎段中的位置了。如上例中数据 `0abch` 的地址就是：`data:6`.

- 将上例中的  `data:6` 单元中的数据送入 `bx` 中，需要用以下程序：

  ```assembly
  mov ax,data
  mov ds,ax
  mov bx,ds:[6]
  ```

  而不能：

  ```assembly
  mov ds,data		; 错误
  mov bx,ds:[6]
  ```

  因为，**8086 CPU 不允许将一个数值直接送入 段寄存器！！！**

- “数据段”，“栈段”，“代码段”全都是我们自己的安排，那么：

  1. 这三个段分别用 `data`,`stack`,`code` 三个有具体含义的段名，CPU 是否就会因为这些段名按我们的意愿，把`data` 段中的内容当作数据段去执行？

     当然不会，这三个段名完全是我们方便阅读程序而取的段名，其完全可以用 `a`,`b`,`c` 这种没有具体含义的段名代替！

  2. 在源程序中，我们使用伪指令 **`assume CS:code,DS:data,SS:stack`** 将 `code` 段与 `cs`寄存器，`data`段与 `ds` 寄存器，`stack` 段 与 `ss` 寄存器 分别关联。那么 CPU 又是否会按照我们的想法 比如，将 `cs` 指向 `code`， 来处理这些段？

     也不会！再此，我们只知道，伪指令 **`assume`** 会将你定义的具有一定用途的段和相关寄存器联系起来。

  3.  CPU 如何使用我们定义的段与伪指令无关，而是由具体的汇编指令控制。

     本例中，我们用 `end start` 指令将程序的入口指定在 我们所定义的 `code` 段的第一条指令处。此就相当于 `code` 段相当于实际的代码段；而后

     ```assembly
     start:	MOV AX,stack
     		MOV SS,AX
     		MOV SP,20h	; 设置栈顶 ss:sp 指向 stack:20h
     ```

     三条指令将 我们定义的 `stack` **段的段地址** 送入 `ss` 寄存器中，并将 `ss:sp` 指向栈顶。此时，`stack` 段方才相当于一个栈空间，或者说一个栈段。由此可见，这个段的定义完全由我们使用汇编指令手动完成。

     将 `code` 段 定义为 数据段 也类似，由以下三条指令完成：

     ```assembly
     MOV AX,data
     MOV DS,AX	; ds 指向 data 段
     MOV bx,0	; ds:bx 指向 data 段中段第一个单元
     ```



## 实验 5 编写、调试具有多个段的程序

- 第 (1) 题，源程序1

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	DW 0,0,0,0,0,0,0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends
end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.



- 第 (2) 题，源程序2

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h
data ends

stack segment
	DW 0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends
end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.

4. 对于如下定义的段：

   ```assembly
   name segment
   ...
   name ends
   ```

   如果段中的数据占 N 个字节，则程序加载后，该段的实际占有空间为 **16 字节**。



- 第 (3) 题，源程序 3

```assembly
assume CS:code,DS:data,SS:stack

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends

data segment
	DW 0123h,0456h
data ends

stack segment
	DW 0,0
stack ends

end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.



- 第 (4) 题，问：如果将 (1) (2) (3) 中最后一条伪指令 `end start` 改为 `end` （也就是不指明程序入口），那个程序仍可以正确执行？说明原因。

  *实践前的猜想* ：~~熟悉做题的套路的人都直到应该是第三个。因为就它跟前两个不一样。~~

  应该是是第三个，因为根据前面写程序的经验，在没有程序入口标号之前，所有段都是在代码段里执行的。而且当时并没有程序入口标号，更别提使用 `end` 伪指令指明程序入口，程序一样会从代码段执行，因此答案应该是源程序3.

  验证：结果与猜想基本一直，下面讨论一些细节问题。

  1. 以修改后的 源程序2 和 源程序 3 为例。与猜想一致，在没有指定程序入口后，代码段就有所不同。

     使用 `u cs:0` 命令后发现 源程序 2 的结果并不是直接指向 代码段的汇编指令，而 源程序 3 则是。

  2. 使用 `u cs:8` 依然看到代码段的汇编指令。猜想是，代码段和数据段总共加起来八个字节，如果按照定义的数据的大小，使用此命令后应该是能看到代码段的汇编指令的，为何？

     由此联想到 第 (2) 题 的第四小问：**如果段中的数据占 N 个字节，则程序加载后，该段的实际占有空间为 \_\_\_\_字节 **。按 第 (2) 题 的推断是 **16 字节**。于是，验证如下，先看看修改后的 源程序 3 的调试结果：

     ![ex5_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex5_1.png)

     再来看看 源程序 2：

     ![ex5_2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex5_2.png)

  - 结论：
    1. 如果段中的数据占 N 个字节，则程序加载后，该段的实际占有空间为 **16 字节**。
    2. 实验题要做，不做会漏掉很多知识点和细节问题。脚踏实地做实验有利于融会贯通。



- 第 (5) 题 编写 `code` 段的代码，将 a 段 和 b 段 的数据依次相加，结果存到 c 段中。

  我的答案：

  ```assembly
  assume CS:code
  a segment
  	DB 1,2,3,4,5,6,7,8
  a ends
  
  b segment
  	DB 1,2,3,4,5,6,7,8
  b ends
  
  c segment
  	DB 0,0,0,0,0,0,0,0
  c ends
  
  code segment
  
  start:	SUB bx,bx
  	MOV CX,8
  	
  s:	MOV AX,a
  	MOV DS,AX
  	SUB DX,DX
  	MOV DL,DS:[bx]
  
  	MOV AX,b
  	MOV DS,AX
  	SUB AX,AX
  	MOV AL,DS:[bx]
  	ADD DX,	AX
  
  	MOV AX,c
  	MOV DS,AX
  	MOV DS:[bx],DL
  
  	INC bx
  	LOOP s
  
  	MOV AX,4C00H
  	INT 21H
  
  code ends
  end start
  ```

  用了 16 条指令，`AX，BX，CX，DX` 四个16位通用寄存器，和 `AL，DL` 两个 8 位通用寄存器。暂时到这里，有时间想象怎么改进。



- 第 (6) 题：编写 `code` 段的代码，用 `push` 指令将 `a` 段中的前 8 个字型数据，逆序存储到 `b` 段中。

  我的答案：

  ```assembly
  assume CS:code
  a segment
  	DW 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
  a ends
  
  b segment
  	DW 0,0,0,0,0,0,0,0
  b ends
  
  code segment
  
  start:	MOV AX,a
  	MOV DS,AX
  	SUB bx,bx
  	MOV CX,8
  
  	MOV AX,b
  	MOV SS,AX
  	MOV sp,10h
  
  s:	PUSH [bx]
  	ADD bx,2
  	LOOP s
  
  	MOV AX,4C00H
  	INT 21H
  
  code ends
  end start
  ```

  从结果看没有什么问题，需要注意由于面向的是 字单元，因此相比上一个题目，数据的的偏移地址每次应增加 2，而不是一；类似的，栈顶指针应拨回 16 个内存单元，而不是 8 个。



# 10. 更灵活的定位内存地址的方法

## 10.1 `and` 和 `or` 指令

1. **`and`** 指令，逻辑 **与** 指令，按位进行与运算。

   该指令可将操作对象的相应位设为 0 ，其他位不变。例如：

   ```assembly
   and al,1011111B	; 将 al 的第六位置零
   and al,0111111B	; 将 al 的第七位置零
   and al,1111110B	; 将 al 的第零位置零
   ```

2. **`or`** 指令，逻辑 **或** 指令，按位进行或运算。

   该指令可将操作对象相应位设为 1，其他位不变。例如：

   ```assembly
   and al,0100000B	; 将 al 的第六位置一
   and al,1000000B	; 将 al 的第七位置一
   and al,0000001B	; 将 al 的第零位置一
   ```


> **注意** ： 
>
> **原书是从零开始计位**，本册子因为打了个马虎眼少看到个零，只能硬着头皮从一开始计位。
>
> 值得吐槽的是，在这里例子中王老师的书没有任何的提示。而在后面的 **大小写转换问题** 时，关于控制大小写字符的二进制位时，王老师才说 是第五位并在括号后面标注 **位数从 0 开始计算**。致使看书不仔细的我一直纠结到底是第六位还是第五位。。。。

## 10.2 关于ASCII 码

- 编码与解码：

  将信息存入计算机中需要对其进行编码，反之，取来时需要对其进行解码。编码和解码采用同一规则时，计算机便可对数据进行自由存取。而 **最早** 出现的编码规则就是 `ASCII`编码。关于更多编解码的问题可以参考博文 [【字符编码】彻底理解字符编码](https://www.cnblogs.com/leesf456/p/5317574.html)。

- 文本编辑器 编辑文本时 显示 文本内容 的过程：

  以键盘输入字符 `a` 并显示在屏幕上的过程为例：

  1. 按下键盘的 `A` 键，这个按键信息被送入计算机，计算机用 `ASCII` 码的规则对其进行编码，将其转换为 `61H`（`ASCII` 编码中，用 `61H` 表示 `a`） 存储再内容的指定空间中；
  2. 文本编辑器软件从内存中取出 `61H`，将其送到到显卡的显存中；
  3. 工作在文本模式下的显卡，用 `ASCII` 码的规则解释显存的内容，`61H` 被当作字符 `a` ，显卡驱动显示器，将字符 “a” 的图像画在屏幕上。

  

## 10.3 以字符形式给出的数据

- 在汇编程序我们可以用 `'.....'` 的方式指明数据是字符的形式给出的，编译器将把他们转换为相对应的 `ASCII` 码。如下例：

  ```assembly
  assume CS:code,DS:data
  data segment
  	DB 'Unix'
  	DB 'foRK'
  data ends
  
  code segment
  
  start:	MOV AL,'a'
  	MOV BL,'b'
  	MOV AX,4C00H
  	INT 21H
  code ends
  end start
  ```

- 调试信息：

  ![10_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/10_1.png)

  从以上信息我们可以看出，

  1. `DS` 段地址 + `10H` 就是数据段的段地址。
  2. 虽然 有两个字符串的定义，但是由于这个字符串都在同一数据段中，因此它们的内存地址是连续的，而不是分属两个段。
  3. 英文字母在内存中以 `ASCII` 码的形式存储。

## 10.4  大小写转换问题

- 部分大小写字母的 `ASCII` 码对比：

| 大写 | 十六进制 |  二进制  | 小写 | 十六进制 |  二进制  |
| :--: | :------: | :------: | :--: | :------: | :------: |
|  A   |    41    | 01000001 |  a   |    61    | 01100001 |
|  B   |    42    | 01000010 |  b   |    62    | 01100010 |
|  C   |    43    | 01000011 |  c   |    63    | 01100011 |
|  D   |    44    | 01000100 |  d   |    64    | 01100100 |
|  E   |    45    | 01000101 |  e   |    65    | 01100101 |

- 以上，发现规律：**大写字母** `ASCII` 码 **+ `20H =`**  对应的 **小写字母** 的 `ASCII` 码。

- 换而言之，字母的 `ASCII`码 **二进制** 的 **第六位** 决定这个是大小还是小写。

- 将 **大写字母** 的`ASCII`码 **二进制** **第六位** 置一（**`or al,00100000B`**）即可变成小写字母。

- 将 **小写字母** 的`ASCII`码 **二进制** **第六位** 置零（**`and al,11011111B`**）即可变成大写字母。

  （假设字母存储于寄存器 `al` 中，并且，二进制位 **从一开始计数！从一开始计数！！从一开始计数！！！**）

- 编程题：将第一个字符串转化为大写，第二个字符串转换为小写。

  ```assembly
  assume cs:code,ds:data
  data segment
  	db 'BaSiC'
  	db 'iNfOrMaTiOn'
  data ends
  
  code segment
  
  start:	mov ax,data
  		mov ds,ax	; 设置 ds 指向 data 段
  
  		mov bx,0	; 设置 (bx) = 0, bx 指向 'BaSiC' 的第一个字母
  		mov cx,5	; 设置循环次数 5, 因为 'BaSiC' 有五个字母
  
  s:		mov al,[bx]			; 将 ASCII 码从 ds:bx 所指向的单元取出
  		and al,11011111B	; 将 al 中的 ASCII 码的第六位置零，变成大写字母
  		mov [bx],al			; 将转化后的 ASCII 码写回源单元
  		inc bx				; (bx) 加一， ds:bx 指向下一个字母
  		loop s
  
  		mov bx,5			; 设置 (bx) = 5, ds:bx 指向 'iNfOrMaTiOn' 的第一个字母
  		mov cx,11			; 设置循环次数 11，因为 'iNfOrMaTiOn' 有十一个字母
  
  s0:		mov al,[bx]
  		or al,00100000B		;将 al 中的 ASCII 码的第六位置零，变成小写字母
  		mov [bx],al
  		inc bx
  		loop s0
  	
  		mov ax,4C00H
  		int 21H
  code ends
  end start
  ```




## 10.5 更多寻址方式

### 10.5.1 `[bx+idata]`

试看如下指令：

```assembly
mov ax,[bx+200]
```

表示：将一个字内存单元送入寄存器 `AX` 中，这个字单元的段地址在 段寄存器 `DS` 中，偏移地址为 `(bx)` 加上立即数（immediate data）200.

可用前面我们规定的规则对其进行解释：`(ax) = ( (ds)*16 + (bx)+200 )`.

这条指令还有其他常用格式：

```assembly
mov ax,[200+bx]
mov ax,200[bx]		; 是不是跟数组的形式很相似？
mov ax,[bx].200		; 跟结构体是不是有丁点关系？
```

- `[bx+idata]` 的应用：将下列程序中的`code`段中 第一个字符串转化为大写，第二个字符串转化为小写。

  1. 方法一，使用 `[bx]` ：

     ```assembly
     assume cs:code,ds:data
     data segment
     	db 'BaSiC'
     	db 'MinIX'
     data ends
     
     code segment
     
     start:	mov ax,data
     		mov ds,ax	
     
     		mov bx,0	
     		mov cx,5	
     
     s:		mov al,[bx]			
     		and al,11011111b	
     		mov [bx],al	
     		inc bx				
     		loop s
     
     		mov bx,5			
     		mov cx,5		
     
     s0:		mov al,[bx]
     		or al,00100000b
     		mov [bx],al
     		inc bx
     		loop s0
     	
     		mov ax,4C00H
     		int 21H
     code ends
     end start
     ```

  2. 方法二，使用 `[bx+idata]`

     ```assembly
     assume cs:code,ds:data
     data segment
     	db 'BaSiC'
     	db 'MinIX'
     data ends
     
     code segment
     
     start:	mov ax,data
     		mov ds,ax	
     
     		mov bx,0	
     		mov cx,5	
     
     s:		mov al,[bx]		; or  mov al,0[bx]	
     		and al,11011111b	
     		mov [bx],al		; or  mov 0[bx],al
     
     		mov al,[5+bx]	; or  mov al,5[bx]
     		or al,00100000b
     		mov [5+bx],al	; or  mov 5[bx],al
     		
     		inc bx		
     		loop s
     
     		mov ax,4C00H
     		int 21H
     code ends
     end start
     ```

     *说实话，要不是两个字符串都刚好长度为 5的话，即使 `[bx+idata]` 这种方式也不能使程序更简洁。。。*

- 以上程序类比 C 语言描述：

  ```c
  char a[5] = "BaSiC";
  char b[5] = "MinIX";
  
  void main(){
      int i = 5;
      do{
          a[i] = a[i] & 0xDF;
          b[i] = b[i] | 0x20;
      }while(i<5);
  }
  ```

  类比一下：

  C 语言：	`a[i]`，	`b[i]`

  汇编语言：`0[bx]`，`5[bx]`

  结论是：*`[bx+idata]` 方式为高级语言实现数组提供了便利机制。* 这就是复杂指令集的特征，不保证硬件的简单性，而保持指令的简洁性，因此更接近高级语言。



### 10.5.2 SI 和 DI

**SI 和 DI** 是 8086 CPU 中和 **BX** 功能相近的寄存器，**SI 和 DI 不能分成两个 8 位寄存器**。

示例1：`#1,#2,#3` 实现相同的功能

```assembly
mov bx,0
mov ax,[bx]		; #1

mov si,0
mov ax,[si]		; #2

mov di,0
mov ax,[di]		; #3
```
示例2：`#1,#2,#3` 也是实现相同的功能

```assembly
mov bx,0
mov ax,[bx+123]		; #1

mov si,0
mov ax,[si+123]		; #2

mov di,0
mov ax,[di+123]		; #3
```



### 10.5.3 `[bx+si]` 和 `[bx+di]`

`[bx+si]` : 段地址为 `(ds)` ,偏移地址为 `((bx)+(si))` 的内存单元。或者说，地址为 `(ds)*16 +((bx)+(si)) ` 的内存单元。

可以有其他格式：

```assembly
mov ax,[bx][si]		; 等价于 mov ax,[bx+si]
mov ax,[bx][di]		; 等价于 mov ax,[bx+di]
```



### 10.5.4 `[bx+si+idata]` 和 `[bx+di+idata]`

二者相似，以`mov ax,[bx+si+idata]` 示例，

`[bx+si+idata]` 表示一个内存单元，它的地址是 `(ds)*16 + ((bx)+(si)+idata)`，将其值送入 寄存器 `ax` 中。

也可写作以下常用格式：

```assembly
mov ax,[bx+200+si]
mov ax,[200+bx+si]
mov ax,200[bx][si]
mov ax,[bx].200[si]
mov ax,[bx][si].200
```



### 10.5.5 不同寻址方式的应用

- 源程序10_5，将 `dataseg` 段中每个单词改为大写字母，（*原书 问题 7.7，154页*）

  ```assembly
  assume cs:code,ds:data
  data segment
  	db 'ibm             '	; 每个字符串长度都为 16，以空格补缺
  	db 'dec             '
  	db 'dos             '
  	db 'vax             '
  data ends
  
  code segment
  
  start:	mov ax,data
  		mov ds,ax	
  
  		mov bx,0	
  		mov cx,4
  
  s0:		mov dx,cx		; 将外层循环 cx 的值保存在 dx 中
  		mov si,0
  		mov cx,3
  
  s:		mov al,[bx+si]
  		and al,11011111b
  		mov [bx+si],al
  		inc si
  		loop s
  
  		add bx,16
  		mov cx,dx
  		loop s0		; 外层循环 loop 指令将 cx 中的计数值减一
  
  		mov ax,4C00H
  		int 21H
  code ends
  end start
  ```

  由于此程序中使用了比较多的寄存器，对于更复杂的情况不具有代表性，因此，本书做了如下改进：源程序10_6

  ```assembly
  assume cs:code,ds:data,ss:stack
  data segment
  	db 'ibm             '	; 每个字符串长度都为 16，以空格补缺
  	db 'dec             '
  	db 'dos             '
  	db 'vax             '
  data ends
  
  stack segment
  	dw 0,0,0,0,0,0,0,0
  stack ends
  
  code segment
  
  start:	mov ax,stack
  		mov ss,ax
  		mov sp,16
  		
  		mov ax,data
  		mov ds,ax
  		mov bx,0
  
  		mov cx,4
  
  s0:		push cx		; 将外层循环 cx 的值压栈
  		mov si,0
  		mov cx,3
  
  s:		mov al,[bx+si]
  		and al,11011111b
  		mov [bx+si],al
  		inc si
  		loop s
  
  		add bx,16
  		pop cx		; 从栈顶弹出原 cx 的值，恢复 cx
  		loop s0		; 外层循环 loop 指令将 cx 中的计数值减一
  
  		mov ax,4C00H
  		int 21H
  code ends
  end start
  ```

  和上一个程序不一样，此程序并没有外层循环的变量 `(cx)` 储存在寄存器中，而是先放在预先定义好的栈空间里。由此引出一些汇编的固有规则：

  1. 尽可能**少**地**使用寄存器**，因此寄存器数量有限，资源很昂贵。
  2. 一般来说数据需要**暂存**时，尽量使**用栈**。

  附图两张：

  源程序 10_5，调试图

  ![10_5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/10_5.png)

  源程序 10_6 调试图

  ![10_6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/10_6.png)



## 实验 6 时间课程中的程序

问题 7.9 将 `data` 中的每个单词的前四个字母改为大写字母。

```assembly
assume cs:code,ds:data,ss:stack
stack segment
	dw 0,0,0,0,0,0,0,0
stack ends

data segment
	db '1. dispaly      '		; 每个字符串长度都为 16，空格补缺
	db '2. brows        '		; 小数点与 单词之间用一个空格隔开
	db '3. replace      '
	db '4. modify       '
data ends

code segment

start:	mov ax,stack
		mov ss,ax
		mov sp,16
		
		mov ax,data
		mov ds,ax
		mov bx,0

		mov cx,4

s0:		push cx		; 将外层循环 cx 的值压栈
		mov si,0
		mov cx,4

s:		mov al,[3+bx+si]
		and al,11011111b
		mov [3+bx+si],al
		inc si
		loop s

		add bx,16
		pop cx		; 从栈顶弹出原 cx 的值，恢复 cx
		loop s0		; 外层循环 loop 指令将 cx 中的计数值减一

		mov ax,4C00H
		int 21H
code ends
end start
```

~~这个题目没有多做思考，完全套用源程序10_6，看到对栈如此娴熟地使用，不得不心生佩服，妙，实在是妙啊。这要让我不参考，闷头去想，估计一上午就没了。。。~~



# 11. 数据处理的两个基本问题

定义两个描述性符号：

`reg` 表示一个寄存器，`reg` 的集合包括：`ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di`；

`sreg` 表示一个段寄存器，`sreg` 的集合包括：`ds, ss, cs, es`.

## 11.1 `bx、si、di、` 和  `bp`

1. 在 8086 CPU 中，**只有这四个** 寄存器 **可以** 用在 "[...]" 中来进行内存单元的 **寻址**。如下例：

   ```assembly
   mov ax,[bx]
   mov ax,[bx+si]
   mov ax,[bx+di]
   mov ax,[bp]
   mov ax,[bp+si]
   mov ax,[bp+di]
   ```

   下面的指令都是 **错误** 的：

   ```assembly
   mov ax,[cx]		# error
   mov ax,[ax]		# error
   mov ax,[dx]		# error
   mov ax,[ds]		# error
   ```

   

2. 这四个寄存器可以 **单个出现**：**`[bx]`，`[bp]`、`[si]`、`[di]`**;

   或 **只能** 以四种组合出现：`bx` 和 `si` 、`bx` 和 `di` 、`bp` 和 `si` 、`bp` 和 `di`.

   |      |            `si`            |            `di`            |
   | :--: | :------------------------: | :------------------------: |
   | `bx` | `[bx+si]`、`[bx+si+idata]` | `[bx+di]`、`[bx+di+idata]` |
   | `bp` | `[bp+si]`、`[bp+si+idata]` | `[bp+di]`、`[bp+di+idata]` |



3. 只要在 `[...]` 中使用寄存器 **`bp`** ，而指令中 **没有**显示地**给出段**地址，**段地址** 就 **默认在**栈段寄存器 **`ss`** 中。如下例：

   ```assembly
   mov ax,[bp]		; 段地址默认在 ss 中
   mov ax,[bp+si]	; 段地址默认在 ss 中
   mov ax,ds:[bp]	; 段地址显示地给出在 ds 中
   ```

   



## 11.2 机器指令处理的数据在什么地方

1. 绝大部分机器指令都是进行 **数据处理** 指令，处理大致可分为 3 类：**读取**、**写入**、**运算**。

2. 机器指令不关心数据的值几何，只关心 **指令执行前一刻**，它将要处理的**数据所在**的**位置**。

3. 指令执行前，所要处理的数据可以存在以下 **三** 个地方：

   CPU 内部，内存，端口。

   如下例：

   |   机器码   |   汇编指令   | 指令执行前数据的位置  |
   | :--------: | :----------: | :-------------------: |
   | `8E1E0000` | `mov bx,[0]` |  内存，`ds[0]` 单元   |
   |   `89C3`   | `mov bx,ax`  | CPU 内部，`ax` 寄存器 |
   |  `BB0100`  |  `mov bx,1`  | CPU 内部，指令缓冲器  |



## 11.3 汇编语言中数据位置的表达

汇编语言用 3 个概念来表达数据的位置：

1. **立即数** （`idata`）

   对于直接**包含在** 机器 **指令中** 的数据（执行前在 CPU 的 **指令缓冲器** 中），在汇编语言中被称为  **立即数**。 在汇编指令中直接给出。如下例：

   ```assembly
   mov ax,1
   mov bx,200h
   mov bx,010000b
   mov al,'a'		; 单个字符也属于立即数
   ```

   - 注意：

      单个字符也属于立即数，但是汇编指令中还是会以 `ascii ` 码的形式存储，跟数值没有什么区别，因此，除了`push` 这类特殊指令外，在没有寄存器参的指令中也写需要使用 `X ptr` 向编译器指明操作对象所占的字节数。

     

2. **寄存器**

   指令要处理的**数据在寄存器中**，在汇编指令中给处相应的寄存器名。如下例：

   ```assembly
   mov ax,bx
   mov ds,ax
   push bx
   mov ds:[0],bx		;ds:[0] 是存在内存中的吧
   push ds
   mov ss,ax
   mov sp,ax
   ```

   

3. 段地址（**SA**） 和 偏移地址（**EA**）

   指令要处理的数据存在**内存**中，在汇编指令中可用 **[X]** 的格式给出**EA**，**SA** 在某个段寄存器中。存放段地址的寄存器可以是默认的，比如：

   ```assembly
   mov ax,[bx+si+8]	; 段地址默认在 ds 中
   mov ax,[bp+si+8]	; 段地址默认在 ss 中
   mov ax,ds:[bp]		; 段地址显示地给出在 ds 中
   mov ax,es:[bx]		; 段地址显示地给出在 es 中
   ```



## 11.4 寻址方式

用 **偏移地址** 来定位内存的方法被称为 **寻址方式**。分为以下几种：

### 11.4.1 直接寻址

|     名称     | 寻址方式  |        含义        | 常用格式举例 |
| :----------: | :-------: | :----------------: | :----------: |
| **直接寻址** | `[idata]` | `SA=idata,EA=(ds)` |  `[idata]`   |

### 11.4.2 寄存器间接寻址

| 寻址方式 |       含义        | 常用格式举例 |
| :------: | :---------------: | :----------: |
|  `[bx]`  | `SA=(bx),EA=(ds)` |    `[bx]`    |
|  `[si]`  | `SA=(si),EA=(ds)` |    `[si]`    |
|  `[di]`  | `SA=(di),EA=(ds)` |    `[di]`    |
|  `[bp]`  | `SA=(bp),EA=(ss)` |    `[bp]`    |

### 11.4.3 寄存器相对寻址

|   寻址方式   |          含义           |            常用格式举例             |
| :----------: | :---------------------: | :---------------------------------: |
| `[bx+idata]` | `SA=(bx)+idata,EA=(ds)` |      用于结构体：`[bx].idata`       |
| `[si+idata]` | `SA=(si)+idata,EA=(ds)` | 用于数组：`idata[si]` ，`idata[di]` |
| `[di+idata]` | `SA=(di)+idata,EA=(ds)` |     用于二维数组：`[di][idta]`      |
| `[bp+idata]` | `SA=(bp)+idata,EA=(ss)` |                 ——                  |

### 11.4.4 基址变址寻址

| 寻址方式  |          含义          |       常用格式举例       |
| :-------: | :--------------------: | :----------------------: |
| `[bx+si]` | `SA=(bx)+(si),EA=(ds)` | 用于二维数组：`[bx][si]` |
| `[bx+di]` | `SA=(si)+(di),EA=(ds)` |            ——            |
| `[bp+si]` | `SA=(bp)+(di),EA=(ds)` |            ——            |
| `[bp+di]` | `SA=(bp)+(di),EA=(ss)` |            ——            |

### 11.4.5 相对基址变址寻址

|    寻址方式     |             含义             |                    常用格式举例                    |
| :-------------: | :--------------------------: | :------------------------------------------------: |
| `[bx+si+idata]` | `SA=(bx)+(si)+idata,EA=(ds)` |           用于二维数组：`idata[bx][si]`            |
| `[bx+di+idata]` | `SA=(si)+(di)+idata,EA=(ds)` | 用于表格（结构）中的数据项：<br />`[bx].idata[si]` |
| `[bp+si+idata]` | `SA=(bp)+(di)+idata,EA=(ds)` |                         ——                         |
| `[bp+di+idata]` | `SA=(bp)+(di)+idata,EA=(ss)` |                         ——                         |



## 11.5 指令要处理的数据有多长

在 8086 CPU 指令中，可以处理两种尺寸的数据：**`byte`** 和 **`word`**. 所以在指令中要指明，要进行的是字操作还是字节操作。以下是处理方法：

1. 通过 **寄存器名** 指明要处理的数据的尺寸。如下例：

   ```assembly
   mov ax,1		; 字操作
   mov bx,ds:[0]	; 字操作
   
   mov al,8		; 字节操作
   mov bl,ds:[0]	; 字节操作
   ```

   

2. 在没有寄存器名的情况下，用操作符 **`X ptr`** 指明内存单元的长度，**`X`**  在汇编指令中可以是 **word** 或 **byte** . 如下例：

   ```assembly
   mov word ptr ds:[0],1	; 字操作
   inc word ptr [bx]		; 字操作
   add word ptr [bx],2		; 字操作
   
   mov ds:[0],word ptr 10H ; 字操作
   
   mov byte ptr ds:[0],1	; 字节操作
   inc byte ptr [bx]		; 字节操作
   add byte ptr [bx],2		; 字节操作
   
   mov ds:[0],byte ptr 1	; 字节操作
   ```

   **注意**：如上例中， 我们可以看到， **`X ptr` 操作符不仅可以放在指令后，也可以放在操作数之前**。这对于解锁 **`mov`** 指令的新用法 ，即立即数直接送入内存单元（如上 **`mov ds:[0],word ptr 10H`** ），很有启示。

   

3. 其他方法，某些指令默认访问的是字单元还是字节单元，如 出栈操作 **`pop`** 和 入栈操作 **`push`**，就规定是字操作。例如：

    ```assembly
    push [100H]		; 将 (ds)*16 + 100H 处的字单元压入栈中。
    ```



## 11.6 寻址方式的综合应用

下面通过一个问题来讨论以下寻址方式的作用。

关于 DEC 公司的一条记录（1982年）如下：

公司名称：DEC

总裁姓名：Ken Olsen

排名：137

收入：40（亿美元）

著名产品：PDP（小型机）

这些数据在内存种以如下图的方式存放：

![11_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/11_1-1599730523302.png)

假设这些数据被存放在 `seg` 段中，从偏移地址 60H 的起始位置开始。

到 1988 年 该公司的信息有了如下变化：

(1) Ken Olsen 在富豪榜上的排名升至 38 位；

(2) DEC 的收入增加了 70 亿美元；

(3) 该公司的著名产品已变为 VAX 系列计算机。

于是，我们要对这三条信息进行相应的修改，以汇编语言的形式，我们有如下程序：

```assembly
mov ax.seg
mov ds,ax
mov bx,60h	; 确定记录地址：ds;bx

mov word ptr [bx+0ch],38	; 排名字段改为 38
add word ptr [bx+0eh],70	; 收入字段增加 70

mov si,0			; 用 si 来定位产品字符串中的字符
mov byte ptr [bx+10h+si],'V'
inc si
mov byte ptr [bx+10h+si],'A'
inc si
mov byte ptr [bx+10h+si],'X'
```

用 C 语言描述这个程序：

```c
struct company {	/* 定义一个公司记录的结构体 */
    char cn[3];		/* 公司名称 */
    char hn[9];		/* 总裁姓名 */
    int pm;			/* 排   行 */
    int st;			/* 收   入 */
    char cp[3];		/* 著名产品 */
}

/* 定义一个公司记录的结构体变量，内存中将存有一条公司的记录 */
struct company dec = {"DEC","Ken Olsen",137,40,"PDP"}

int main()
{
    int i;
    dec.pm = 38;
    dec.st += 70;
    i = 0;
    dec.cp[i] = 'V';
    i++；
    dec.cp[i] = 'A';
    i++;
    dec.cp[i] = 'X';
    return;
}
```

接下来按 C 语言的风格对上面的汇编程序进行修改，好好体会一下：

```assembly
mov ax.seg
mov ds,ax
mov bx,60h	; 确定记录地址：ds;bx

mov word ptr [bx].0ch,38	; 排名字段改为 38
add word ptr [bx].0eh,70	; 收入字段增加 70

mov si,0			; 用 si 来定位产品字符串中的字符
mov byte ptr [bx].10h[si],'V'
inc si
mov byte ptr [bx].10h[si],'A'
inc si
mov byte ptr [bx].10h[si],'X'
```



## 11.7 div 指令

`div` 就是除法指令，其中操作对象的关系如下表示：

| 除数  |                 被除数                  |  商  | 余数 |
| :---: | :-------------------------------------: | :--: | :--: |
| 8 位  |           16 位，默认存 `AX`            | `AL` | `AH` |
| 16 位 | 32 位，`DX` 存高 16 位，`AX` 存低 16 位 | `AX` | `DX` |

- 格式如下：

  ```
  div reg
  div 内存单元
  ```

  `reg` 和 内存单元 里存放的都是 除数。

- 实例如下：

  ```assembly
  div byte ptr es:[9]		; 除数是 (es:[9]), 被除数是 (ax)
  div word ptr [bx+si+8]	; 除数是 (ds:[bx+si+8]),
  						; 被除数是 (DX)*1000H + (AX)
  ```

概念就这么多，要想熟练多加练习吧。



## 11.8 伪指令 `dd` 和 `dup` 操作符

​	和 `db`,`dw` 类似，`dd` 也是由编译器识别的伪指令。

**`dd`** 是用来定义 **`dword`** (double word, 双字) 型数据的。如下例：

```assembly
data segment
	dw 1	; 占一个字节
	dd 1	; 占两个字节
data ends
```

第一个数据在 `data:0` 处，

第二个数据在 `data:2` 处，占两个字节。

---

**`dup`** 是一个操作符，和 **`dd`** 一样，由编译器识别处理。它用来与伪指令 `db`,`dw`,`dd` 等数据定义的伪指令配合使用，用来进行 **数据的重复**。如下例：

```assembly
db 3 dup (0)	; 定义了 3 个字节，他们的值都是零，相当于 db 0,0,0
db 3 dup (1,2,3) ; 定义了 9 个字节，相当于 db 1,2,3,1,2,3,1,2,3
db 3 dup ('abc') ; 定义了 9 个字节，相当于 db 'abcabcabc'
```



## 实验 7 寻址方式在结构化数据访问中的应用

- 题目：

  Power idea 公司从 1975 年成立一直到 1995 年的基本情况如下。

| 年份 | 收入（千美元） | 雇员（人） | 人均收入（美元） |
| :--: | :------------: | :--------: | :--------------: |
| 1975 |       16       |     3      |        ？        |
| 1976 |       22       |     7      |        ？        |
| ...  |                |            |                  |
| 1995 |    5937000     |   17800    |        ?         |

下面的程序中已经定义好了这些数据：

```assembly
data segment
	db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
	db '1984','1985',1986','1987','1988','1989','1990','1991','1992'
	db '1993','1994','1995'
	; 以上是表示 21 年的字符串
	
	dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
    ;以上是表示21年公司总收入的21个dword型数据
    
    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
    dw 11542,14430,15257,17800
    ;以上是表示21年公司雇员人数的21个word型数据
data ends

table segment
	db 21 dup ('year summary')
table ends
```

编程，将 data 段中的数据按如下格式写入到 table 段中，并计算 21 年中的人均收入（取整），结果也按照下面的格式保存在 table 段中。

![ex7](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex7.png)

我的答案：

```assembly
assume CS:code

data segment
	db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
	db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
	db '1993','1994','1995'
	; 以上是表示 21 年的字符串
	
	dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
    ;以上是表示21年公司总收入的21个dword型数据
    
    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
    dw 11542,14430,15257,17800
    ;以上是表示21年公司雇员人数的21个word型数据
data ends

table segment
	db 21 dup ('year summ ne ?? ')
table ends

code segment
	
start:	mov ax,data
		mov ds,ax

		mov ax,table
		mov es,ax

		mov bx,0
		MOV DI,0
		mov si,0
		mov cx,21

s:		mov ax,ds:[bx]
		mov es:[si],ax
		mov ax,ds:[2+bx]
		mov es:[2+si],ax				; 0~3 列，年份

		mov BYTE ptr es:[4+si],' '		; 4 列，空格

		mov ax,ds:[54h+bx]
		mov es:[5+si],ax
		mov dx,ds:[56h+bx]
		mov es:[7+si],dx				; 5~8 列，被除数，收入	
		
		div WORD ptr ds:[0a8h+di]
		mov es:[0dh+si],ax				; d~e 列，商，人均收入取整

		mov BYTE ptr es:[9+si],' '		; 9 列，空格

		mov ax,ds:[0a8h+di]
		mov es:[0ah+si],ax				; a~b 除数，雇员

		MOV BYTE ptr es:[0ch+si],' '	; c 列，空格

		MOV BYTE ptr es:[0fh+si],' '	; f 列，空格
		
		ADD DI,2
		ADD bx,4
		add si,10h

		loop s

		MOV AX,4C00H
		INT 21H

code ends
end start
```

- 编程总结：

1. 拼写错误，比如段定义语句拼写错误。
2. 未指明操作对象所占字节大小。比如 `MOV BYTE ptr es:[0ch+si],' '` 经常性忽视掉 `byte ptr` 标记。
3. `assume` 伪指令，比如，`ds:data`，但是忽略了 `table` 段也在数据段中；定义了栈段却没有用 `assume` 伪指令关联。导致报错不断。

- 思考：

  没有什么巧妙的设计思路，就是乱堆，几乎用掉了所有能用到的寄存器。没有用到栈。也没有用到二维数组之类的`[bx+si+idata]` 相对基址变址寻址方式。暂且如此，待*(bu)*来*(ke)*日*(neng)*优化。结果如下图：

  ![ex7_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex7_1.png)



# 12. 转移指令的原理

**可以修改 `IP`，或者同时修改 `CS` 和 `IP` 的指令统称为转移指令。**

- 8086 CPU 的**转移行为**有以下几个：
  - **只修改 `IP`** 时，称为 **段内转移** ，比如，`jmp ax`.
  - **同时修改** `CS` 和 `IP` 时，称为 **段间转移**，比如 `jmp 1000:0`
- 根据 指令 **对 `IP` 修改范 围** 的不同，段内转移又分为：段转移和近转移。
  - **短转移** `IP` 的修改范围为 `-128 ~ 127`. （两个字节，**一个字** 以内）
  - **近转移** `IP` 的修改范围为 `32768 ~ 32768`. （四个字节，**两个字** 以内）
- 8086 CPU 的转移指令分为以下几类：
  - 无条件转移指令（如：`jmp`）
  - 条件转移指令
  - 循环指令（如：`loop`）
  - 过程
  - 中断
  
  

## 12.1 操作符 offset

操作符 `offset` 在汇编语言中是由**编译器处理**的符号，它的功能是 **取得标号的偏移地址**。如下例：

```assembly
assume cs:code
code segment
	start:	mov ax,offset start		; 相当于 mov ax,0
		s:	mov ax,offset s			; 相当于 mov ax,3
end start
```

例题1：该程序在运行中将 s 处的一条指令复制到 `s0` 处。

```assembly
assume cs:code
code segment
	s:	MOV AX,bx
		MOV SI, offset s
		MOV DI, offset s0
		MOV AX,CS:[SI]		
		MOV CS:[DI],AX
	s0:	NOP			; no operation 啥也不干，
		NOP			; 机器码占一个字节
code ends
end s
```



## 12.2 `jmp` 指令

`jmp` 为无条件转移指令，可以修改 `IP` ，也可以同时修改 `CS` 和 `IP` .

`jmp` 指令要给出的两种信息：

- 转移的目的地址
- 转移的距离（段间转移、段内转移，段内近转移）



## 12.3 依据位移进行转移的 `jmp` 指令

**`jmp short 标号`**（转到标号处执行指令）

**`short`** 符号说明指令进行的是**段内短转移**，对 `IP` 的修改范围为 `-128 ~ 127`. 标号指代码段中的标号，指明指令要转移的目的地。如下例一：

```assembly
assume cs:code
code segment
	start:		mov ax,0
				jmp short s
				add ax,1
	s:			inc ax
code ends
end start
```

上面的程序执行后，`ax=1`，因为只进行了一次加一。

用 `debug` 程序查看其机器码：

|    地址     |  机器指令  |   汇编指令    |
| :---------: | :--------: | :-----------: |
| `0BBD:0000` | `B8 00 00` | `MOV AX,0000` |
| `0BBD:0003` |  `EB 03`   |  `JMP 0008`   |
| `0BBD:0005` | `05 01 00` | `ADD AX,0001` |
| `0BBD:0008` |    `40`    |   `INC AX`    |

程序中 `jmp short s ` 所对应的机器码是 **`EB03`**.

对例一稍作修改，称为例二：

```assembly
assume cs:code
code segment
start:	mov ax,0
		mov bx,0
        jmp short s
        add ax,1
s:		inc ax
code ends
end start
```

同样用 `debug` 程序查看其机器码：

|    地址     |  机器指令  |   汇编指令    |
| :---------: | :--------: | :-----------: |
| `0BBD:0000` | `B8 00 00` | `MOV AX,0000` |
| `0BBD:0003` | `BB 00 00` | `MOV BX,0000` |
| `0BBD:0006` |  `EB 03`   |  `JMP 0008`   |
| `0BBD:0008` | `05 01 00` | `ADD AX,0001` |
| `0BBD:000B` |    `40`    |   `INC AX`    |

我们发现，`jmp short s ` 所对应的机器码依旧是 **`EB03`**，没有因为因为其所在位置的所在位置，即 `CS：IP` 发生变化 而变化。

`jmp short 标号` 指令 不会因为目的地的地址变化而变化，机器码 `EB 03` 是根据什么修改 `IP`，使其指向目标指令呢？答案是，机器码中的 `03`，即转移的位移。因为 无论如何，`add ax,1` 的指令长度都是 3. 所以结论是：

**`jmp short 标号` ** 所对应的机器码中，并**不包含转移的目的地址**，**而是**包含**相对当前 `IP` 的 转移位移**。

这个位置是汇编编译器根据汇编指令中的“标号”计算出来的，具体方法如下图：

![12_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/12_1.png)

如图，实际上 `jmp short 标号` 指令的功能为：`(IP)=(IP) + 8位位移`。

1. 八 位位移 = **标号处的地址 减去 `jmp` 指令后的第一个字节的地址**；
2. `short` 指明此处的位移为 八 位位移；
3. 八位位移的范围为 `-128 ~ 127` （ $2^{7}$， 由于第一位是符号位）,用**补码**表示；
4. 八位位移由编译程序在编译时算出。



~~- **原码(true form)**：~~

  ~~是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1（0有两种表示：+0和-0），其余位表示数值的大小。~~

~~- **补码**：~~

  ~~正整数的补码是其二进制表示，与原码相同。~~

  ~~求负整数的补码，将其**原码**除符号位外的所有位**取反**（0变1，1变0，符号位为1不变）**后加1**.~~

  

和  `jmp short 标号` 指令相似的还有 `jmp near ptr 标号`，实现段内近转移。

- **`jmp near ptr 标号`**

   `jmp near ptr 标号` 指令的功能为：`(IP)=(IP) + 16位位移`。

  1. 十六位位移 = **标号处的地址 减去 `jmp` 指令后的第一个字节的地址**；
  2. `near ptr` 指明此处的位移为 16 位位移，进行的是段内近转移；
  3. 十六位位移的范围为 `-32768 ~ 32767` （ $2^{15}$， 由于第一位是符号位）,用**补码**表示；
  4. 十六位位移由编译程序在编译时算出。



## 12.4 转移目的地址在指令中的 `jmp` 指令

**`jmp far prt 标号`**  实现的是 **段间转移**，又称为 **远转移**，功能如下：

**`(CS)`** =  标号所在的 **段地址**；

**`(IP)`** =  标号在段中的 **偏移地址**。

**`far ptr`** 指明了指令用标号的段地址和偏移地址修改 `CS` 和 `IP`。

看下面的例子：

```assembly
assume cs:code
code segment
start:	mov ax,0
	mov bx,0
        jmp far ptr s
        DB 256 dup(0)
s:	add ax,1
	inc ax
code ends
end start
```

使用 `debug` 查看其机器指令：

|    地址     |     机器指令     |     汇编指令     |
| :---------: | :--------------: | :--------------: |
| `0B3A:0000` |    `B8 00 00`    |  `MOV AX,0000`   |
| `0B3A:0003` |    `BB 00 00`    |  `MOV BX,0000`   |
| `0B3A:0006` | `EA 0B 01 3A 0B` | `JMP 0B3A:010B`  |
| `0B3A:000B` |     `00 00`      | `ADD [BX+SI],AL` |
| `0B3A:000D` |     `00 00`      | `ADD [BX+SI],AL` |
| `0B3A:000F` |     `00 00`      | `ADD [BX+SI],AL` |
|     ···     |                  |                  |

从上表我们可以看到 伪指令 `DB 256 dup(0)` 被编译器解释为 多个 `ADD [BX+SI],AL` 指令，这不是关键。关键是，我们可以看到，

**`jmp far ptr s` 的机器指令包含了转移的 段地址 和 偏移地址。**



## 12.5 转移地址在寄存器中的 `jmp` 指令

指令格式：**`jmp 16位reg`**

功能：**`(IP) = (16位reg)`**

示例：

```assembly
jmp ax
```

前面 **CS 和 IP** 一节总曾提到过其用法，在此不再赘述。



## 12.6 转移地址在内存中的 `jmp` 指令

两种格式：

1. **`jmp wod ptr 内存单元（段内转移）`**

   功能：**从内存单元地址处开始存放着一个字，是转移目的地偏移地址。**

   内存单元可以用任何一种寻址方式给出。如下例一：

   ```assembly
   mov ax,0123H
   mov ds:[0],ax
   jmp word ptr ds:[0]
   ```

   例二：

   ```assembly
   mov ax,0123H
   mov [bx],ax
   jmp word ptr [bx]
   ```

   执行后，结果都一样，`(IP) = 0123H`.

2. **`jmp dword ptr 内存单元（段内转移）`**

   功能：从内存单元处开始存放着两个字，**高地址处存放着转移目的地址的段地址，低地址处存放偏移地址**。

   **`(CS) = （内存单元地址 + 2）`**

   **`(IP) = （内存单元地址）`**

   如下例一：

   ```assembly
   mov ax,0123H
   mov ds:[0],ax
   mov word ptr ds:[2],0
   jmp dword ptr ds:[0]
   ```

   例二：

   ```assembly
   mov ax,0123H
   mov ds:[bx],ax
   mov word ptr ds:[bx+2],0
   jmp dword ptr ds:[bx]
   ```

   执行后，结果都一样，`CS=0`，`(IP) = 0123H`，`CS:IP` 指向 `0000:0123H`

- 检测题 9.1:

  - （1）

  ```assembly
  assume cs:code
  data segment
  	?		; DB 16 dup(0)
  data ends
  
  code segment
  start:	mov ax,data
  	mov ds,ax
  	mov bx,0
  	jmp word ptr [bx+1]
  code ends
  end start
  ```

  若要使程序中的 `jmp` 指令指向后，`CS:IP` 指向程序的第一条指令，在 `data` 段中应该定义那些数据？

  - 我的答案： 

    如上，定义一个全是零的数据段就可以了。

    首先 `mov ax,data` 和 `mov ds,ax`两条语句将 数据段的地址置为 `ds:0`，`jmp word ptr [bx+1]` 相当于 `jmp word ptr ds:[1]`，此时，`jmp` 值的操作相当于 `(IP) = ds:[1]` ,跳转到第一条指令的位置，即 跳转到 `CS:0` ，也就是说，只要使得 `ds:[1] = (IP) = 0`，就行了。因此，不管偏移地址是多少，都置零就可以了。

  

  - (2)

  ```assembly
  assume cs:code
  data segment
  	dd 12345678H
  data ends
  code segment
  start:	mov ax,data
  		mov ds,ax
  		mov bx,0
  		mov [bx],__		; 0 错了，再来
  		mov [bx+2],__	; ds:[10H] 错了，再来
  		jmp dword ptr ds:[0]
  code ends
  end start
  ```

  补全程序，使得 `jmp` 指令执行后，`CS:IP` 指向程序的第一条指令。

  - 我的答案

    和上一题类似，第一条指令依然是 `CS:0`，至于`jmp dword ptr ds:[0]` ，从 `ds[0]` 开始连续的四个内存单元，高字节存跳转的段地址，低字节存偏移地址，因此，~~可以使得 高字节等于`(CS)`，低字节等于 0，由于 `data` 段中只定义了一个双字，占 4 个字节，不超过 16 字节，因此，`data` 段长度仍为 16. 我们可以据此算出 `(CS) = ds:[10H]`.~~
    
    由于这两条未完成的指令不含有 `X ptr` 标记，所以这两空不能填内存单元，`mov` 指令也没有限定操作数字长，因此只能填寄存器。但是本程序可供使用的寄存器，目测只有 `ax,bx,ds,cs` ，`(ds)+1=(cs)`，除此之外似乎并没有其他线索。而且，以我的脑子，目前无论怎么拼凑，总是会有 `mov 内存单元,内存单元` 这种非法的形式存在。
  
  - [x] 综上，留待后续。
  
  百度看到了博客园一位博主的答案，他的答案是 
  
    ```assembly
    mov [bx],offset start	;偏移地址
  mov [bx+2],word ptr cs	;取出代码段地址，mov [bx+2],cs 也可以
    ```

    看到 `word ptr` 的位置，不禁感叹：这也可以？然而，可惜的是，两个指令都报错了：
  
    ```
    error : Operand must have size.
    error : Illegal use of register
    ```
  
  第一个很明显，需要 `X ptr` 操作符，而且，既然是第一条指令，很明显不就是 `IP = 0`?
  
  第二个就很值得探究了。首先我第一时间想到的是 `X ptr` 操作符不是只能跟在指令后，第一个操作数之前吗？居然还可以放在第二个操作数之前？
  
    经过查看前面 `mov` 指令和 `X ptr` 操作符的相关知识，经过试验，发现可以用 `mov` 将立即数送入内存单元，当然，这必须要用到 `X ptr` 操作符来指明立即数的大小。于是就有了我的第一种答案，如下：
  
    ```assembly
    mov [bx],WORD ptr 10H
    mov [bx+2],AX
    ```
  
    原因是：`(CS):0 = (DS:10)`，也可以说 `(CS) = (DS)+1`.
  
    查看 `mov` 指令的关于段寄存器的格式发现了有 **`mov [...],sreg`** 格式，也就是说，**将寄存器的内容直接送入内存单元段其实是可以的**！
  
    经过试验，发现确实可以，那为什么这位博主的不能通过编译呢？经过试验发现，原来是这位博主多此一举，在一个 16 位寄存器前还加了一个 `word ptr` 操作符，去掉这个操作符，程序就是没问题。如此，得到了更简单的第二种答案：
  
    ```assembly
    mov [bx],word ptr 0
    mov [bx+2],cs
    ```
  
    当然，既然可以把寄存器直接送入内存单元，那么也可以这样：
  
    ```assembly
    mov [bx],word ptr 10H
    mov [bx+2],ds
    ```
  
    以上就是本题的答案了。在验证 **`mov [...],sreg`**  过程中，发现 `mov [0],ds` 指令会报错，这是前面已经提到的原因：编译器会把 `[0]` 视为立即数 `0`，因此 `[bx]` 就可以了。
  
    **总结**：在思考本题时，出现了两个误区。一个 `X ptr` 操作符的用法，另一个 `mov` 指令的格式。这两个其实可以说是编译器与语法的问题，刚才那位博主之所以可以那样写，可能时因为他使用的编译器跟我的不一样罢了。但是这次做题暴露出两个问题：
  
    1. 思维定式很严重，迷信书本，不敢质疑，懒于探索。就比如操作符的问题，如果当时肯去尝试，问题早就可以解决了。就算没解决，也可以通过大量的资料一探究竟。、
    2. 基础知识不固定，学后忘前。这才是最严重的问题，且不说这本丝毫没有告诉我们关于 `X ptr` 的另一种格式。但是 **`mov [...],sreg`** 这是前面实打实总结过的内容，就要不知道 `X ptr` 也应该可以用此种方式解决问题才对。
  
  好好反思一下吧。
  
  
  
  - (3)  用 `debug` 查看内存，结果如下：
  
    ```
    2000:1000 BE 00 06 00 00 00 ...
    ```
  
    则此时，CPU 执行指令：
  
    ```assembly
    mov ax,2000H
    mov es,ax
    jmp dword ptr es:[1000H]
    ```
  
    后，`(CS)=?`，`(IP)=?`
  
  - 我的答案：
  
    `(CS)=0006H`，`(IP)=00BEH`



## 12.7 `jcxz` 指令

**`jcxz`** 指令为有条件转移指令，**所有的条件转移指令都是短转移**，在对应的机器码中包含转移指令的**位移**，而不是目的地址。对 `IP` 的修改范围都为 **`-128 ~ 127`**.

- 指令格式：

  **`jcxz 标号`** 	；如果（**`(cx)=0`**，**转移到标号处执行**。） 

- 操作：

  当 **`(cx)=0`** 时，**`(IP)=(IP)+8位位移`**

  8 位位移 = 标号处的地址 - `jcxz ` 指令后的第一个字节的地址；

  8 位位移 的f范围为：**`-128 ~ 127`**，用 **补码** 表示；

  8 位位移 由编译程序在编译时算出。

  当 `(cx)` 不等于 0 时，什么也不做（程序继续向下执行）。

从 **`jcxz`** 的功能中可以看出，**`jcxz 标号`** 的功能相当于：

```c
if(cx==0) jmp short 标号;
```



- 测检查点 9.2：补全程序，利用 `jcxz` 指令，实现在内存 `2000H` 段中查找第一个值为 0 的字节，找到后，将其偏移地址存储在 `dx` 中。 答案如下：

```assembly
assume cs:code

code segment
start:	mov ax,2000H
		mov ds,ax
		mov bx,0

s:		mov cx,[bx]		; #1
		mov ch,0		; #2	
		jcxz ok			; #3
		inc bx			; #4
		jmp short s
ok:		mov dx,bx
		mov ax,4c00h
		int 21h

code ends
end start
```

刚开始将 `#4` 步与 `#3` 步位置弄反了，造成结果的差之毫厘。。。

结果验证如下图：

![12_2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/12_2.png)



## 12.8 `loop` 指令

**`loop`** 指令为循环指令，所有的循环指令都是 **短转移**，在对应的机器码中包含转移指令的**位移**，而不是目的地址。对 `IP` 的修改范围都为 **`-128 ~ 127`**.

- 指令格式：

  **`loop 标号`** 	；`(cx)=(cx)-1`，如果（`(cx)` 不等于 0，转移到标号处执行。） 

- 操作：

  1. `(cx)=(cx)-1` ；
2. 当  `(cx)` **不等于 0** 时，**`(IP)=(IP)+8位位移`** 。

8 位位移 = 标号处的地址 - `loop` 指令后的第一个字节的地址；

8 位位移 的f范围为：**`-128 ~ 127`**，用 **补码** 表示；

8 位位移 由编译程序在编译时算出。

  当 `(cx)=0`  时，什么也不做（程序继续向下执行）。

从 **`loop`** 的功能中可以看出，**`loop 标号`** 的功能相当于：

```c
(cx)--;
if((cx)!=0) jmp short 标号;
```



- 检测点 9.3

  测检查点 9.2：补全程序，利用 `loop` 指令，实现在内存 `2000H` 段中查找第一个值为 0 的字节，找到后，将其偏移地址存储在 `dx` 中。 答案如下：

  ```assembly
  assume cs:code
  code segment
  start:	mov ax,2000h
  		mov ds,ax
  		mov bx,0
  
  s:		mov cl,[bx]
  		mov ch,0
  		ADD CX,1	; ___
  		inc bx
  		loop s
  
  ok:		dec bx		; dec 指令的功能和 inc 相反，dec bx 进行的操作为： (bx) = (bx)-1
  		mov dx,bx
  
  		mov ax,4c00h
  		int 21h
  
  code ends
  end start
  ```

  注意 **`loop`** 指令是**先 执行 `(CX)=(CX)-1`**，然后再根据 `(CX)` 决定是否跳转。`add cx,1` 是因此若找到了为 `00H` 的单元，即 `CX=0`，先执行`(CX)=(CX)-1`，会使得  `CX=FFFFH` ，而不是零，不会停止循环。



这章最后再来分析一个程序：

```assembly
assume cs:code
code segment
start:	jmp short s
		db 128 dup(0)
s:		mov ax,0ffffh
code ends
end start
```

`jmp short s` 的转移范围是 `-128 ~ 128` ，`IP` 最多向后移动 127 个字节。

注意，`jmp 2000:1000` 这种存在于 `debug` 程序中形式的指令汇编编译器是不认识的，混入编译器后可能会报错。



## 实验 8 分析一个奇怪的程序

分析下面的程序，在运行前思考：这个程序可以正确返回吗?

运行后再思考：为什么是这种结果?

通过这个程序加深对相关内容的理解。

```assembly
assume cs:code
code segment

		mov ax,4c00h		; #10
		int 21h				; #11

start:	mov ax,0			; #12
s:		nop
		nop

		mov di,offset s		; #1
		mov si,offset s2	; #2
		mov ax,cs:[si]		; #3
		mov cs:[di],ax		; #4

s0:		jmp short s			; #5

s1:		mov ax,0			; #6
		int 21h				; #7
		mov ax,0			; #8

s2:		jmp short s1		; #9
		nop

code ends
end start
```

- 运行前思考： 

  由于程序入口在 `start` 所以可以顺利运行一段；

  `#1` 到 `#4` 的目的是为了把 `#9` 处的指令复制到 `s` 到，由于 `#9` 处的指令占两个字节，而 `s` 处开始的两个 `nop` 刚好占两个字节，因此，可以复制成功；

  接下来跳转到刚刚复制的两个指令处,执行 `#9` 处的指令，跳转到 `s1`;

  最后面这一段从 `#6` 到 `#8` 处的指令，不太理解，尤其是 `#6` 和 `#8` 两处两个相同的指令，还有 `start` 标号前的标准返回格式有没有存在的意义，想不出来。

  我的猜想是可以正常运行，但是可能不会正常返回，结果到底如何，

  交给实验把。

- 运行的情况：

  最终结果是猜对了，不过，有几步还是想错了。

- 运行后再思考：

  **`#1` 到 `#4` 是复制了 `#9` 的机器指令 `EBF6`，而不是 `jmp short s1`** ，这是什么意思呢？因为还是犯了前面做题暴露出来的问题，没有认真巩固好基础知识；具体到这条指令理解的偏差是 ：

  > `jmp short 标号`  所对应的机器码中，并**不包含转移的目的地址**，**而是**包含相对当前 `IP` 的 转移**位移**。

  因此，复制的机器指令实际上只包含 **相对当前 `IP` 的转移位移**。

  复制的 `jmp` 指令执行的操作是，向前跳转 8 个字节的位移。所以`#6`和 `#8`那令人迷惑两个 `mov` 指令的目的也就很明显了，为了凑齐 8 个字节，好与 `#10` 到 `#12` 三个指令字节数相同。

  因此机器指令 **`EBF6`** 执行后成功跳转到了 `CS:0` ，即 `#10` 的位置。虽然执行了 `#10` 和 `#11` ，程序并未停止。这应该是因为 伪指令 **`end`** 的原因。

  

## 实验 9 根据材料编程

编程:在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串`'welcome to
masm!'`。
编程所需的知识通过阅读、分析下面的材料获得。

`80x25`彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构:
内存地址空间中，`B8000H~BFFFFH` 共`32K`B的空间，为`80×25`彩色字符模式的显
示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。

在`80x25`彩色字符模式下，显示器可以显示25行，每行80个字符，每个字符可以有
`256` 种属性(背景色、前景色、闪烁、高亮等组合信息)。

这样，一个字符在显示缓冲区中就要占两个字节，分别存放字符的 `ASCII` 码和属性。
`80×25`模式下，一屏的内容在显示缓冲区中共占 `4000` 个字节。

显示缓冲区分为8页，每页 `4KB(~4000B)`，显示器可以显示任意一页的内容。一般
情况下，显示第О页的内容。也就是说通常情况下，`B8000H~B8F9FH` 中的 `4000` 个字节
的内容将出现在显示器上。

在一页显示缓冲区中:

偏移 `000~09F`对应显示器上的第1行(80个字符占160个字节);
偏移 `OA0~13F` 对应显示器上的第2行;
偏移 `140~1DF` 对应显示器上的第3行;

依此类推，可知，偏移 `FOO~F9F` 对应显示器上的第25行。

在一行中，一个字符占两个字节的存储空间(一个字)，低位字节存储字符的`ASCII`
码，高位字节存储字符的属性。一行共有80个字符，占160个字节。

即在一行中:

`00~01` 单元对应显示器上的第1列;
`02~03` 单元对应显示器上的第2列;
`04~05` 单元对应显示器上的第3列;

依此类推，可知，`9E～9F`单元对应显示器上的第80列。
例：在显示器的0行О列显示黑低绿色的字符串`'ABCDEF'`
(`'A'` 的 `ASCII` 码值为 `41H`，`02H` 表示黑底绿色)

显示缓冲区里的内容为:

```
          00 01 02 03 04 05 06 07 08 09 0A 0B ... OE OF
B800:0000 41 02 42 02 43 02 44 02 45 02 46 02... .. ..
	:
	:
B800:00A0 .. .. .. .. .. .. .. .... .. .. .... .. .. ..
```

可以看出，在显示缓冲区中，偶地址存放字符，奇地址存放字符的颜色属性。

一个在屏幕上显示的字符，具有前景(字符色)和背景(底色)两种颜色，字符还可以以
高亮度和闪烁的方式显示。前景色、背景色、闪烁、高亮等信息被记录在属性字节中。

属性字节的格式: 

| 属性字节 |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   含义   |  BL  |  R   |  G   |  B   |  I   |  R   |  G   |  B   |
|          | 闪烁 | 背景 | 背景 | 背景 | 高亮 | 前景 | 前景 | 前景 |

R：红色
G：绿色
B：蓝色

可以按位设置属性字节，从而配出各种不同的前景色和背景色。

比如:

红底绿字，属性字节为：`01000010B`;
红底闪烁绿字，属性字节为：`11000010B`;
红底高亮绿字，属性字节为：`01001010B`;
黑底白字，属性字节为：`00000111B`;
白底蓝字，属性字节为：`01110001B`。

例:在显示器的0行О列显示红底高亮闪烁绿色的字符串 `'ABCDEF'`
(红底高亮闪烁绿色，属性字节为：`11001010B`，`CAH`)
显示缓冲区里的内容为：

```
          00 01 02 03 04 05 06 07 08 09 0A 0B ... 9E 9F
B800:0000 41 CA 42 CA 43 CA 44 CA 45 CA 46 CA ... .. ..
	:
	:
B800:00AO .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
```

注意，闪烁的效果必须在全屏DOS方式下才能看到。

- 我的答案：

```assembly
assume cs:code
data segment
	db 'welcome to masm!'
data ends

code segment
start:	mov ax,data
	MOV DS,ax
	MOV CX,16	; 16 个字符
	
	MOV AX,0b800h
	;MOV AX,2000h
	MOV ES,ax
	
	MOV bx,0
	MOV SI,0
	
s:	MOV Al,[SI]
	MOV ES:[bx+7a0h],AL	;7a0h （13*160）第十三行，
						; 从第 32（20h）列开始，哪里不对劲了？
	MOV BYTE ptr ES:[bx+7a1h],71h		; 2,24H,71H
	ADD bx,2
	INC SI
	LOOP s

	MOV AX,4C00h
	INT 21h

code ends
end start
```

运行是可以的，虽然效果没那么完美，调样式的细活，我干不了，就这样吧。。。附上一般般效果图。

![ex9](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/ex9.png)



# 13. `CALL` 和 `RET` 指令

`cal`l 和 `ret` 指令都是转移指令，它们都修改 `IP`，或同时修改 `CS` 和 `IP`。它们经常被共
同用来实现子程序的设计。

## 13.1 `ret` 和 `retf`

**`ret`** 指令用栈中的数据，修改  **`IP`** 的内容，从而实现 **近转移**；

**`retf`** 指令用栈中的数据，修改 **`CS` 和 `IP`** 的内容，从而实现 **远转移**。

CPU 执行 **`ret` ** 指令时，进行下面两步操作:

(1) `(IP) = ((ss)*16 + (sp))`
(2) `(sp) = (sp)+2`

CPU 执行 **`retf`** 指令时，进行下面4步操作:

(1) `(IP) = ((ss)*16+(sp))`
(2) `(sp) = (sp)+2`
(3) `(CS) = ((ss)*16+(sp))`
(4) `(sp) = (sp)+2`

可以看出，如果我们用汇编语法来解释 `ret` 和 `retf` 指令，则:

CPU执行 `ret` 指令时，相当于进行:
```assembly
pop IP
```

CPU执行 `retf` 指令时，相当于进行:
```assembly
pop IP
pop CS
```

例：下面的程序中，`ret` 指令执行后，`(IP)`=0，**`CS:IP` 指向代码段的第一条指令**。

```assembly
assume cs:code
stack segment
	db 16 dup (0)
stack ends

code segment
        mov ax,4c00h
        int 21h
	
start:	mov ax,stack
        mov ss,ax
    	mov sp,16
		mov ax,0
		push ax
	    mov bx,0	; 据试验，发现有或没有这条指令都
	    			; 能正常返回，所以这条指令段目的是？？？
    	ret
code ends
end start
```

下面的程序中，`retf` 指令执行后，**`CS:IP` 指向代码段的第一条指令**。
```assembly
assume cs:code
stack segment
    db 16 dup (0)
stack ends
code segment
        mov ax, 4cooh
        int 21h
start:	mov ax,stack
        mov ss,ax
        mov sp,16
        mov ax,0
        push cs			; 段寄存器可以直接被 push
        push ax
        mov bx,0
        retf
code ends
end start
```



- 检测点 10.1

  补全程序，实现从内存 `1000:0000` 处开始执行指令。
```assembly
assume cs:code
stack segment
    db 16 dup (0)
stack ends

code segment
start:	mov ax,stack
        mov ss,ax
        mov sp,16
        mov ax,0		;____	pop IP
        push ax
        mov ax,1000h	;____	pop CS
        push ax
        retf
code ends
end start
```



## 13.2 `call` 指令

CPU执行call指令时，进行两步操作:

(1) 将当前的 **`IP`** 或 **`CS`和 `IP`** 压入栈中;
(2) 转移。

`call` 指令**不能实现短转移**，除此之外，`call` 指令实现转移的方法和 `jmp` 指令的原理相
同。



### 13.2.1 依据位移进行转移的 `call` 指令

**`call 标号`**  (将当前的 `IP` 压栈后，转到标号处执行指令)

CPU 执行此种格式的 `call` 指令时，进行如下的操作:
(1) `(sp) = (sp) - 2`
    `((ss)*16 + (sp)) = (IP)`
(2) `(IP)=(IP) + 16位位移`。

> 16 位位移 = 标号处的地址 - `call` 指令后的第一个字节的地址;
> 16 位位移的范围为 `-32768~32767`，用补码表示;
> 16 位位移由编译程序在编译时算出。

从上面的描述中，可以看出，如果我们用汇编语法来解释此种格式的 `call` 指令，则:
CPU 执行 `call 标号` 时，相当于进行:

```assembly
push IP
jmp near ptr 标号
```



- 检测点 10.2

  下面的程序执行后，`ax` 中的数值为多少？

  ```assembly
  内存地址		机器码		汇编指令
  1000:0		b8 00 00	mov ax,0
  1000:3		e8 01 00	call s
  1000:6		40			inc ax
  1000:7		58			s:pop ax
  ```

- 作答：

  我猜是 3 ，但是当我试验过后发现是 **6** ，为啥？还是因为前面的基础知识没巩固牢靠，具体原因是：

  > **`IP` 先自动增加然后指令再执行！！！**

  在执行指令时，`IP` 寄存器的值总是先增加，然后再执行指令。也就是说，

  **在执行 `call s` 指令之前，`IP` 的值已经不是当前指令 `call s` 的第一个字节的偏移地址了，而是下一个指令的第一个字节的偏移地址**。

  在此谨记：

  指令执行过程中，

  **`IP` 先自动增加然后指令再执行！**

  **`IP` 先自动增加然后指令再执行！！**

  **`IP` 先自动增加然后指令再执行！！！**



### 13.2.2 转移目的地地址在指令中的 `call` 指令

前面讲的 `call` 指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前 `IP`
的转移位移。

**`call far ptr 标号`** 实现的是段间转移。

CPU 执行此种格式的call指令时，进行如下的操作。

(1) `(sp) = (sp)-2`
    `((ss)*16 + (sp) = (CS)`
    `(sp) = (sp)-2`
    `((ss)*16 + (sp)) = (IP)`
(2) `(CS) = 标号所在段的`**段地址**
	 `(IP) = 标号在段中的`**偏移地址**

从上面的描述中可以看出，如果我们用汇编语法来解释此种格式的 `call` 指令，则:
CPU执行 **`call far ptr 标号`**  时，相当于进行:

```assembly
push CS
push IP
jmp far ptr标号
```



- 检测点 10.3

  下面的程序执行后，`ax` 中的数值为多少?

  ```assembly
  内存地址			机器码			汇编指令
  1000:0			b8 00 00		mov ax,0
  1000:3		9A 09 00 00 10		call far ptr s
  1000:8			40				inc ax
  1000:9			58			  s:pop ax
  								add ax,ax
  								pop bx
  								add ax,bx
  ```

  - 作答：

    吸取了上次的教训，这回谨慎作答。在此 `call` 指令首先 "`push cs`"，再 "`pop ip`" ，因此栈中的两个元素，从栈顶到栈底依次为 `0008h` 和 `1000h`，

    由于 指令执行时，`IP` 先自动增加当前指令 `call far ptr s` 的长度（占用字节数）使得 `(IP)` 等于 下一个指令的第一个字节处的偏移地址，再去执行当前指令 `call far ptr s` ，所以栈顶元素是 8 而不是 3.

    继续往下，跳转到 `s` 标号处，

    `pop ax` 执行，`(ax)=0008h`，

    `add ax,ax` 执行，`(ax)=0010h`，

    `pop bx` 执行，`(ax)=1000h`，

    `add ax,bx` 执行，`(ax)=1010h`.

  - 验证：没有使得 `CS = 1000H` ，但是结果同样为 `(cs)+10H` . 因此这次猜对了。



### 13.2.3 转移地址在寄存器中的 `call` 指令

- 指令格式：**`call 16位reg`**

- 功能:
  `(sp) = (sp)-2`
  `((ss)*16 + (sp) = (IP)`
  `(IP) = (16位reg)`

- 用汇编语法来解释此种格式的 `call` 指令，CPU 执行 `call 16位reg` 时，相当于
  进行:

  ```assembly
  push IP
  jmp 16位reg
  ```

- 检测点 10.4

  下面的程序执行后，ax中的数值为多少？

  ```assembly
  内存地址			机器码			汇编指令
  1000:0			b8 06 00		mov ax,6
  1000:3			ff d0			call ax
  1000:5			40				inc ax
  1000:6						  	mov bp,sp
  								add ax,[bp]		; 5 + 6
  ```

  - 作答：`(ax)=000bh`
  - 注意，别忘了 **在未指定段寄存器时，`[...]` 中只要存在 寄存器`bp`，其段寄存器就默认为 栈寄存器 `SS`**.



### 13.2.4 转移地址在内存中的 `call` 指令

转移地址在 **内存中** 的call 指令有两种格式。

(1) **`call word ptr 内存单元地址`**

用汇编语法来解释此种格式的call指令，则:
CPU 执行 "**`call word ptr 内存单元地址`**" 时，相当于进行:
```assembly
push IP
jmp word ptr 内存单元地址
```
比如，下面的指令:
```assembly
mov sp,10h
mov ax,0123h
mov ds:[0],ax
call word ptr ds:[0]
```

执行后，`(IP) = 0123H`，`(sp) = 0EH` (入栈后，`10H-2`)



(2) 用汇编语法来解释此种格式的call指令，则:
CPU执行 "**`call dword ptr 内存单元地址`**" 时，相当于进行:

```assembly
push cs
push IP
jmp dword ptr 内存单元地址
```
比如，下面的指令:
```assembly
mov sp,10h
mov ax,0123h
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
```
执行后，`(CS)=0` ，`(IP)=0123H`，`(sp)=0CH`.



- 检测点 10.5

  (1) 下面的程序执行后，`ax` 中的数值为多少？（注意：用 `call` 指令的原理来分析，不要在 `Debug` 中单步跟踪来验证你的结论。对于此程序，在 `Debug` 中单步跟踪的结果，不能代表CPU的实际执行结果。）

  ```assembly
  assume cs:code
  stack segment
  	dw 8 dup (0)
  stack ends
  code segment
  start:	mov ax,stack
          mov ss, ax
          mov sp,16
          mov ds,ax
          mov ax,0
          call word ptr ds:[0EH]
          inc ax		; #1
          inc ax		; #2
          inc ax		; #3
          
          mov ax, 4c00h
          int 21h
  code ends
  end start
  ```
  
  - 审题时的认真思考：
  
    话说，只要结尾有 `mov ax, 4c00h` 返回指令，再问 “`ax` 中的数值为多少？” 有什么意义，这个程序没有什么理由不能正常返回吧？那么我只能认为这个问题问的是，“**程序返回前**”，`ax` 中的数值为多少？
  
  - 作答：
  
    关键指令 `call word ptr ds:[0EH]` 执行过程的分析：
  
    首先 `IP` 自动增加，所以 `IP` 的值为 `call` 指令后第一条指令的首字节位置的偏移地址，
  
    然后 "`push IP`" ，栈顶元素就是当前，刚刚分析过的 `IP` 的值了；
  
    最后 跳转到 `ds:[0EH]` , 这个地址正是栈顶元素的位置，所以跳转到 `#1`，第一个 `inc ax` 的位置，所以我猜，返回前，`(ax)=3`.
  
  - 验证：
  
    题目说，不能用 `debug` 分析，但是不能靠猜啊，于是我还是用 `debug` 验证了一下，结果，也是 3。。其他，以后有（bu）时（ke）间（neng）再说了。
  
    
  
  (2) 下面的程序执行后，`ax` 和 `bx` 中的数值为多少?
  
  ```assembly
  assume cs:code
  data segment
  dw 8 dup (0)
  data ends
  code segment
  start:	mov ax,data
          mov ss,ax
          mov sp,16
          mov word ptr ss:[0],offset s	; #1
          mov ss:[2],cs					; #2
          call dword ptr ss:[0]			; #3
          nop								; #4
  s:		mov ax,offset s				  	; #5
          sub ax,ss:[OcH]			  		; #6
          mov bx,cs					  	; #7
          sub bx,ss:[0eH]				  	; #8
          
          mov ax,4c00h
          int 21h
  code ends
  end start
  ```
  
  这题我觉得和上题一样，题干少了几个字。
  
  - 分析：
  
    `#1` 和 `#2` 将  `s`标号处的偏移地址 和 `(cs)` 分别复制到 栈空间的前两个字节；
  
    `#3` 先后将当前 `(cs)` 和 `(ip)`（注意是当前`(ip)`，而不是当前指令的 `(ip)`，再次强调，执行指令过程中，`ip` 的增长总是先于当前指令执行，所以当前`cs:ip` 实际上指向 `#5` 处的指令） 先后压入栈中，
  
    由于当前栈为空栈，所以，当前`(cs)= ss:[0eh]` , 当前 `(ip)= ss:[0ch]`
  
    再跳转到 `ss:[0]`，也就是前两步 `#1` 和 `2` 设置的，所以，`ss:[0]`  实质上等于 `s` 标号处的段地址和偏移地址（`s` 标号处的 `cs:ip`）。因此 `#3` 的 `call` 指令用作时跳转到 `s` 标号处；
  
    `#5` 将 `s` 标号处的偏移地址赋予 `ax`，
  
    `#6` 将 `s` 标号处的偏移地址与 `#4` 处的偏移地址之差送入 `ax` 中，由于前面提到过 `nop` 指令占一个字节，所以 `(ax)=1`.
  
    `#7` 和 `#8` 与之前两步类似，`(bx)` 的结果是，`s` 标号处的段地址 与 `#4` 处的段地址之差，前后无变化，所以是 0.
  
  - 作答：
  
    稍作思考，认为 `(ax)=1`，`(bx)=0`
  
  - 验证：
  
    结果与猜想一致。
  
  - 知识回顾：
  
    这里的两个题目都用到了栈，和前所总结的一样，栈其实是一个相对独立的空间，与之相关的操作指令目前学过的只有 `push` 和 `pop` 。
  
    对于一段栈空间，栈顶到这段栈空间满栈位置之间的空间来说，任何除 `push` 和 `pop` 之外的读写指令对其操作都不会影响栈结构的使用，因为 `push` 指令会覆盖这段空间的内容，而 `pop` 指令不操作这段空间；
  
    但是，对于栈顶到栈底这段空间来说， `push` 和 `pop` 之外的读写指令会对栈的使用有很大的影响，例如，使用 `mov` 指令改变栈顶的值，`pop` 指令送出的数据就可能不是上一次 `push` 指令压入栈的数据了。
  
    

## 13.3 `call` 和 `ret` 指令的配合使用

- 问题 10.1

  下面程序返回前，`bx` 中的值是多少?
  ```assembly
  assume cs:code
  code segment
  start:	mov ax,1
  		mov cx,3
  		call s
  		mov bx,ax	; (bx)=?
  		mov ax,4c00h
  		int 21h
  s:		add ax,ax
  		loop s
  		ret
  code ends
  end start
  ```
  思考后看分析。

  - 作答：

    `(bx)=8`

  - 分析：

    如上程序，`call` 和 `ret` 指令的配合使用，我们

    可以用 `call`指令先将下一条指令的偏移地址压入栈中，然后去运行一个具有一定功能的程序（此处为 $2^{n}$）,我们称之为 **子程序**，

    然后再用 `ret` 指令将栈中保存的偏移地址弹出到 `IP` 寄存器中，返回继续执行子程序之前 `call` 指令的下一条指令。

- 结论：

  因此，我们可以用 `call` 和 `ret` 指令来实现子程序的框架。如下：

  ```assembly
  assume cs:code
  code segment
  main:	;
  		;			; 调用子程序sub1
  		call sub1
  		;
  		;
  		mov ax,4c00h
  		int 21h
  
  sub1:	;			; 子程序sub1开始
  		;
  		call sub2	; 调用子程序sub2
  		;
  		;
  		ret			; 子程序返回
  
  sub2:	;			; 子程序sub2开始
  		;
  		;
  		ret			; 子程序返回
  code ends
  end main
  ```



## 13.4 `mul` 指令

**`mul`** 指令就是 **乘法指令**。使用时需要注意以下几点：

**两个相乘的数 要么都是 8 位，要么都是 16 位。**

| 乘数1               | 乘数2                      | 积                        |
| ------------------- | -------------------------- | ------------------------- |
| 8 位，存于 `AL` 中  | 8 位 `reg` 或 内存字节单元 | 存于 `AX` 中              |
| 16 位，存于 `AX` 中 | 16 位 `reg` 或 内存字单元  | `DX` 存 高位，`AX` 存低位 |

- 格式如下：

  ```assembly
  mul reg
  mul 内存单元
  ```

- 内存单元可以用不同的寻址方式给出，示例如下：

  ```assembly
  mul byte prt ds:[0]		; (ax) = (al)*((ds)*16+0)
  mul word prt [bx+si+8]	; (ax) = (ax)*((ds)*16+(bx)+(si)+8) 结果的低 16位
  						; (dx) = (ax)*((ds)*16+(bx)+(si)+8) 结果的高16位
  ```

- 实例：

  1. 计算 `100*10`

  ```assembly
  ; 100 和 10 小于 255，可以做 8 位乘法
  mov al,100
  mov bl,10
  mul bl
  ```

  结果：`(ax)=1000(03E8H)`

  2. 计算 `100*1000`

  ```assembly
  ; 100 小于 255，1000 大于 255，所以必须做 16 乘法
  mov ax,100
  mov bx,1000
  mul bx
  ```

  结果：`(ax)=4240H` ，`(dx)=000FH`，（`F4240H=1000000`）

  

## 13.5 参数和结果传递的问题

下面以一个例子来讨论一下 子程序的 参数和返回值传递的问题。

- 问题：

  设计一个子程序，可以根据提供的 `N`，来计算 `N` 的 3 次方。

- 分析：

  1. 应将参数放在什么地方？

     可以将参数存放在寄存器 `bx` 中；

  2. 计算得到的数值，存储在什么地方？

     可将结果放在 `dx` 和 `ax` 中；

子程序如下：

```assembly
;说明:计算N的3次方
;参数:(bx)=N
;结果:(dx:ax)=N^3
cube:	mov ax,bx
        mul bx
        mul bx
        ret
```



- 编程，计算data段中第一组数据的3次方，结果保存在后面一组 `dword` 单元中。

```assembly
assume cs:code
data segment
  dw 1,2,3,4,5,6,7,8
  dd 0,0,0,0,0,0,0,0
data ends

code segment
start:  mov ax,data
        mov ds,ax
        mov si,0    ; ds:si指向第一组word单元
        mov di,16   ; ds:di指向第二组dword单元
        mov cx,8
s:      mov bx,[si]
        call cube
        mov [di],ax
        mov [di].2,dx
        add si,2    ; ds:si指向下一个word单元
        add di,4    ; ds:di指向下一个dword单元
        loop s
        mov ax,4c00h
        int 21h
cube:   mov ax,bx
        mul bx
        mul bx
        ret
code ends
end start
```



## 13.6 批量数据的传递

对于上一小节的程序，子程序 `cube` 只有一个参数，可以存放于 寄存器 `bx` 中，如果有多个参数，以致寄存器不够用咋办？不只是参数，返回值也有这样的问题。

答案是，在这种时候，我们将批量数据**放到内存中**，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。

下面看一个例子，设计一个子程序，功能:将一个全是字母的字符串转化为大写。

这个子程序需要知道两件事，字符串的内容和字符串的长度。因为字符串中的字母可
能很多，所以不便将整个字符串中的所有字母都直接传递给子程序。但是，可以将字符串
在内存中的**首地址**放在寄存器中传递给子程序。因为子程序中要用到循环，我们可以用
`loop` 指令，而循环的次数恰恰就是字符串的长度。出于方便的考虑，可以将字符串的长度放到`cx`中。

- 子程序：

```assembly
capital: and byte ptr [si],11011111b ;将ds:si所指单元中的字母转化为大写
		 inc si						 ; ds:si指向下一个单元
		 loop capital
		 ret
```

- 编程，将data段中的字符串转化为大写。

```assembly
assume cs:code
data segment
	db 'conversation'
data ends
code segment
start:	mov ax,data
		mov ds,ax	
		mov si,0			; ds:si指向字符串(批量数据)所在空间的首地址
		mov cx,12			; cx存放字符串的长度
		call capital
		mov ax, 4c00h
		int 21h
capital:and byte ptr [si],11011111b
		inc si
		loop capital
		ret
code ends
end start
```

注意，除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。关于这种
技术请参看附注4。



## 13.7 寄存器冲突问题

设计一个子程序，功能:将一个全是字母，以 0 结尾的字符串，转化为大写。
程序要处理的字符串以 0 作为结尾符，这个字符串可以如下定义:

```assembly
db 'conversation' ,0
```

大小写转换的子程序段可以如下：

```assembly
capital:mov cl,[si]
		mov ch,0
		jcxz ok			; 如果 (cx)=0，结束；如果不是，处理
		and byte ptr [si],11011111b	; 将 ds:di 所指向单元的字母转换为大写
		inc si			; ds:si 指向下一个单元
		jmp short capital
ok:		ret
```

`data` 段中字符串的定义：

```assembly
data segment
	db 'word' , 0
	db 'unix' , 0
	db 'wind' , 0
	db 'good' , 0
data ends
```

代码段中的相关程序如下：

```assembly
mov ax,data
mov ds,ax
mov si,0
call capital
```

可以看到，所有字符串的长度都是5(算上结尾符0)，使用循环，重复调用子程序
`capital`，完成对4个字符串的处理。完整的程序如下。

```assembly
assume cs:code
data segment
	db 'word' , 0
	db 'unix' , 0
	db 'wind' , 0
	db 'good' , 0
data ends

code segment
start:	mov ax, data
		mov ds,ax
		mov bx,0
		mov cx,4
s:		mov si,bx
		call capital
		add bx,5
		loop s
		mov ax, 4c00h
		int 21h
capital:mov cl,[si]
		mov ch,0
		jcxz ok
		and byte ptr [si],11011111b
		inc si
		jmp short capital
ok:		ret
code ends
end start
```

那么问题来了，

- 问题 10.2

  这个程序思路完全正确，但还是差点意思，找出来。

- 以下抄书

  问题在于寄存器 `cx` 的使用，主程序中 `cx` 记录了循环的次数；子程序中也使用了 `cx`，这就造成了寄存器冲突。那么，如何解决这个问题呢？如下：

  在子程序的开始**将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复**。可以**用栈来保存寄存器中的内容**。
  
  

以后，我们编写子程序的标准框架如下:

---

子程序开始:	子程序中使用的寄存器入栈
						子程序内容
						子程序中使用的寄存器出栈
						返回(`ret`、`retf`)

---



我们改进一下子程序`capital`的设计:
```assembly
capital:push cx
		push si
		mov cl,[si]
change:	mov ch,0
        jcxz ok
        and byte ptr [si],11011111b
        inc si
        jmp short change
ok:		pop si
        pop cx
        ret
```
要注意寄存器入**栈**和出栈的顺序。



## 实验 10 编写子程序

- [ ] 完成与否



## 课程设计 1

在整个课程中，我们一共有两个课程设计，编写两个比较综合的程序，这是第一个。

- 任务：

  将实验 7 中的 Power idea 公司的数据按照 下表 的格式在屏幕上显示出来。

  | 年份 | 收入（千美元） | 雇员（人） | 人均收入（美元） |
  | :--: | :------------: | :--------: | :--------------: |
  | 1975 |       16       |     3      |        5         |
  | 1976 |       22       |     7      |        3         |
  | 1977 |      382       |     9      |        42        |
  | 1978 |      1356      |     13     |       154        |
  | 1979 |      2396      |     28     |        85        |
  | 1980 |      8000      |     38     |       215        |
  | 1981 |     16000      |    133     |       123        |
  | 1982 |     24486      |    225     |       111        |
  | 1983 |     56965      |    4126    |        15        |
  | 1984 |     97479      |    728     |       125        |
  | 1985 |     140417     |    1001    |       146        |
  | 1986 |     197514     |    1442    |       136        |
  | 1987 |     345980     |    2258    |       153        |
  | 1988 |     590827     |    2293    |       211        |
  | 1989 |     853538     |    1532    |       199        |
  | 1990 |    1183665     |    5635    |       299        |
  | 1991 |    1843600     |    8226    |       224        |
  | 1992 |    2259660     |   11542    |       239        |
  | 1993 |    3753095     |   14435    |       263        |
  | 1994 |    4619600     |   15257    |       334        |
  | 1995 |    5937505     |   17869    |       333        |
  
  *注：本表由原书图片使用 `QQ` 截图文字识别功能修改后获得，与原图片有出入，由于题干只涉及到数据的显示，因此 **不必在意这些细节***。
  
  在这个程序中，要用到我们前面学到的几乎所有的知识，注意选择适当的寻址方式和相关子程序的设计和应用。
  另外，要注意，因为程序要显示的数据有些已经大于65535，应该编写一个新的数据到字符串转化的子程序，完成 `dword` 型数据到字符串的转化，说明如下。
  
  名称: `dtoc`
  功能:将 `dword` 型数转变为表示十进制数的字符串，字符串以 '0' 为结尾符。
  
  ---
  参数:`(ax)=dword` 型数据的低16位
  		`(dx)=dword`型数据的高16位
  		`ds:si` 指向字符串的首地址
  
  返回:无
  
  ---
  
  在这个子程序中要注意除法溢出的问题，可以用我们在实验10中设计的子程序 `divdw` 来解决。
  
  
  
  - [ ] 完成与否



# 14 标志寄存器

CPU内部的寄存器中，有一种特殊的寄存器(对于不同的处理机，个数和结构都可能不同)具有以下 3 种作用：

1. 用来存储相关指令的某些执行结果;
2. 用来为CPU执行相关指令提供行为依据;
3. 用来控制CPU的相关工作方式。

这种特殊的寄存器在 8086 CPU 中，被称为**标志寄存器**。8086 CPU 的标志寄存器有 16
位，其中存储的信息通常被称为 **程序状态字**(`PSW`)。

flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而 **flag 寄存器**是**按位起作用**的，也就是说，它的**每一位都有专门的含义**，记录特定的信息。
8086 CPU 的 flag 寄存器的结构如下图所示。

![14_1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/14_1.png)

flag 的1、3、5、12、13、14、15 位在 8086 CPU 中没有使用，不具有任何含义。而
0、2、4、6、7、8、9、10、11位都具有特殊的含义。

标志位一览表，来源于百度百科

| 标志位 | 外语全称             | 标志位名称   | =1     |                  |      | =0       |                    |      |
| :----: | -------------------- | ------------ | ------ | ---------------- | ---- | -------- | ------------------ | ---- |
|   CF   | Carry Flag           | 进位标志     | 进位   | Carry            | CY   | 无进位   | No Carry           | NC   |
|   PF   | Parity Flag          | 奇偶标志     | 偶     | Parity Even      | PE   | 奇       | Parity Odd         | PO   |
|   AF   | Auxiliary Carry Flag | 辅助进位标志 | 进位   | Auxiliary Carry  | AC   | 无进位   | No Auxiliary Carry | NA   |
|   ZF   | Zero Flag            | 零标志       | 等于零 | Zero             | ZR   | 不等于零 | Not Zero           | NZ   |
|   SF   | Sign Flag            | 符号标志     | 负     | Negative         | NG   | 非负     | Positive           | PL   |
|   TF   | Trace Flag           | 跟踪标志     |        |                  |      |          |                    |      |
|   IF   | Interrupt Flag       | 中断标志     | 允许   | Enable Interrupt | EI   | 禁止     | Disable Interrupt  | DI   |
|   DF   | Direction Flag       | 方向标志     | 减少   | Down             | DN   | 增加     | Up                 | UP   |
|   OF   | Overflow Flag        | 溢出标志     | 溢出   | Overflow         | OV   | 未溢出   | Not Overflow       | NV   |

本章学习 `CF`、`PF` 、`ZF` 、`SF` 、`OF` 、`DF` 标志位以及相关指令。



## 14.1 `ZF` 标志

**`ZF` 是 `flag` 的第 6 位**，零标志位（**Zero Flag**）。

它记录相关**指令执行后**，**结果是否为零**。

如果 **为 0**，那么 **`zf=1`**，如果 **不为 0**，那么  **`zf=0`**. 

 如下例：

```assembly
mov ax,1
sub ax,1	; 执行后，结果为 0，则 zf=1.

mov ax,2
sub ax,1	; 执行后，结果不为 0，则 zf=0.
```

- 注意：

  有的指令的执行 **影响** 标志寄存器，如 `add`，`sub`，`mul`，`div`，`inc`，`or`，`and` 等，这类 **运算指令**（逻辑运算或算术运算）；

  有些指令 **不影响**，如 `mov`，`push`，`pop` 等，他们大都是 **传送指令**。、



## 14.2 `PF` 标志

**flag 的第 2 位是 `PF`**，奇偶标志位（Parity Flag）。

它记录相关**指令执行后**，**其结果**的所有 **二进制位中 1 的个数** 是否为偶数。

如果1的个数为 **偶数**，**`pf=1`**，如果为 **奇数**，那么 **`pf=0`**.

比如，指令:

```assembly
mov al,1
add al,10
```

执行后，结果为 `00001011B`，其中有3(奇数) 个 1，则 `pf=0`;

```assembly
mov al,1
or al,2
```


执行后，结果为 `00000011B`，其中有2(偶数) 个 1，则 `pf=1`;

```assembly
sub al,al
```

执行后，结果为 `00000000B`，其中有 0(偶数) 个 1，则`pf=1`。



## 14.3 `SF` 标志

**`flag` 的第 7 位是 SF**，符号标志位（Sign Flag  ）。

它记录相关指令执行后，其结果是否为负。

如果结果**为负**，**`sf=1`**；如果 **非负**，**`sf=0`**。

我们在处理一个数时，比如 `10000001B` 可以看成是是无符号的 129，

也可以看成是 -127（符号位不变，减一取反得原码 `11111111B`，符号位 `1` 表示负数，其余位之和 $1111111B = 2^{7}-1 = -127$ ）

如此，对于同一个二进制数，计算机可以将它当作有符号或无符号数据来运算。

那么计算机如何识别一个数到底时有符号还是无符号数呢？答案就是本节标题。

**`SF` 标志**，就是 CPU 对有符号数运算结果的一种记录，它**记录数据的正负**。

~~`SF=1`，表示 有符号 运算，结果为负；~~

~~`SF=0`，表示 无符号 运算，结果为非负。~~

以上表述并不准确，尤其在遇到 **检测点 11.2** 时，仅仅凭运算结果判定 `SF` 的取值会有矛盾。例如以下指令：

```assembly
mov al,10H	; 0001 0000 (B); 无符号 16		; 有符号，原码即补码	16
add al,90H	; 1001 0000	(B); 无符号 144	; 有符号，原码取反加一为其相反数	-112
```

以下指令执行，二进制运算结果为`1010 0000` ，

有符号运算的结果为 160（补码：`1010 0000`），没有超出 0 ~ $(2^{8}-1)$ 的无符号表示范围，所以没有进位，`CF = 0`.

无符号运算的结果为 -96（补码：`1010 0000`），也没有超出有符号表示范围 -128 ~ 127，所以没有溢出，`OF = 0`.

那么，既然无符号运算的结果为非负，有符号运算的结果为负，`SF` 该以哪个结果的标准作为取舍呢？所以以上对于 `SF` 标志位的取值的说法是不严谨的。对此，我们参照维基百科的定义：

> In a computer processor the **negative flag** or **sign flag** is a single bit in a system status (flag) register used to indicate  whether the result of the last mathematical operation produced a value  in which the most significant bit (the left most bit) was set. In a two's complement interpretation of the result, the negative flag is set if the result was negative.

以上对于 `SF` 标志位的取值有了两条参照标准，一是，运算结果的最高有效位（`MSB` ，就是最左边的位，也叫最高权重位，例如 8 位数的最高权重位即最左边的 $2^{7}$）的取值；二是，用补码表示运算结果时，若结果为负，则置零。

为减少分歧，在此统一规定，**`SF` 的取值为运算结果的最高有效位**。



例如，指令 `sub al,al` 执行后，`ZF` 、`PF`、`SF` 标志位都会受影响，分别为 1、1、0.

- 检测点 11.1

  写出下面每条指令执行后，`ZF`、`PF`、`SF`等标志位的值。

  ```assembly
sub al,al	; ZF=1	PF=1	SF=0
mov al,1	; ZF=0	PF=0	SF=0
push ax		; ZF=0	PF=0	SF=0
pop bx		; ZF=0	PF=0	SF=0
add al,bl	; ZF=0	PF=0	SF=0
add al,10	; ZF=0	PF=1	SF=0
mul al		; ZF=0	PF=1	SF=0
  ```

  *注：由于题干没有给出数据，我只能把每一条指令执行的结果继续带到下一条执行了。*



## 14.4 `CF` 标志

**flag 的第 0 位是 `CF`，进位标志位。**

一般情况下，在进行**无符号**数运算的时候，它记录了运算结果的最高有效位 **向更高位的进位值**，或从 **更高位的借位值**。

强调一下，是无符号数运算，**无符号！**，**无符号！！**，**无符号！！！**

对于位数为 N 的无符号数来说，其对应的二进制信息的最高位，即第 N-1 位，就是它的最高有效位，而假想存在的第 N 位，就是相对于最高有效位的更高位，如下图：

![14_2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/14_2.png)

比如下面两个数相加产生**进位**的例子：

```assembly
mov al,98H
add al,al	; 执行后，(al)=30H，CF=1，
			; CF 记录了从最高有效位向更高位的进位值 1
add al,al	; 继续执行后，(al)=60H,CF=0，
			; CF 记录了从最高有效位向更高位的进位值 0
```

再比如下面两个数相减产生**借位**的例子：

```assembly
mov al,97H
sub al,98H	;执行后:(al)=FFH，CF=1，CF记录了向更高位的借位值 1
sub al,al	;执行后:(al)=0，CF=0，CF记录了向更高位的借位值 0
```

- 思考：为什么借位或进位要么是 1，要么不存在借位或进位呢？

  稍微动笔画两下，就知道对于这类进制数的加减法，一次确实只能向前借一位或进一位。不是怕借多了还不起，就是只能脚踏实地，一步一个脚印，不能一步登天。

  那么，乘法呢？乘法一次可不会只允许进一位吧。通过前面的学习，我们已经直到，乘法的结果由最多两个寄存器保留，在乘数位数和对应结果存放的限制下不会产生溢出。



## 14.5 `OF` 标志

- **溢出**

在进行 **有符号** 数运算的时候，如**结果超**过了机器所能表示的**范围**称为溢出。

比如说指令运算的结果用 8 位寄存器或内存单元来存放，比如，`add al,3`，那么对于8位的有符号数据，机器所能表示的范围就是 `-128~127`。同理，对于 16 位有符号数据，机器所能表示的范围是 `-32768~32767`.

如果运算结果超出机器所能表达的范围，将产生溢出。如下两例：

*记住，这里所讲的溢出，只针对有符号数*；

  ```assembly
  mov al,89
  add al,99
  ```

以上指令执行后，将产生溢出，当我们将指令 `add al,99` 看作是有符号运算时，

`(al)=(al)+99=98+99 = 197`，因为，197 超出有符号 8 位数的范围：`-128 ~ 127`，所以将会溢出。

  ```assembly
  mov al,0F0H	; F0H，为有符号数-16的补码
  add al,088H	; 88H，为有符号数-120的补码
  ```

执行后，将产生溢出。因为 `add al,088H` 进行的有符号数运算是:
  `(al)=(al)+(-120)=(-16)+(-120)=-136`，

   -136 超出有符号 8 位数的范围：`128~127`.

- **溢出标志位**

  CPU 需要对指令执行后是否产生溢出进行记录，于是就有了溢出标志位，**溢出标志位假定你进行的是有符号运算**

**flag 的第 11 位是 `OF`，溢出标志位**。

  ~~一般情况下，`OF` 记录了 **有符号** 数运算的结果是否发生了溢出。~~

  ~~如果 **发生溢出**，**`OF=1`**；如果**没有**，**`OF=0`**。~~

~~- **`OF` 标志 与 `CF` 标志 的区别**~~

  ~~**`CF`** 是对 **无符号** 数运算有意的标志位，而~~

  ~~**`OF`** 是对 **有符号** 数运算有意义的标志位。~~

~~- [ ] 既然一个数可以看成是有符号数 或 无符号数，那么计算机如何区分，存储的数据到底是有符号数还是无符号数呢？~~

~~- [ ] 是否，有符号数的运算，都是以补码进行，而无符号数都是以原码就行？~~

~~- [ ] 又或者，汇编语言中的数值表达都是用补码表达？以一个 8 位数为例，若为有符号数，其范围为 `-128~127` ；此时有一数 `11001011B` ，以无符号数视之，则为一大于 128 数；以有符号数视之，则为有符号负数。。。。~~

  ~~以上，详见附录2，补码~~

  





~~综上，计算机不会识别一个数到底是有符号数还是无符号数。至于是无符号数还是有符号数这取决于使用者对 `CF` 和 `OF` 标志位的取舍。~~

~~什么意思呢？来看下面几个例子：~~
```assembly
mov al,98
add al,99
```
~~`add` 指令执行后：`CF=0`，`OF=1`. ~~

~~前面我们讲过，CPU 在执行 `add` 等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。对于无符号数运算，CPU 用`CF` 位来记录是否产生了进位；对于有符号数运算，CPU 用 `OF`~~~~位来记录是否产生了溢出，当然，还要用 `SF` 位来记录结果的符号。~~

~~对于无符号数运算，`98+99`没有进位，`CF=0`；~~

~~对于有符号数运算，`98+99`发生溢出，`OF=1`.~~

```assembly
mov al,0F0H
add al,88H
```
~~`add` 指令执行后：`CF=1`，`OF=1`. ~~

~~对于无符号数运算，`0F0H + 88H` 有进位，`CF=1`；~~

~~对于有符号数运算，`0F0H + 88H` 发生溢出，`OF=1`.~~

```assembly
mov al,0F0H
add al,78H
```
~~`add` 指令执行后：`CF=1`，`OF=0`.~~

~~对于无符号运算，`0F0H+78H` 有进位，`CF=1`；~~

~~对于有符号数运算，`0F0H+78H` 不发生溢出，`OF=0`.~~

~~我们可以看出，**`CF` 和 `OF` 所表示的进位和溢出，是分别对无符号数和有符号数运算而言的**，它们之间没有任何关系。~~



- 检测点 11.2

  写出下面每条指令执行后，`ZF`、`PF`、`SF`、`CF`、`OF` 等标志位的值。

  | 指令 \ 标志位 | `CF` |  `OF`   |  `SF`   | `ZF` | `PF` |
  | :-----------: | :--: | :-----: | :-----: | :--: | :--: |
  |  `sub al,al`  |  0   |    0    |    0    |  1   |  1   |
  | `mov al,10H`  |  0   |    0    |    0    |  1   |  1   |
  | `add al,90H`  |  0   | ***0*** | ***1*** |  0   |  1   |
  | `mov al,80H`  |  0   |    0    |    0    |  0   |  1   |
  | `add al,80H`  |  1   |    1    |    0    |  1   |  1   |
  | `mov al,0FCH` |  1   |    1    |    0    |  1   |  1   |
  | `add al,05H`  |  1   | ***0*** |    0    |  0   |  0   |
  | `mov al,7DH`  |  1   |    1    |    0    |  0   |  1   |
  | `add al,0BH`  |  0   |    1    | ***1*** |  0   |  1   |

  ~~注：第四、五两行组成的指令组，其运算结果 `(al)=100H`，其各个标志位的结果经实验如上，从中得出两个结论：~~

  ~~1. `mov` 这类传送指令执行前后，对标志位没有影响。（强调一遍）~~
  ~~2. 对于 无符号运算来说，运算结果的进位溢出并不会使 `SF=1`；反之，借位产生负数的运算结果会使 `SF=1`.~~

  扩展：

  ~~**奇偶标志位是根据运算结果的低八位的 1 的个数计算的**。~~

~~- 遗言：~~

  ~~上表，中又黑又歪的字体是我暂时不能想明白的事，或许我对基础了解的还不够吧。~~

  ~~我，真的不懂机器在想什么。。。~~

  ~~如上，对于涉及到的无符号运算，无符号相关的标志位倒是不难推测（这么一想，竟然有些欣慰）。但是对于，有符号运算而言，我太难了。。。。~~

~~- [ ] 完成与否标记。~~





​	 

## 14.6 `adc` 指令





## 14.7 `sbb` 指令



## 14.8 `cmp` 指令







# 15. 内中断









# 附录 1 Intel 系列未处理器的三种工作模式







# ~~附录 2 补码~~

- ~~对于补码我们已经知道：~~

  ~~1. **最高位为符号位；为 1，表示负数，为 0 表示正数。**~~

  ~~2. **正数和0的补码就是该数字本身，负数的补码则是将其对应正数按位取反再加1**.~~

~~- 我们不知道的事，关于硬件（来自于维基百科词条：补码）：~~

  ~~补码（英语：2's complement）是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，常在计算机科学中使用。补码以有符号比特的二进制数定义。~~

  ~~正数和0的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加 1。~~

  补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成~~各种有号数加法及减法，在电路设计上相当方便。~~

  ~~另外，补码系统的0就只有一个表示方式，这和反码系统不同（在反码系统中，0有二种表示方式），因此在判断数字是否为0时，只要比较一次即可。~~

  ~~更详细的信息，可参见维基百科。~~

~~- 本书附录对于补码的介绍中我们所不知道的：~~

  ~~1. 反码对于 `0` 的表示有二重性，即 存在 `+0` 和 `-0`.~~

  ~~2. **正数的补码取反加1后，为其对应的负数的补码；**~~

~~**负数的补码取反加1后，为其绝对值。**~~

~~比如:~~
~~`1` 的补码为：`00000001b`，取反加 1 后为：`11111111b`，表示 `-1`；~~
~~`-1` 的补码为：`11111111b`，取反加 1 后为：`00000001b`，其绝对值为 `1`.~~

  ~~据此，我们可以快速计算出有符号数补码的原码，或者说，我们习惯的值。~~













#  Question & No answer

## 1. 关于8086 CPU 最大寻址范围的问题

根据 8086 CPU 和成物理地址的方式，我们可以知道 8086 CPU 的寻址能力为 $2^{20}$，也就是 1 M，其寻址范围应为 `00000 ~ FFFFF`，用段地址和偏移地址表示为 `0000:0000 ~ F000:FFFF`. 但是使用 `Debug` 程序无论是 D 命令访问，A 或 E 命令写入 在这范围之外的物理地址如 `F001:FFFF`，都不会被 Debug 告知有什么错误，还能返回结果。这是为何？

Debug程序 使用的环境为 `xp` 系统的虚拟机。



## 2. 关于 SP + 2 的值 赋给 SP 后 SP 的值

 本书**问题3.11** 说到，“SP 原来为 `FFFEH`，加二后 SP = 0”，对此心中存疑，于是打开虚拟机上的 xp 系统，用 debug 程序进行了测试，结果如下图

![x1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/x1.png)

结果没有任何问题，哈哈，但是上一次结果并不是这样滴。

因为 SP 是 16 位寄存器，所以 SP + 2 的值赋给 SP 其结果溢出后会舍去溢出的不放呢，所以结果如此。

# Study Conclusion

1. 学习有主线和副线，要明确主线。

   在学习的过程中往往会遇到很多陌生的名词和知识点，这些东西对于后面的学习可能会有暂时阻碍。努力地去清除这些阻碍本无可厚非，但是不要将好奇心无限放大，越走越远，偏离学习的主线。以往的学习经验告诉我，这非但不会使我变得博学，而是变得更肤浅并浪费大把时间。记住，不要本末倒置。

2. 注重基础的学习，而不是工具和框架。

   新奇的东西确实会吸引眼球，让人有获得的欲望。但是不要忘记，再华丽花哨的东西都不是凭空而来的，它是在旧事物的基础上发展而来的。例如，看上去吸引眼球的逆向，有各种工具和方法，但是不变的是其核心是汇编指令，所有的逆向相关的书籍都会有汇编指令的内容，有些是 `x86`，有些是 `x64`，但是不管`x86` 还是`x64` 其基础都不会脱离 实模式。所以，应该把百分之八十的时间花在基础和底层知识的学习上，其余时间用来学习工具和框架才对。

   



[^1]: 本参考书出于教学考虑，将总线简单定义为 “连接CPU和其他芯片的导线”，不能解答某些疑问，故引用百科[总线](https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF)词条。
[^2]: 此分类与本参考书略微不同，本参考书描述上似乎将通用寄存器的范围限制在本小节所参考博文 [8086CPU各寄存器及其简介](https://blog.csdn.net/weixin_40913261/article/details/90762210)的数据寄存器之内，与百科锁定并由[“科普中国”科学百科词条编写与应用工作项目](https://baike.baidu.com/science) 所审核的 [通用寄存器](https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/283978?fr=aladdin) 词条不一致，遂以更符合权威部门所审定的参考博文为主。

[^3]:一个程序或者类库更新到较新的版本后，用旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。--百度词条[向下兼容](https://baike.baidu.com/item/%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9?fromtitle=%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9&fromid=94553)。

[^4]: 这两句话都引自 《Beginning x64 Assembly Programming: From Novice to AVX Professional》 一书，作者 Jo Van Hoey.
[^4]: 







- [ ] 关于 OF 标志位，有几点需要统一一下
- [ ] 关于补码（负数）的运算方式的统一，即符号位参与运算与否的两种方式。不参与，带符号的原码取反加一；不参与，对应正数的原码取反加一；
- [x] 关于 OF 标志位置零置一的时机，到底是运算结果为负还是最高有效位（MSB），还是运算结果的解释为补码时，结果为正为负
- [ ] 从 OF 标志位的角度来看运算，即如何把无符号数转换为有符号的运算
- [ ] ~~明确一点，计算机（仅以 X86为例）将数值都是以反码的形式存储的吗？还是说，执行指令时，把所有数值经编译器转换为补码？又或者都不是。~~ 涉及到数据存储的具体细节不在本时段学习范围。