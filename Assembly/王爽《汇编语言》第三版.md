*王爽《汇编语言》第三版 一书读书笔记*



[TOC]

# 1. 基础知识
## 1.1 机器语言
### 1.1.1 概念

机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字。计算机将之转换为一列高低电平以使计算机的电子期间受到驱动进行运算。

## 1.2 汇编语言
### 1.2.1 概念
1. 机器语言难以记忆和书写，与汇编语言产生。汇编语言主体是汇编指令，与机器语言的区别在于表达方法上。
2. 汇编语言由编译器翻译成机器码交给计算机执行。

### 1.2.2 语言成分
汇编语言由以下三部分组成：

1. 汇编指令：机器码对应的助记符，**有对应的机器码**。
2. 伪指令：没有对应的机器码，由编译器执行，计算机不执行。
3. 其他符号：如 `+、-、*、\` 等符号，由编译器识别，没有对应的机器码。

## 1.3 其他基本概念
1. 内存：

   1. 数据和指令存在的位置。
   2. 内存不是磁盘的容量（比如 1 TB 的硬盘），磁盘上的数据或程序如果不读入内存就无法被 CPU 使用。
   3. 每个存储器被划分为若干个存储单元，每个存储单元从 0 开始编号。

2. 计算机的最小 **信息单位** 是 **bit**（比特），一个二进制位。

3. 计算机最小的 **存储单位** 是 **Byte**，称一个 **字节**。

4. **两个字节为一个字**（word），刚好为一个 8086 CPU 寄存器的位数（16位）。

5. 单位换算：

   **8  bit = 1 Byte**

   **2 Byte = 1 Word**

   **1 KB = 1024 Byte**

   **1 MB = 1024 KB**

   **1 GB = 1024 MB**

   **1 TB = 1024 GB**

6. 内存地址空间：地址总线宽度下，可寻址范围极为 CPU 的内存地址空间。例如，一个 CPU 的地址总线宽度为 10 ,那么可寻址 $2^{10}$ 个内存单元。这 1024 个内存单元即是 CPU 的内存地址空间。

7. CPU 不能直接对外设进行控制，直接控制外设的是与这些外设相连接的扩展插槽上的接口卡。扩展插槽和接口卡通过总线与 CPU 相连，**CPU 通过 接口卡间接控制外设**。某些接口上装有 RAM，用来对大批量输入输出的数据进行暂存，例如显卡的显存。更多 CPU 控制外设的内容在后续外中断章节还会提到。

   

## 1.4 CPU 对存储器的读写

1. 必要条件：

   CPU 对存储器进行读写需要其他芯片提供以下三类信息：

   - 存储单元的地址信息
   - 器件的选择，读写命令。（控制信息）
   - 读写的数据信息。

2. 读写过程（仅以读为例）

   - CPU 通过地址总线将地址信息 3 发出。
   - CPU 通过控制总线发出读内存命令，选中存储器芯片，并通知它将要从中读取数据。
   - 存储器将 3 号单元的数据 8 通过数据线送入 CPU.

- 示意图（CPU 从三号单元读取数据的过程）
![1.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.4.png)



## 1.5 总线

### 1.5.1 概念[^1]

  总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由[导线](https://baike.baidu.com/item/导线/1413914)组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为[数据总线](https://baike.baidu.com/item/数据总线/272650)、[地址总线](https://baike.baidu.com/item/地址总线/4307936)和[控制总线](https://baike.baidu.com/item/控制总线/272568)，分别用来传输数据、数据地址和[控制信号](https://baike.baidu.com/item/控制信号/10329713)。总线是一种内部结构，它是cpu、内存、输入、[输出设备](https://baike.baidu.com/item/输出设备/10823333)传递信息的公用通道，[主机](https://baike.baidu.com/item/主机/455151)的各个部件通过总线相连接，[外部设备](https://baike.baidu.com/item/外部设备)通过相应的接口电路再与总线相连接，从而形成了[计算机硬件系统](https://baike.baidu.com/item/计算机硬件系统/8092895)。在计算机系统中，**各个部件之间传送信息的公共通路叫总线**，[微型计算机](https://baike.baidu.com/item/微型计算机/9287)是以[总线结构](https://baike.baidu.com/item/总线结构/10183496)来连接各个[功能部件](https://baike.baidu.com/item/功能部件/8514356)的。

### 1.5.2 逻辑分类

  从逻辑上分为以下三类：地址总线，控制总线，数据总线。

- **地址总线**：CPU 通过地址总线指定存储器单元。地址总线的宽度决定 CPU 的寻址范围。（更多有关地址总线的问题在后面寻址有关问题再讨论）

- **数据总线**：CPU 与 内存之间的数据传送通过数据总线进行传送。数据总线的宽度决定了 CPU 和 外界的数据传输速度。例如，8 根数据总线一次可以传输 一个字节的数据。

- **控制总线**：CPU 通过 控制总线控制外部器件。控制总线决定对外部器件的控制能力（能控制多少外部器件）。控制总线的方向是双向的，CPU 通过控制总线发送控制信息给其他器件，反之其他器件也通过控制总线发送反馈信息给  CPU.

### 1.5.3 南北桥芯片

  南北桥芯片是主板上的**总线控制器芯片**。

![1.5.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.5.3.png)

- 北桥芯片：

  北桥芯片通过前端总线直接与 CPU相连。用于高速信号，CPU 信号，RAM信号和 GPU 信号。AMD 在 K8 系列后将内存控制器集成在 CPU 中，因此 AMD系的主板上的北桥芯片不再控制内存。

- 南桥芯片


##  1.6 内存地址空间

- 基本概念：

  所有的物理存储器都被 CPU 看作**一个**由若干存储单元组成的**逻辑存储器**，也即**内存地址空间**。每个物理存储器在这个逻辑存储器中都有一个地址段，即一段地址空间。示意图如下：

- CPU 的逻辑存储器

  ![1.6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/1.6.png)

- 限制因素：

  内存地址空间的大小受**地址总线宽度**的限制，8086 CPU 的地址**总线宽度为 20**，即 20 跟地址线，可表示从 1 到 ($2^{20}$ -1) 的 $2^{20}$ 个不同的地址信息，即可**定位 $2^{20}$  个内存单元**，也即**可寻址** $2^{20}$  个地址空间**，则其内存地址空间大小为 1 MB**，**寻址能力**为 **1 MB**。



# 2. 初识寄存器

## 2.1 CPU 内部基本构造

CPU 的由运算器、寄存器、控制器等器件组成，这些器件靠**内部总线**相连，**外部总线**实现 CPU 和主板上其他器件的联系。CPU内部工作原理简单总结如下：

- 运算器进行信息处理。

- 寄存器进行信息存储。

- 控制器控制各种器件进行工作。

- 内部总线连接各种器件，在他们直接发送数据。

  

## 2.2 寄存器分类一览

来源 : [8086CPU各寄存器及其简介](https://blog.csdn.net/weixin_40913261/article/details/90762210)



**8086 CPU 中寄存器总共为 14 个，且均为 16 位 。**

即 **AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES** 共 14 个。

而这 14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。

### 2.2.1 通用寄存器

**数据寄存器：AX，BX，CX，DX **[^2]

| 标识 | 名称 |
| :--: |:--: |
|**AX** (Accumulator) | 累加寄存器，也称之为累加器 |
|**BX** (Base) | 基地址寄存器 |
|**CX** (Count) | 计数器寄存器 |
|**DX** (Data) | 数据寄存器 |



**指针寄存器：SP 和 BP **

|          标识          |      名称      |
| :--------------------: | :------------: |
| **SP** (Stack Pointer) | 堆栈指针寄存器 |
| **BP** (Base Pointer)  |  基指针寄存器  |

**变址寄存器：SI 和 DI **

|            标识            |      名称      |
| :------------------------: | :------------: |
|   **SI** (Source Index)    |  源变址寄存器  |
| **DI** (Destination Index) | 目的变址寄存器 |



### 2.2.2 段寄存器

|          标识          |     名称     |
| :--------------------: | :----------: |
| **CS** (Code Segment)  | 代码段寄存器 |
| **DS** (Data Segment)  | 数据段寄存器 |
| **SS** (Stack Segment) | 堆栈段寄存器 |
| **ES** (Extra Segment) | 附加段寄存器 |



### 2.2.3 控制寄存器

|             标识             |      名称      |
| :--------------------------: | :------------: |
| **IP** (Instruction Pointer) | 指令指针寄存器 |
|           **FLAG**           |   标志寄存器   |



## 2.3 寄存器的逻辑结构

- 以数据寄存器 **AX** 为例

![2.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/2.3.png)

- 2进制和16进制的转换：

  **四位二进制数 等于 一位十六进制数**。因为四位二进制数可表示从0到 $2^{4}-1$ 即 15 以内的任意一个整数，一位十六进制数可表示的范围为0到15，刚好可以一一对应。因此，一个十六位二进制数可由四位十六进数表示。

- 在 8086 CPU 中，每个寄存器都是十六位。其中 **AX，BX，CX，DX** 四个 **数据寄存器** 由于向前兼容的原因可以分成**两个独立的 8 位寄存器**。如上图 **AX** 可以分成 一个 **AH** 寄存器，用来存储 **AX** 的 **高八位**称为**高位字节**，一个 **AL** 寄存器，用来存放 **AX** 的 **低八位**称为**低位字节**。类似的还有如下几种情况：
  - **BX** 可以分为 **BL** 和 **BH**；
  - **CX** 可以分为 **CL** 和 **CH**；
  - **DX** 可以分为 **DL** 和 **DH**；

- 在使用寄存器时需要注意以下几点：
  1. 一个寄存器只能存入其位数可表示范围以内的数据。例如，一个 **AX** 寄存器能存储的最大整数为 $2^{16}-1$ ，一个 **AL** 寄存器最大能存储的整数为 $2^{8}-1$.
  2. 在使用汇编指令如果操作对象由两个时，需要注意**两个操作对象的位数必须一致**。
  3. 在使用数据寄存器时需要注意，以 **AX** 为例，**AH** 和 **AL** 是两个 **独立** 的寄存器，**AL** 独立参与操作后得到的进位不会保存在 **AH**中，而是被舍去。如果 **AX** 参与操作此时第八位产生的进位会存储在高八位之中，此时 **AX** 相对于 **AH** 和 **AL** 而言也是一个独立的寄存器。



# 3. 物理地址

## 3.1 基本概念

- 定义：

  前面说到，CPU 将所有的物理存储器看一个由若干个存储单元组成的 **逻辑存储器**。所有的内存单元构成的存储单元是一个 **一维的线性空间**。每一个内存单元在这个一维的地址空间，这个地址被称为 **物理地址**。

- 16 位结构的 CPU：

  - 运算器一次最多可以处理 16位的数据；
  - 寄存器的最大宽度为 16位；
  - 寄存器和运算器之间的通路为 16位。

- **8086 CPU 有20跟地址线可表示 $2^{20}$ 个物理地址，即具有 1 MB 的寻址能力。**



- *扩展：*
  - x 位 CPU的说法是一种商业的叫法，并不是严格的专业术语。不同架构的 CPU对此亦有不同的定义标准。比如 CISC 架构的 x86 指令集的32位和64位就与 RSIC 架构的 ARM指令集的32位和64并相同。
  - 32位CPU通常有32个地址总线，其寻址能力为 $2^{32}$，即 **4 GB**. 由于 32位架构的 CPU寻址能力的限制，此架构的 CPU的计算机并不能利用大于其寻址能力以外的物理地址。
  - x86架构指的是以8086指令集为基础后进行一系列扩展的指令的集合，其特点是向下兼容[^3]。x86-32指的是 x86架构的32位扩展。
  - x86-64架构也被称为 AMD64架构，这是由于x86架构的64位扩展是由 AMD公司率先一步实现的。Inter 公司曾自研过不兼容 x86 架构的 IA-64，但由于x86 已形成的强大生态，IA-64日渐式微，AMD64架构最终也被Inter 采用。
  - x 位的操作系统指的是支持 x 位的操作系统，其针对特定 x 位的 CPU 进行设计。



## 3.2 8086 CPU 给出物理地址的方法

-  CPU 内部物理地址的合成与传送流程：
![2.4.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/2.4.2.png)

   

   1. CPU 中相关部件提供两个16 位的地址，一个称为 **段地址**，另一个称为 **偏移地址**；
2. 段地址和偏移地址通过内部总线送入一个称为**地址加法器**的部件；
   3. 地址加法器将**两个 16位地址合成一个 20位的物理地址**；
4. 地址加法器通过内部总线将 20位物理地址送入输入输出控制电路；
   5. 输入输出控制电路将 20位物理地址送上地址总线；
6. 20 位物理地址总线传送到存储器。


- 合成方法：

  **物理地址 = 段地址（SA） \* 16 + 偏移地址（EA）**

- 含义：段地址 \* 16 定位段的**起始地址**（基础地址），用偏移地址定位段中的内存单元。
- *注意：段地址和偏移地址都是**16位**。*



## 3.3 内存的“段”

### 3.3.1 基础知识

- “段”并不存在于物理内存中，“段”是**由 CPU 划分的若干个连续的存储单元**。在后面的学习中就会知道，后面的 “数据段”，“代码段” 和 “堆栈段”都是人为划分的段。
- “段”没有硬性的规定范围，可大可小。但是需要注意的是，由于偏移地址是16位，可寻址 $2^{16}$ 个内存单元，所以**一个段的最大长度是 64 K.**

### 3.3.2 CS 和 IP

- 基础知识：
  - 段寄存器：用于存放段地址的寄存器。在8086 CPU 中有 CS、DS、SS、ES。
  - **CS**：代码段寄存器，存放代码（指令）的段地址。
  - **IP**：指令指针寄存器，存放指令的偏移地址。
- 修改 CS 和 IP 的值
  1. 8086 CPU中传送指令 `mov` 不能用于设置 CS、IP的值。
  2. `jmp` 指令可同时修改 CS、IP的值 ，`jmp SA:EA`。例如 `jmp 2AE3:1003`.
  3. `jmp` 只修改 IP寄存器的值，`jmp 某一合法寄存器`。例如：`jmp ax`.“某一合法寄存器”，表示只能用寄存器的值修改 IP.

### 3.3.3 指令执行流程

![3.2.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/3.2.2.png)

1. CS、IP  中的内容送入地址加法器（地址加法器完成：物理地址 = 段地址 *  16 + 偏移地址）;
2. 地址加法器将物理地址送入输入输出控制电路；
3. 输入输出控制电路将 20000H（CS:IP 指向的物理地址）送上地址线；
4. 内存 20000H 单元处的第一条**指令通过数据总线**被送入 CPU；
5. 输入输出控制电路将机器指令送入**指令缓冲器**；
6. IP 中的值**自动增加**指令长度的值；
7. **执行控制器**执行指令；
8. 从 1 处重复执行至止。

**Notice：** **IP 先自增然后指令再执行**。

# 4. Debug 程序

- Debug 是 DOS、Windows （自 Windows 10 之后不再提供此程序）都提供的实模式（8086 方式）程序的调试工具。
- 使用方法：打开命令行（cmd），在命令行界面手动输入 “debug”  即可进入。
- 使用到的命令与功能：

| 命令 |                 功能                 |
| :--: | :----------------------------------: |
|  R   |        查看、修改寄存器的内容        |
|  D   |            查看内存的内容            |
|  E   |           改写内存中的内容           |
|  U   |   将内存中的机器指令翻译成汇编指令   |
|  T   |           执行一条机器指令           |
|  A   | 以汇编的格式在内存中写入一条机器指令 |

## 4.1 指令的用法

- R 命令

|   指令格式   |                  命令用法                  |                          |
| :----------: | :----------------------------------------: | :----------------------: |
|      r       |          无参数，查看寄存器的内容          |            r             |
| r *register* | 以部分寄存器名作为参数，修改寄存器的内容。 | r ax ,  r cs , r ip 等等 |

**Tips** ： 在使用 R 命令修改寄存器内容时，在指令输入后按下回车键会出现一个 “:” 符号作为内容输入的提示，当输入完成后再次回车即可修改内容，可用 R 指令再次验证内容是否改变。



- D 命令

常用方法：`d 段地址[段寄存器]:偏移地址1 [偏移地址2]`

例如：`d 1000:9`，`d 1000:9 f`，`d ds:0 f`



当 D 命令只有一个参数时，会显示一个默认的 段地址（这个段地址来自哪里，目前无法确定），这个参数将作为显示首行内存信息的偏移地址



- E 命令

常用方法：

1. `e 段地址:偏移地址 data1 data2 data3 ... `

例如：`e 1000:0 0 1 2 3 4 5`

2. 提问方式修改从某一地址开始的内存单元的内容，步骤如下：

首先按 `e 段地址:偏移地址` 的格式输入物理地址（起始地址）后按下回车，之后debug程序会显示起始地址，和第一单元的原始内容，让后光标停在 `.` 的后面以此提示用户输入想要修改的内容，不输入内容直接按空格则不会修改原始内容。无论输入与否只要按下空格则会进入下一个地址，显示下一个地址的原始内容，后面再次出现 `.` 提示符号，直至用户按下回车完成内存该写。如下图：

![4.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.1.png)

3. 写入单个字符和字符串

写入单个字符 ：`e 1000:0 1 'a' 2 'b' 3 'c'`

写入字符串： `e 1000:0 1 "a+b" 2 "c++" 3 "dayelu"`



**Tips**：E 命令还可以通过写入指令对应的机器码来写入指令。



- U 命令

常用方法： `u 段地址:偏移地址1 [偏移地址2]`

使用方法如下图：

![4.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.2.png)



- T 命令

使用指南：

要想使用 T 指令执行自己想要执行的指令有两种方法：一种方法是首先要将汇编指令写入 `CS:IP ` 处，由于这是汇编指令的起点；另一种方法是将指令写入想要写入地址处，然后再通过认为改变 CS寄存器和 IP寄存器的地址来执行指令。以下以第二种为例：

1. 如上图 首先从物理地址 `1000:0` 处写入汇编指令。
2. 用 R 指令将 `CS:IP` 地址 设置为 `1000:0`.
3. 使用 T 命令对汇编指令进行单步执行。

操作如图：

![4.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.3.png)



- A 命令

使用 E 命令可以写入机器指令，但是这样写入很不方便，因此 Debug 提供了 A 命令用于直接像内存写入汇编指令。

使用方法：`a 段地址:偏移地址`，操作如下图：

![4.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/4.4.png)

- [ ] 使用 `a 段地址:偏移地址` 的办法可以直接指定 CS:IP 所指向的位置，也就是代码段的位置，从此处开始输入指令。

  

  除此之外还可以直接以 输入 a指令后回车的方式从预设的 CS:IP  处开始输入指令。

  事实整明并非如此，当 CS:IP 改变 a 命令的回车默认位置并不会改变，也就是说它是一个预定值。这跟上面 D 命令的情况也类似，其段地址也是个预定值，并不会随着 CS 或者 DS 寄存器进行改变。



​		诡异的时，当我推出debug程序再次进入时，CS，DS 和 A命令，D 命令的预设值都会一模一样！！！

​	

​		这说明 debug 程序也会有欺骗的嫌疑，这些程序的原因未必会出现 汇编语言的中，因此，过分纠结这些工具好像属实没必要！！！！

​		

# 5. 寄存器（内存访问）

## 5.1 内存种字的存储

在 CPU 种用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节。如图所示：

![5.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/5.1.png)

假设从地址 0 处开始存放 2000（**4E20H**），用 地址为0 和 1 两个内存单元存放。**高地址 1** 存放**4E**，**低地址 0** 存放 **20** .

**字单元**：存放一个字型数据（16位）的内存单元，由**两个地址连续的内存单元**组成。**高**地址内存单元中存放字型数据的**高**字节位，**低**地址内存单元存放字型数据的**低**字节位。这种方式有时也被称为“**高高低低**”原则，属于**小端模式**。



关于更多 “**大小端模式**” 的相关问题详见博客 [详解大端模式和小端模式]( https://www.cnblogs.com/wpgraceii/p/11395719.html)



## 5.2 DS 和 [address]

**CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址**，在 80806 CPU 中，内存地址由段地址和偏移地址组成。

**DS 寄存器：**在 8086 CPU 中通常用 **DS 寄存器存放要访问数据的段地址**。例如;

```assembly
mov bx,1000H	; 1
mov ds,bx		; 2
mov al,[0]		; 3
```

**解析：**

将 地址为 10000H 的内存单元（8位，一个字节）里的值送入 al 寄存器中。

由于 **8086 CPU 不支持将 数据 直接送入段寄存器中**，送所以只能将 地址为 10000H 内存单元的段地址，即 **1000H** 先送入 **bx** 寄存器中，再由 **bx** 传送给 段寄存器 **DS**.如上述步骤1，2.

**[...]** 表示一个内存单元，**[ ]** **中的数值表示内存单元的偏移地址**，其**段地址默认存储于 段寄存器 DS 中**，8086 CPU 执行指令时会自动从 DS 中取出。由于al 是8位寄存器，所以这里步骤3 就表示将内存单元 **1000H:00H** 中的值传送给 寄存器 al。



## 5.3 mov、add、sub 指令

### 5.3.1 mov 指令形式

1. 与段寄存器无关的指令语句

|              形式              |    例子    |
| :----------------------------: | :--------: |
|   **mov ** *register*,*data*   | mov ax,8AH |
| **mov ** *register*,*register* | mov ax,bx  |
|  **mov ** *register*,*[···]*   | mov ax,[0] |
|   **mov ** [···],*register*    | mov [0],ax |

2. 与段寄存器相关的指令语句

|                  形式                   |   例子    |
| :-------------------------------------: | :-------: |
| **mov ** *register*, *segment register* | mov ds,ax |
| **mov **  *segment register*,*register* | mov ax,ds |
| **mov ** *segment register*,*[···]* | mov ax,1000H<br >mov ds,ax<br >mov ds,[0] |
| **mov ** [···],*segment register* | mov ax,1000H<br >mov ds,ax<br >mov [0],ds |



### 5.3.2 add 指令和 sub 指令

**add 加法指令，sub 减法指令**，与 **mov指令** 类似，**将两个数值计算结果储存在 指令操作的第一个操作对象里面（寄存器或内存单元）**，格式有以下分别四种。


|              形式              |    例子    |
| :----------------------------: | :--------: |
|   **add ** *register*,*data*   | add ax,8AH |
| **add ** *register*,*register* | add ax,bx  |
|  **add ** *register*,*[···]*   | add ax,[0] |
|   **add ** [···],*register*    | add [0],ax |
|   **sub ** *register*,*data*   | sub ax,8AH |
| **sub ** *register*,*register* | sub ax,bx  |
|  **sub ** *register*,*[···]*   | sub ax,[0] |
|   **sub ** [···],*register*    | sub [0],ax |



# 6 8086 CPU 栈机制

## 6.1 基本概念

- **栈的基本操作**：
  
  - **入栈**：将一个新元素放入栈顶。
  - **出栈**：从栈顶取出一个元素。
  
- 栈的特点：

  栈顶元素总是最后入栈，需要出栈时，又最先被栈中取出。栈的这种操作原则被称为：**LIFO（Last In First Out，后进先出）**。

- **关于栈顶和栈底的区分**：

  可以**将栈想象成一个瓶子**，向瓶子里塞物品（假设瓶子是规则的筒状，并且物品刚好每次只能塞进去一个），**瓶底就是栈底**，靠近瓶口的物品的位置就是栈顶。

- 基本的 **入栈和出栈指令**：**PUSH（入栈）和 POP（出栈）**

- 8086 CPU 的入栈和出栈都是**以字（16 位）为单位**进行的。

- 8086 CPU **确定栈顶元素位置的方式**：

  - **SS (Stack Segment)  堆栈段寄存器** ：**存放栈的段地址**。

  - **SP (Stack Pointer)  堆栈指针寄存器**：**存放栈的偏移地址**。

    **任意时刻，SS:IP 指向栈顶元素。**



## 6.2 出入栈操作的完整过程

- **入栈**过程，**栈顶从高地址向低地址方向增长**，以**push ax**为例，步骤如下：

  
  
  1.  **SP = SP - 2，SS:SP 指向当前栈顶前面的字单元，以当前栈顶前面的字单元为新的栈顶**。
  2.  **将 ax 中的内容送入 SS:SP 指向的内存单元处**，SS:SP 此时指向新栈顶。
  
  
  
    操作过程如下图，图片来自 *《汇编语言》第三版，59页，作者王爽*

![6.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.1.png)

- 出栈操作，与入栈操作刚好相反，以 **pop ax** 为例，步骤如下：

  
  
1. **将 SS:SP 指向的内存单元处的数据送入 ax 中**；
  2. **SP = SP + 2 ,SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。**

  

   操作过程如下图，图片来自 *《汇编语言》第三版，61页，作者王爽*

![6.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.2.png)

  - 注意 ：上图中，出站后，**SS:SP 指向新的栈顶 1000EH**，pop 操作前的栈顶元素，~~1000CH 处的2266H 依然存在~~，但是它已不在栈中。当再次执行 push 等入栈指令后， SS:SP 移动至 1000CH 处，并在里面写入新数据，~~覆盖当前数据~~。
  
    
    
    ~~这与外存的读写方式类似 ，删除数据的时候并不会对存储单元就行真的擦除操作，只是将其索引删去，使得这部分数据无法被检索到。当有新的数据写入时将会把这些数据覆盖。当发出删除操作指令之后就立马对数据作类似清零的操作会增加计算机的负载，增加时延，没有必要。以上属于个人理解。~~ 
    
    我没说过这句话。
    
    以上**注意**纯属**谣言！！！**，注意内容来自，本参考书籍王爽老师的《汇编语言》第三版，上面说到执行pop指令之后，被弹出去之前的栈顶元素依然与地址，当再次有入栈操后才会被覆盖掉。经亲手实验证实，在 pop 指令执行之后，该地址的内容会被栈顶上面的字元素填充，有图有真相：
    
    ![6.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.3.png)
    
    ![6.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.4.png)



## 6.3 答疑解惑

### 6.3.1 栈与内存图的画法

1. **关于内存的画法**
   通过参考国内外的相关书籍，可以初步做出以下结论：

   如果规定只能化成一个竖直形状的图形，**内存地址是从高到低还是低到高的标识法**其实都没有任何问题，**没有硬性的规定**。这只是一个模型而已，随便你怎么画好了，内存条等等这些硬件才不在乎你把它化成什么样子。但是不管怎么画都需要遵守相关的准则，例如下面要谈到的 x86体系结构下**CPU提供的栈机制**的画法 。

2. **关于栈的画法**

   至于栈的最原始定义是什么无从考证，栈只是一种数据结构而已。所以当你画栈的内存模型时，如果没有特殊限制说明，你画了一个栈并规定好栈顶之后，你**不需要过分纠结**入栈时，新元素是应该放在栈顶的上方还是下方，即规定**入栈的方向**。如果没有特殊的限制说明，你自己规定就好了，你规定入栈的方向在栈顶的上方，那元素就只能从此进入。再次强调，栈只是一个数据结构，你了解他的基本原理就够了，你只需知道**栈是一个受限的线性表，只能从一个方向填充和删除元素并且遵循 LIFO 原则就够**了。但是当遇到特定情况时需要遵守相关原则，例如下面要谈到的 x86体系结构下**CPU提供的栈机制**的画法 。

3. **x86 体系CPU 提供的栈机制的画法**

   前面提到，在没有规定下，无论内存地址的增长方向还是栈的入栈方向再没有特殊规定下可以随心所欲地画。但是，在特定硬件体系结构下，如本标题，栈和内存有特定的联系时，就不能随心所欲了。

   通过查阅国内外相关书籍，初步聊到 x86 体系 CPU 对栈的规定：

   1. **栈的"生长"方向是从高地址到低地址**。（*The stack will grow as more data is stored in it, and it will grow in the downward direction,
      from higher addresses to lower addresses.*）
   2. **入栈操作（执行 push 指令）时，栈顶的地址总是随着元素的增加而由高到低**（*The stack pointer rsp will decrease every time you put data on the stack.*[^4]），这句话本意应解释为：**“每次向栈中增加数据时，栈指针寄存器 的值将会减小**”，二者意义并无冲突。

   

所以关于栈的画法，内存是从上到下或者下到上增加都没关系，只是在 特定条件下，例如 x86 体系的CPU 的限制下，注意入栈的方向与内存的法相对应其法则就够了。现选取国外相关图书中**内存地址增加方向不同**的内存图画法如下，以供进一步理解：



- 入栈操作，**内存向下减小**，来自 *Assembly Language for x86 Processors, 7th Edition* 一书 141 页，作者 KIP R. IRVINE

![6.5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.5.png)

  - **内存向下增加**，Intel 64, registers and stack，英特尔 CPU 结构图，来自 *Low-Level Programming* 一书 15 页，作者 Igor Zhirkov.

    ![6.6](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.6.png)





### 6.3.2 一个关于 SP 的伪命题

- *SP 寄存器指向栈顶元素的哪个内存单元*? 以以下图为例，《汇编语言》第三版，59页，作者王爽。引出以下问题：

![6.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.1.png)

- 疑问：如上图第三部分，SP 是指向 66 还是 22 ？

- 解析：冷静了很久，才发现这是伪命题！因为， SP 是 堆栈指针寄存器，**单个 SP 是不能确定物理地址的**，更不用说确定 栈顶元素的物理地址。再次强调**任何时候，SS:SP 指向栈顶元素。** 由于 SS:SP 指向栈顶元素，所以可以确定 SS:IP 指向的是 66 而不是 22。因为根据 “**高高低低原则**” ，高地址存放高字节，低地址存放低字节，当 SS:IP 指向的是 66 时，高地址是 1000DH 存放 22，低地址是 1000CH 存放 66，所以 SS:SP 指向的字型数据是 2266H 。

  反之，如果 SS:IP 指向的是 22，那么 SS:SP 指向的字型数据就是 2322H 而不是 2266H 了。

  

- 困惑来源：在伪命题成立的情况下，误以为，pop 和 push 操作都是以字型数据为操作对象，所以无论 SP 指向 66 还是 22 pop 的都有可能操作的是 2266H ，会影响最终结果，以致一错再错。最后才通过分析 pop 指令执行时，SP 寄存器的变化才重回正轨。

  

  至于为什么会把 栈指令寄存器 SP 当成了 SS:SP 呢？原因就是来自 *Assembly Language for x86 Processors, 7th Edition* 一书 141 页的这张图相关的一系列图。

  ![6.5](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.5.png)

  
  
  ​	图中的寄存器 ESP 直接指向了内存单元！也就是说它一个寄存器就可以指向物理地址！这让我对 ESP 和 SP 之间产生了混淆，完全忘记了 我学的目前还是 8086汇编，而 ESP 寄存器属于 x86 汇编，与之类似的 还有属于 x64汇编的 RSP 。通过搜索才知道“**ESP为栈指针，用于指向栈的栈顶**”，**不需要像 8086 汇编中 两个寄存器合成 栈顶元素的物理地址。** 因此铸成大错。



## 6.4  空栈和栈顶超界问题

- 空栈状态，图片来自 *《汇编语言》第三版，60页，作者王爽*

  ![6.7](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.7.png)

  **若 10000H ~ 1000FH为栈空间**，栈底位置内存单元的地址为 1000FH ，当栈为空时，SS:SP 应该指向何处？

  由于当向栈空间添加一个元素之后，由于入栈操作的操作数是字型数据，所以 SS:SP 必然指向1000EH。因此反推之，当栈空时，SS:SP 指向不属于栈空间的栈底内存单元的下一个位置，即 10010H.**空栈也可以理解成栈中唯一的元素出栈**。



- 栈顶超界

  前面提到栈的空间时，都有一个“假设”的前提，那么 8086 CPU 有没有防止栈满时继续入栈导致出现栈顶超界问题的机制呢？

  答案是，并没有。**8086 CPU 并没有检测和限制栈的越界问题**。**8086 CPU 只考虑当前栈顶的位置，当前需要执行那一条指令**。**当栈满时继续进行入栈操作时，将会覆盖掉栈顶元素之上栈空间之外的一个字单元**。因此这是搬砖人员需要考虑问题。

  所以在编程时**尽量使用最大栈空间**防止入栈数据太多而导致的超界问题 ；同样在进行出栈时也需要注意当前栈是否为空，以防止出现栈空时继续出栈造成的越界问题。



## 6.5 push 和 pop 指令

- 指令使用方式：

|   指令格式    |              意义              |                     示例                     |
| :-----------: | :----------------------------: | :------------------------------------------: |
|  push 寄存器  |     将一个寄存器的数据入栈     |                   push ax                    |
|  pop 寄存器   |   出栈，用一个寄存器接收数据   |                    pop ax                    |
| push 段寄存器 |    将一个段寄存器的数据入栈    |                   push ds                    |
| pop 段寄存器  |  出栈，用一个段寄存器接收数据  |                    pop ds                    |
| push 内存单元 |    将一个内存单元处的字入栈    | mov ax,1000H<br >mov ds,ax<br >push [0]<br > |
| pop 内存单元  | 出栈，用一个内存字单元接收数据 | mov ax,1000H<br >mov ds,ax<br >pop [2]<br >  |



- 编程示例：

  - 要求：
    1. 将 10000H ~ 1000FH 这段空间当作栈，初始状态栈空；
    2. 设置 AX = 001AH，BX = 001BH；
    3. 将 AX、BX 中的数据入栈；
    4. 将 AX 、BX 清零；
    5. 从栈中恢复 AX、BX 原来的内容。

  

  - 代码示例：

    ```assembly
    mov ax,1000H
    mov ss,ax
    mov sp,0010H	;初始化栈顶，栈的情况如下图（a）所示
    
    mov ax,001AH
    mov bx,001BH
    
    push ax
    push bx		;ax,bx 入栈，栈的情况如下图（b）所示
    
    sub ax，ax
    sub bx，bx	;将ax清零用 mov ax,0 或者 sub ax,ax 都可以，前者机器码 2 字节，后者三字节。
    
    pop bx
    pop ax	;从栈中恢复 ax、bx 的数据，当前栈顶是 bx 中原来的内容， ax 原来的内容在栈顶下面，所以先 pop bx 再 pop ax
    ```

    ![6.8](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/6.8.png)

- 总结：

  push、pop 指令实质上一种**内存传送指令**，可以**在寄存器和内存之间传送数据**。

  push、pop 等栈操作指令**修改的只是 SP** ，因此，**栈顶的变化范围最大为 0 ~ FFFFH**。





- [x] 通过debug 程序验证 “pop 操作之后 数据仍在内存” 的正确性
- [ ] 吸收第三章 实验的知识。(这个实验跟后面的内容有联系，待学习完后面再战)

然后向下面这样



# 7. 第一个源程序

## 7.1 源程序示例

- 源程序 *1.asm*

```assembly
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	
	mov ax,4c00H
	int 21H

codesg ends	;名为 codesg 的段到此结束

end
```



1. 伪指令

   汇编语言源程序包含 **汇编指令** 和 **伪指令** 两种指令。

   **汇编指令**是有对应机器码的指令，最终**被 CPU 执行**。

   **伪指令**没有对应的机器指令，最终不被 CPU 所执行，而是**被编译器执行**。

   

   上述源程序中出现的伪指令有如下几种：

   

   - **segment 和 ends**

      segment 和 ends 是**可编译源程序**中必须被用到的两个**成对使用**的伪指令。这对指令的功能是定义一个段，**segment** 标记一个**段的开始**，**ends** 标记一个**段的结束**。使用格式如下：
    ```
   段名 segment
   ：
   段名 ends   
    ```

   - **end**

     整个汇编源程序的结束标志。编译器执行到此即结束编译。

   

   - **assume**

     这条伪指令的含义为“假设”，假设某一段寄存器和程序中的某一个用 segment...ends 定义的段相关联。

   

2. **标号**

   汇编源程序中除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。



3. **程序返回**

   在一个**单任务系统**中（以 DOS为例），一个程序 P2 在可执行文件中，则必须有一个正在运行的程序 P1，将 P2 从可执行文件中加载到内存后，将 **CPU** 的**控制权**将给 P2， P2 才能得以运行。P2 开始运行后，P1 暂停运行。

   而当 P2 运行完毕后，应该将 **CPU** 的**控制权**交还给使它得以运行的程序 P1，此后，P1继续运行。

   

   一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，这个过程被称为 “**程序返回**”。

   ```assembly
mov ax,4c00H
   int 21H
   ```
   
   这两条指令所实现的功能就是 **程序返回**。



## 7.2 源程序的编译、连接和执行

- 工具：masm5.0 汇编编译器，Overlay Linked3.60 连接器

- 步骤：以 *1.asm* 为例

  1. **编译** 源文件（.asm），生成目标文件（.obj）

     ```
     C:\masm>masm 1.asm;
     ```

  2. **连接** 目标文件（.obj）,生成可执行文件（.exe）
     
     ```
     C:\masm>link 1.obj;
     ```

  3. 执行
  
     ```
     C:\masm> 1.exe
     ```



- 注意：
  1. 编译和连接命令后面**分号（;）**不可省略。
  2. 以上三个步骤中文件后缀名（如 .asm , .obj , .exe等）均可省略。



## 7.3 程序执行过程的追踪

- DOS 中 .EXE 文件的简单加载过程，如下图：*王爽《汇编语言》第三版，92页*

  ![7.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.1.png)

- 追踪工具：Debug 程序

  由于 Debug 程序可以将程序加载入内存，**设置 CS:IP 指向程序的入口**，但是，**Debug 程序 不放弃对 CPU 的控制**，所以可以对程序执行过程就行追踪。

  

- 追踪过程，以源程序 1.asm 生成的可执行文件 1.exe 为例，如下图：

  ![7.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.1-1597756911155.png)

  ![7.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7.2.png)

  

- 步骤说明：

  1. 在命令提示符中输入`debug 1.exe` 后回车，Debug 将从将程序从 1.exe 加载入内存中，进行相关初始化后，设置 **CS:IP** 指向程序的入口。
  2. 使用 T 命令单步执行，直到下个指令为 `INT 21` 时，**使用 P 命令结束**程序。
  3. 使用 Q 命令退出 Debug 程序，将返回到 command （命令行终端）中，因为 Debug 是由 command 加载运行的。



- 过程解析：

  在 DOS 中用  `debug 1.exe`  运行 Debug 对 1.exe 进行跟踪时，

  程序**加载顺序**是：command 加载 Debug $\longrightarrow$ Debug 加载 1.exe 

  程序**返回顺序**是：从 1.exe 中的程序返回到 Debug $\longrightarrow$ 从 Debug 返回到 command。

  

## 实验三

- 源程序：t1.asm

```asm
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,2000H
	mov ss,ax
	mov sp,0
	add sp,10

	pop ax
	pop bx
	push ax 
	push bx
	pop ax
	pop bx
	
	mov ax,4c00H
	int 21H

codesg ends	;名为 codesg 的段到此结束

end
```

- Debug 追踪，如下图

![7x1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x1.png)

![7x2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x2.png)

![7x3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x3.png)



- 查看 PSP 区的内容

![7x4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/7x4.png)



- [ ] 其中玄机如何，暂未参透，待来日回首。



# 8. [BX] 和 LOOP 指令

## 8.1 [BX]

和 `[0]`一样，`[BX]` 同样也表示一个内存单元，段地址在 DS 寄存器中，偏移地址 在 BX 寄存器中。如下：

```assembly
mov ax,[bx]
```

将一个内存单元的地址送入 ax。这个内存单元的长度位 2（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

- 约定符号：

  为了方便下文的描述，做如下规定：

  1. 符号 `()` 表示一个内存单元或者寄存器的内容。例如：(ax) 表示寄存器 ax 的内容。
  2. `idata` 表示常量。例如：`mov ax,[idata]` 代表 `mov ax,[1]、mov ax,[2]` 等。

- 有例题如下：

- 代码：

```assembly
mov ax,2000H
mov ds,ax
mov bx,1000H
mov ax,[bx]

inc bx	; 表示 将bx存储的数据加一，类似于 C语言的自增（++）
inc bx
mov [bx],ax

inc bx
inc bx
mov [bx],ax

inc bx
mov [bx],al

inc bx
mov [bx],al
```

- 内存变化图：图片来源王汇编。97，99 两页

![8.1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.1.png)



## 8.2 LOOP 指令

loop 为循环指令。

- 指令格式：`loop 标号`。
- 操作步骤：
  1. `(cx) = (cx) - 1`
  2. 判断 `cx ` 中的值，不为零则转至表好处执行，为零则向下执行。

- `loop ` 指令用来实现循环的功能，**`cx`** 中存放 **循环次数**。

- 示例：计算 $2^{12}$

```assembly
assume cs:code
code segment
	mov ax,2
	mov cx,11

s:	add ax,ax
	loop s
	
	mov ax,4c00h
	int 21h

code ends
end
```

- 解析：

  `add ax,ax` 等价于 `(ax) = (ax) * 2`，由于此例，（ax）可以看作底数是2 的幂运算，乘以 2 就相当于指数加一。所以，可以将 `(cx) ` 设置为 11 来实现。



## 8.3 Debug 程序跟踪 loop 指令实验

- 要求：

  计算`ffff:0006` 单元中的数乘以 3，结果存放在 `dx` 中。

- 源程序：

```assembly
assume cs:code
code segment
	mov ax,0ffffh ; ffff:0006 单元处数值最大值为2^8-1,
    			  ; 不会大于 IP寄存器可存的
    			  ; 最大数值 2^16-1, 因此不会有溢出行为。 
	mov ds,ax
	mov bx,6	; 以上，设置 ds:bx 指向 ffff:6
	
	mov al,[bx]
	mov ah,0	; 以上，设置(al)=((ds*16)+(bx)),(ah)=0
	
	mov dx,0	; 累加器清零
	mov cx,3	; 循环三次、
	
s:	add dx,ax
	loop s		; 以上累加计算(ax)*3
	
	mov ax,4c00h
	int 21h		; 程序返回

code ends
end
```

- 注意：

  **在汇编源程序中 ，数据 不能以字母开头！** 所以本例中，`mov ax,0ffffh` ，十六进制数 `ffffh` 需要写成  `0ffffh`。

- 调试

  ![8.2](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.2.png)

  如上图所示，使用 `Debug` 对已生成的可执行文件进行调试。

  1. 通过使用 **`U`** 命令查看汇编指令，我们发现，此时在汇编源程中的 **标号 s** 变成了 `0012H` ，没错，正是源程序中 **标号 s** 所在行的那条汇编指令的起始位置。

  2. 直接使用 **`G`** 命令将偏移地址跳转至 `0012H` ，即  **标号 s** 所在的位置。也可以说是 循环体开始的位置。然后使用 **`T`** 命令不停地进行 单步调试，直至到执行 `int 21` 指令后，用 **`P`** 命令退出调试。如下图：

     ![8.3](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.3.png)

     从上图程序运行的过程我们看出，每次执行完 **`loop`** 指令后，CX 的值会自动减一，然后会判断其值是否会大于零；若大于零，则会 **向上** 跳转到标号的所在位置继续从上往下执行；若等于零则继续 **向下** 执行。

  3. 当循环次数增多，使用 **`T`**  命令进行单步调试就显得不可行，于是我们可以使用 **P** 命令。如上所见，**P** 命令可以用来终结调试，不仅如此，当执行到 **`loop`** 指令时，我们使用 **P** 命令 后，`Debug` 程序就会自动重复执行标号和 **`loop`** 指令之间，以及 **`loop`** 指令 在内的诸多指令，如下图;

     ![8.4](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/8.4.png)



## 8.4 Debug 和 masm 对指令的不同处理

- 对于汇编指令 **`mov ax,[idata]`** ，

  在 `Debug` 程序中，表示将 `ds:[idata]` 中的内容送入 AX 中。

  在 masm 中则会被解释为，将 `idata` 送入 AX 中。

- 在 masm 源程序中有两种方法表示，这种内存单元：
  
  1. 将偏移地址送入 bx 寄存器中，使用 **`ds:[bx]` ** 表示内存单元。
  2. 使用 **段前缀**：**`ds:[0]`** 显示地给出段地址，这种形式表示一个内存单元。
  
- 下面给出 masm 源程序 的具体例子，增强区分：

  `mov ax,[0]` 	====>>>	`(ax) = 0`

  `mov ax,[bx]` 	====>>>	`(ax) = (ds:bx)`

  `mov ax,ds:[0]` 	====>>>	`(ax) = (ds:0)`

  `mov ax,ds:[bx]` 	====>>>	`(ax) = (ds:bx)`



## 8.5 loop 和 [bx] 的联合应用

- 要求：

  计算 `ffff:0 ~ ffff:b` 单元中的数据之和，结果存储在 `dx` 中。

- 分析：

  每个内存单元的可存储的最大数值为 $2^{8}-1=255$，12 个这样的数之和 $255\times 12=$ 3060,不会大于一个字可存储的最大数值 $2^{16}-1=65535$ .因此，`ds`寄存器可存下，不会发生溢出问题。

- 源程序1：

```asm
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax	; 设置(ds)=ffffh
	mov dx,0	; 初始化累加寄存器，(dx)=0

	mov al,ds:[0]
	mov ah,0	; (ax)=((ds)*16+0)=(ffff0h)
	add dx,ax	; 向dx中加上 ffff:0 单元的数值

	mov al,ds:[1]
	mov ah,0	; (ax)=((ds)*16+1)=(ffff1h)
	add dx,ax	; 向dx中加上 ffff:1 单元的数值

	mov al,ds:[2]
	mov ah,0	; (ax)=((ds)*16+2)=(ffff2h)
	add dx,ax	; 向dx中加上 ffff:2 单元的数值

	mov al,ds:[3]
	mov ah,0	; (ax)=((ds)*16+3)=(ffff3h)
	add dx,ax	; 向dx中加上 ffff:3 单元的数值

	mov al,ds:[4]
	mov ah,0	; (ax)=((ds)*16+4)=(ffff4h)
	add dx,ax	; 向dx中加上 ffff:4 单元的数值

	mov al,ds:[5]
	mov ah,0	; (ax)=((ds)*16+5)=(ffff5h)
	add dx,ax	; 向dx中加上 ffff:5 单元的数值


	mov al,ds:[6]
	mov ah,0	; (ax)=((ds)*16+6)=(ffff6h)
	add dx,ax	; 向dx中加上 ffff:6 单元的数值

	mov al,ds:[7]
	mov ah,0	; (ax)=((ds)*16+7)=(ffff7h)
	add dx,ax	; 向dx中加上 ffff:7 单元的数值

	mov al,ds:[8]
	mov ah,0	; (ax)=((ds)*16+8)=(ffff8h)
	add dx,ax	; 向dx中加上 ffff:8 单元的数值

	mov al,ds:[9]
	mov ah,0	; (ax)=((ds)*16+9)=(ffff9h)
	add dx,ax	; 向dx中加上 ffff:9 单元的数值

	mov al,ds:[0ah]
	mov ah,0	; (ax)=((ds)*16+0ah)=(ffffah)
	add dx,ax	; 向dx中加上 ffff:a 单元的数值

	mov al,ds:[0bh]
	mov ah,0	; (ax)=((ds)*16+0bh)=(ffffbh)
	add dx,ax	; 向dx中加上 ffff:b 单元的数值

	mov ax,4c00h
	int 21h		; 程序返回

code ends
end
```

- 解析：（~~不只是为何，以上程序无法在 masm 中通过编译。没关系，知道大概的意思就行，不必太纠结于工具而浪费宝贵的时间！~~ 编译不通过的原因，竟然是，文件名中不能含特殊字符，于是将 "." 换成下划线就ok了。）

  以 `AX`  作为累加寄存器进行累加，重复十二次。当然，当内存范围更大时，这样的编程方式显然不可取。于是，刚刚学到的 **`loop`** 指令就可排上用场了。改进如下：

- 源程序2：

```asm
assume cs:codesg

codesg segment	;定义一个段名为 codesg 的段，从此开始

	mov ax,0ffffh
	mov ds,ax
	mov bx,0	; 初始化 ds:bx 指向 ffff:0

	mov dx,0	; 初始化累加器 dx
	mov cx,12	; 初始化训话计数器 cx
	
s:	mov al,[bx]
	mov ah,0
	add dx,ax
	inc bx		; bx 自增，指向下一个内存单元
	loop s
	
	mov ax,4c00h
	int 21h

codesg ends	;名为 codesg 的段到此结束

end
```



## 8.6 安全的内存空间和段前缀

- 安全的内存空间

  1. 在 8086 模式中，随意向一段内存空间写入内容是很危险的，因为这段空间可能存放着很重要的数据或这代码。

  2. 在 DOS 方式（实模式）下，一般情况，`0:200 ~ 0:2ff` 空间没有系统或其他程序的数据或代码。

- 段前缀

  前面我们已经在 **8.4 Debug 和 `masm` 对指令的不同处理** 一小节中看到，要想 `masm` 正确处理 `mov ax,[idata]` 类似的指令需要用 `bx` 做中转，或者显示地加上段寄存器，如 `mov ax,ds:[8]` 这种形式。

  此处的 **`ds:`** 就是**段前缀**，用于 **显示地指明内存单元的段地址**，类似的还有：**`cs:`** ，**`ss:`** ，**`es:`**.

## 实验四

- 编程，向内存 `0:200 ~ 0:23F` 依次传送数据 `0~63(3FH)`，程序中只能使用 9 条指令，9 条指令包括 `mov ax,4c00h` 和 `int 21h`。

  ```assembly
  assume CS:code
  code segment
  	MOV AX,0020h
  	MOV DS,AX
  	MOV bx,0
  	MOV CX,64
  
  s:	MOV [bx],bx
  	INC bx
  	LOOP s
  
  	MOV AX,4c00h
  	INT 21h
  
  code ends
  end
  ```

- 下面的程序的功能是将 `mov ax,4c00h` 之前的指令复制到内存 `0:200` 处，补全程序，上机调试，跟追运行结果。

  ```assembly
  assume CS:code
  code segment
  	MOV AX,___
  	MOV DS,AX
  	MOV AX,0020h
  	MOV ES,AX
  	MOV bx,0
  	MOV CX,___
  
  s:	MOV AL,[bx]
  	MOV ES:[bx],AL
  	INC bx
  	LOOP s
  
  	MOV AX,4c00h
  	INT 21h
  
  code ends
  end
  ```

  ~~这个问题很奇怪,`MOV AX,4c00h`到底前面问题的的程序里的指令还是什么别的？是在此之前的一条还是若干条指令，到底是啥意思？吾无奈阅读理解能力低下，并不能理解其深意。so，未完待续。。。。。~~



# 9. 包含多个段的程序

## 9.1 在代码段中使用数据和栈

- 直接看源程序9.1：

```assembly
assume CS:codesg
codesg segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		; 用 dw 定义 16 个字型数据，在程序加载之后，
		; 将取得 16 个字的内存空间，存放这 16 个数据。
		; 在后面的程序中将这段空间当做栈来使用

start:	MOV AX,CS
	MOV SS,AX
	MOV sp,30h	; 将设置栈顶 ss:sp 指向 cs:30h

	MOV bx,0
	MOV CX,8

s:	PUSH CS:[bx]
	ADD bx,2
	LOOP s		; 以上将代码段 0~15 单元中的
				; 8 个字型数据依次入栈

	MOV bx,0
	MOV CX,8

s0:	POP CS:[bx]
	ADD bx,2
	LOOP s0		; 以上依次出栈 8 个字型数据
				; 到代码段 0~15 单元中

	MOV AX,4c00h
	INT 21h

codesg ends
end start
```

- 解析：
  1. 此处我们用到了一个新的伪指令 **`dw`（define word）** 用来定义字型数据。此处定义了 8 个字型数据（数据之间用逗号隔开）。
  
  2. 注意此处在程序的第一条指令前加上了一个标号 **start** ，并且其在程序的末尾 **`end start`** 中再次出现。
  
  3. 所以需要说明伪指令 **end** 的作用：第一，通知编译器结束程序；第二，告诉编译器程序的入口在什么地方。**`end start`** 即告诉编译器程序的入口在标号 **start** 处。
  
  4. 上例中，指令 `MOV sp,30h` 的作用是将设置栈顶 `ss:sp` 指向 `cs:30h`，为什么是 `30h`？
  
     首先，我们用伪指令 `dw` 定义的连个段空间，这两个段的地址是相邻的，连续的。
  
     其次，两个段定义的空间分为别，8 个 和 16 个字，加起来就是 24 个字，也就是 48 个字节，也即 48 个内存单元，也就是 16 进制是 `30h` 了。所以就需要将 `ss:sp` 指向这段内存的最底部作为栈顶了。



## 9.2 将数据、代码、栈放入不同的段

上菜：

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,20h	; 设置栈顶 ss:sp 指向 stack:20h

	MOV AX,data
	MOV DS,AX	; ds 指向 data 段
	MOV bx,0	; ds:bx 指向 data 段中段第一个单元

	MOV CX,8
s:	PUSH [bx]
	ADD bx,2
	LOOP s		; 将以上 data 段中段 0~15 单元
			; 中的 8 个字型数据依次入栈

	MOV bx,0
	MOV CX,8
s0:	POP [bx]
	ADD bx,2
	LOOP s0		; 以上依次出栈 8 个字型数据到 
			; data 段的 0~15 单元中
	MOV AX,4c00h
	INT 21h

code ends
end start
```

- 从上例中可以看出，定义一个段与定义代码段没有区别，知识段名不同。

- 对段地址的引用

  在程序中 **段名** 代表 **段地址**，相当于一个标号。所以， `mov ax,data` 的含义就是将 **段名** 为 `data` 的 **段的段地址** 送入 `ax`.

- 一个段中的数据的段地址可有段名来表示，偏移地址就要看它哎段中的位置了。如上例中数据 `0abch` 的地址就是：`data:6`.

- 将上例中的  `data:6` 单元中的数据送入 `bx` 中，需要用以下程序：

  ```assembly
  mov ax,data
  mov ds,ax
  mov bx,ds:[6]
  ```

  而不能：

  ```assembly
  mov ds,data		; 错误
  mov bx,ds:[6]
  ```

  因为，**8086 CPU 不允许将一个数值直接送入 段寄存器！！！**

- “数据段”，“栈段”，“代码段”全都是我们自己的安排，那么：

  1. 这三个段分别用 `data`,`stack`,`code` 三个有具体含义的段名，CPU 是否就会因为这些段名按我们的意愿，把`data` 段中的内容当作数据段去执行？

     当然不会，这三个段名完全是我们方便阅读程序而取的段名，其完全可以用 `a`,`b`,`c` 这种没有具体含义的段名代替！

  2. 在源程序中，我们使用伪指令 **`assume CS:code,DS:data,SS:stack`** 将 `code` 段与 `cs`寄存器，`data`段与 `ds` 寄存器，`stack` 段 与 `ss` 寄存器 分别关联。那么 CPU 又是否会按照我们的想法 比如，将 `cs` 指向 `code`， 来处理这些段？

     也不会！再此，我们只知道，伪指令 **`assume`** 会将你定义的具有一定用途的段和相关寄存器联系起来。

  3.  CPU 如何使用我们定义的段与伪指令无关，而是由具体的汇编指令控制。

     本例中，我们用 `end start` 指令将程序的入口指定在 我们所定义的 `code` 段的第一条指令处。此就相当于 `code` 段相当于实际的代码段；而后

     ```assembly
     start:	MOV AX,stack
     		MOV SS,AX
     		MOV SP,20h	; 设置栈顶 ss:sp 指向 stack:20h
     ```

     三条指令将 我们定义的 `stack` **段的段地址** 送入 `ss` 寄存器中，并将 `ss:sp` 指向栈顶。此时，`stack` 段方才相当于一个栈空间，或者说一个栈段。由此可见，这个段的定义完全由我们使用汇编指令手动完成。

     将 `code` 段 定义为 数据段 也类似，由以下三条指令完成：

     ```assembly
     MOV AX,data
     MOV DS,AX	; ds 指向 data 段
     MOV bx,0	; ds:bx 指向 data 段中段第一个单元
     ```



## 实验五

- 源程序1

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	DW 0,0,0,0,0,0,0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends
end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.

- 源程序2

```assembly
assume CS:code,DS:data,SS:stack
data segment
	DW 0123h,0456h
data ends

stack segment
	DW 0,0
stack ends

code segment
start:	MOV AX,stack
	MOV SS,AX
	MOV SP,16

	MOV AX,data
	MOV DS,AX

	PUSH DS:[0]
	PUSH DS:[2]

	POP DS:[2]
	POP DS:[0]

	MOV AX,4C00H
	INT 21H

code ends
end start
```

1. CPU 执行程序，程序返回前，data 段中的数据为多少？

   答：**跟程序执行前一样**。

2. CPU 执行程序，程序返回前，`cs` = **`0b3d`H**, **`ss` = `0b3c`H**, `ds`= **`0b3b`H**.

3. 设程序加载后，`code` 段的段地址为 X，则 `data` 段的段地址为 **`X-2`**, `stack` 段的段地址为 **`X-1`**.

4. 对于如下定义的段：

   ```assembly
   name segment
   ...
   name ends
   ```

   如果段中的数据占 N 个字节，则程序加载后，该段的实际占有空间为 **16 字节**。

#  Question & No answer

## 1. 关于8086 CPU 最大寻址范围的问题

根据 8086 CPU 和成物理地址的方式，我们可以知道 8086 CPU 的寻址能力为 $2^{20}$，也就是 1 M，其寻址范围应为 `00000 ~ FFFFF`，用段地址和偏移地址表示为 `0000:0000 ~ F000:FFFF`. 但是使用 Debug 程序无论是 D 命令访问，A 或 E 命令写入 在这范围之外的物理地址如 `F001:FFFF`，都不会被 Debug 告知有什么错误，还能返回结果。这是为何？

Debug程序 使用的环境为 xp 系统的虚拟机。



## 2. 关于 SP + 2 的值 赋给 SP 后 SP 的值

 本书**问题3.11** 说到，“SP 原来为FFFEH，加二后 SP = 0”，对此心中存疑，于是打开虚拟机上的 xp 系统，用 debug 程序进行了测试，结果如下图

![x1](%E7%8E%8B%E7%88%BD%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88/x1.png)

结果没有任何问题，哈哈，但是上一次结果并不是这样滴。

因为 SP 是 16 位寄存器，所以 SP + 2 的值赋给 SP 其结果溢出后会舍去溢出的不放呢，所以结果如此。

# Study Conclusion

1. 学习有主线和副线，要明确主线。

   在学习的过程中往往会遇到很多陌生的名词和知识点，这些东西对于后面的学习可能会有暂时阻碍。努力地去清除这些阻碍本无可厚非，但是不要将好奇心无限放大，越走越远，偏离学习的主线。以往的学习经验告诉我，这非但不会使我变得博学，而是变得更肤浅并浪费大把时间。记住，不要本末倒置。

2. 注重基础的学习，而不是工具和框架。

   新奇的东西确实会吸引眼球，让人有获得的欲望。但是不要忘记，再华丽花哨的东西都不是凭空而来的，它是在旧事物的基础上发展而来的。例如，看上去吸引眼球的逆向，有各种工具和方法，但是不变的是其核心是汇编指令，所有的逆向相关的书籍都会有汇编指令的内容，有些是 x86，有些是 x64，但是不管x86 还是x64 其基础都不会脱离 实模式。所以，应该把百分之八十的时间花在基础和底层知识的学习上，其余时间用来学习工具和框架才对。

   



[^1]: 本参考书出于教学考虑，将总线简单定义为 “连接CPU和其他芯片的导线”，不能解答某些疑问，故引用百科[总线](https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF)词条。
[^2]: 此分类与本参考书略微不同，本参考书描述上似乎将通用寄存器的范围限制在本小节所参考博文 [8086CPU各寄存器及其简介](https://blog.csdn.net/weixin_40913261/article/details/90762210)的数据寄存器之内，与百科锁定并由[“科普中国”科学百科词条编写与应用工作项目](https://baike.baidu.com/science) 所审核的 [通用寄存器](https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/283978?fr=aladdin) 词条不一致，遂以更符合权威部门所审定的参考博文为主。

[^3]:一个程序或者类库更新到较新的版本后，用旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。--百度词条[向下兼容](https://baike.baidu.com/item/%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9?fromtitle=%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9&fromid=94553)。

[^4]: 这两句话都引自 《Beginning x64 Assembly Programming: From Novice to AVX Professional》 一书，作者 Jo Van Hoey.
[^4]: 