### 基本输入输出操作
#### 1.错误报告

- perror()

#### 2.终止执行

- exit()

#### 3.流

##### 3.1 概念
​		在C语言中，所有的 I/O 操作只是简单地从程序移进或字节的操作，这种字节被称为 **流**。
##### 3.2 流的读写过程
​		C语言读取和写入的操作实际上是，在一块被称为 **缓冲区（buffer）** 的内存区域来回复制数据。用于输入流的缓冲区只有当它**写满时**才会被刷新（**flush**,物理写入）到设备或文件中。一次性写满的缓冲区写入比逐片把程序产生的输出写入效率更高。输入缓冲区为空时通过从设备或文件读取下一块较大的输入重新填充缓冲区。
#####  3.3 分类
​		流分为两种类型，文本流 和 二进制流。二进制流中的字节未作任何改变地写入到文件和设备中，当不希望 I/O 函数修改 文本文件的行末字符时，可以使用二进制写入。
#####  3.4 文件
​		**FILE** 结构定义在 <stdio.h> 中，它并不是一个磁盘上的文件，它是一个数据结构，用于访问一个流。ANSI C 程序运行时系统至少提供 标准输入（**stdin**），标准输出（**stdout**）和 标准错误（**stderr**) 这三个流，他们都时一个指向 FILE 结构的指针。通常 标准输入 为 键盘设备，标准输出 为 终端或屏幕。对此，操作系统 允许 用户在 修改 默认的标准输入和输出设备，这叫作 I/O **重定向**.
####  4.I/O 操作总览

##### 4.1 I/O 操作的一般流程

- 流程图

```mermaid
graph LR
A(1.为文件声明一个 FILE 指针) -->B(2.通过 fopen打开流)
    B --> C(3.I/O 操作)
	C --> D(4.fclose 函数关闭流)

```

​		I/O 函数以三种基本的形式处理数据：单个字符，文本行和二进制。下表列出了用于每种 I/O 形式的函数或函数家族。

- 执行字符、文本行和二进制 I/O 的函数

| 数据类型 | 输入 | 输出 | 描述 |
| :----:  | :--: | :--: | :--: |
| 	字符	 | getchar | putchar |读取（写入）单个字符|
|	文本行	|	gets / scanf	|	puts / printf | 文本行未格式化的输入（输出）/格式化的输入（输出 |
| 二进制数据	|	fread	|	fwrite	| 读取（写入）二进制 |

- 输入输出函数家族

| 家族名  |    目的    | 可用于所有的流 | 只用于 stdin 和 stdout | 内存中的字符串 |
| ------- | :--------: | :------------: | :--------------------: | :------------: |
| getchar |  字符输入  |  fgetc，getc   |        getchar         |       ***1***        |
| putchar |  字符输出  |  fputc，putc   |        putchar         |       ***1***        |
| gets    | 文本行输入 |     fgets      |          gets          |       ***2***        |
| puts    | 文本行输出 |     fputs      |          puts          |       ***2***        |
| scanf   | 格式化输入 |     fscanf     |         scanf          |     sscanf     |
| printf  | 格式化输出 |    fprintf     |         printf         |    sprintf     |

***1***. 对指针使用下标或间接访问操作从内存获得一个字符（或向内存写入 一个字符）。

***2***. 使用stcpy 函数从内存读取文本行（或向内存写入文本行）。



#### 4.2 打开流和关闭流

##### 4.2.1 打开流

  fopen() 函数打开一个特定的文件，并把一个流和这个文件相关联。原型如下：

  ```c
FILE *fopen( charb*name, char const *mode);
  ```

  参数 name 是希望打开的文件或设备名。

  参数 mode 提示流是用于只读、只写、还是既读又写，以及它是文本流还是二进制流。以下是常用模式：

|        | 读取 | 写入 | 添加 |
| :----: | :--: | :--: | :--: |
|  文本  | ”r“  | ”w“  | "a"  |
| 二进制 | ”rb“ | “wb” | "ab" |

  ​	如果打开文件用于读取，那么它必须是原先已存在的。数据只能从尾部写入。

  ​	在 mode 中添加 ”a+“ 表示该文件开打用于更新，并且流既允许读也允许写。但是如果已从该文件读入一些数据，在写入之前必须调用定位函数（fseek， fsetpos、rewind等）。在写入一些数据后又需要从该文件读取数据，必须先调用  ***fflush*** 函数或者文件定位函数之一。

- 检查 fopen 的返回值

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
	FILE *pfile = fopen("hh.txt","r");
	if (pfile == NULL)
	{
		perror("hh.txt");
		exit(EXIT_FAILURE);
	}
	
	return 0;
}
```

运行结果：

​	hh.txt: No such file or directory

- freopen() 函数

​	打开或重新打开一个特定的文件流。原型如下：

```c
	FILE *freopen( char const *filename, char const *mode, FILE *stream )；
```

​	最后一个参数就是需要打开的流，可以是先前从 fopen() 返回的流，也可以是标准流  stdin、stdout 或 stderr . 这个函数首先试图关闭这个流，然后用指定的文件和模式重新打开这个流。如果打开失败，函数返回一个 NULL 值，否则返回第三个参数。
##### 4.2.2 关闭流

​		int fclose( FILE *f );

​		fclose() 函数在文件关闭之前刷新缓冲区。成功返回 0 ,否则返回 EOF .

#### 4.3字符I/O

##### 4.3.1 非格式化的字符输入族

```C
int fgetc( FILE *stream );
int getc( FILE *stream );
int getchar(void);
```

​	函数 getchar() 始终从标准输入读取字符，函数 fgetc() 和 函数getc() 需要 把操作的流传递给他们。这三个函数都用来读取字符,返回值都是 int 类型。

- 示例

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
	char *filename = "demo.txt";
	FILE *pfile = fopen(filename,"r");
	int ch;

	while( (ch = fgetc(pfile)) != EOF )
	{
		printf("%c", ch);
	}

	printf("\n");
	printf("请输入一个字符串：\n");

	int chs;
	while( (chs = getchar()) != EOF)
	{
		if (chs == '@')
		{
			break;
		}
		printf("%c", chs);
	}
	printf("\n");
	fclose(pfile);
	return 0;
}
```

运行结果：

​	请输入一个字符串：s's's
​	nihao@ ⇲
​	nihao

**NOTICE**

​	while 语句的判断条件中，(chs = getchar()) 的大括号必不可少，因为赋值运算符的优先级比 比较运算符的优先级低。

##### 4.3.2 非格式化的字符输出族

```C
int fputc( int character,FILE *stream )
int putc( int character, FILE *stream );
int putchar( int character );
```

​	第一个参数是要被打印的字符。

- 示例1

```
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
	char *filename = "test.txt";
	FILE *pfile = fopen(filename,"a");
	int input = 0;
	
	while( (input = getchar()) != EOF )
	{
		if (input == '@')
		{
			break;
		}
		putchar(input);
		fputc(input, pfile);
	}

	fclose(pfile);

	FILE *pfiler = fopen(filename,"r");
	
	int chc = 0;
	while( (chc = fgetc(pfiler)) != EOF )
	{
		printf("%c", chc);
	}
	printf("\n");
	fclose(pfiler);
	return 0;
}
```

  运行结果;

​	are you happy? 	⇲
​	are you happy?
​	yes,I am.@ 			⇲
​	yes,I am.are you happy?
​	yes,I am.

- 示例2

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
	int ch = 0;
	printf("请输入一段字符：\n");
	while( (ch = getchar()) != EOF )
	{
		if (ch == '@')
		{
			break;
		}
		// printf("%c", putchar(ch));
		putchar(ch);
	}
	printf("\n");

	return 0;
}
```

运行结果：
    请输入一段字符：
    are you ok?	⇲
    are you ok?
    terrible			⇲
    terrible
    @ 					⇲

##### 4.3.3 字符 I/O 宏

​	fgetc 和 fputc 都是真正的函数，但 getc、putc、getchar 和 puchar 都是通过 #define 指令定义的宏。宏在执行时间上效率稍高。

##### 4.3.4 撤销字符 I/O

```c
int ungetc( int character, FILE *stream );
```

​	**ungetc()把先前读入的字符返回到流中，下一次调用流的读取字节流函数将会读入该字符。**

- 示例1

  ```c
  #include <stdio.h>
  
  int main(int argc, char const *argv[])
  {
  	char *filename = "test.txt";
  	FILE *pfile = fopen(filename, "r");
  	char res = fgetc(pfile);
  	ungetc(res,pfile);
  	printf("%c\n", fgetc(pfile));
  	return 0;
  }
  ```

  运行结果：
		a

- 示例2

  ```c
  #include <stdio.h>
  
  int main(int argc, char const *argv[])
  {
  	char ch = 'd';
  	ungetc(ch,stdin);
  	char res = getchar();
  	printf("%c\n", res);
  
  	return 0;
  }
  ```

  - 运行结果：

  ​	d

  - 解析：

  ​	ungetc() 函数可以用来将字符返回到流中，流可以是文件指针，也可以是 stdin，如 示例2，将字符返回到 stdin 流中，stdin 流默认定向到键盘，因此当 getchar() 调用时相当于 把字符输入键盘中。
  
#### 4.4未格式化的行 I/O (字符串 I/O)

- 概述：

  行 I/O 可以用 格式化和未格式化两种方式执行，都用于操纵字符串。

- gets  和 pust 族：（字符串而非单个字符的操作）

  ```c
  char *fgets( char *buffer, int buffer_size, FILE *stream);
  char *gets( char *buffer);
  
  char *fputs( char const *buffer, FILE *stream);
  int puts(char const *buffer);
  ```

##### 4.4.1 puts 和 fputs

- 示例：

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
	char *filename =  "text1.txt1";
	FILE *pfile = fopen(filename,"w");
	puts(filename);
	fputs(filename, pfile);
	fclose(pfile);
	return 0;
}
```

- 运行结果:

  text1.txt

  ```shell
  cat test1.txt
  text1.txt
  ```

NOTICE:
  在使用流时注意，要以可写的模式打开文件，否则就会出现意想不到的错误。

##### 4.4.2 gets 和 fgets

- 示例1：

  - test.txt1

  ```
  1.1 操作系统的目标和作用.................................1
  1.1.1 操作系统的目标......................................1
  1.1.2 操作系统的作用......................................2
  1.1.3 推动操作系统发展的主要动力...............4
  1.2 操作系统的发展过程.....................................5
  1.2.1 无操作系统的计算机系统.......................5
  1.2.2 单道批处理系统......................................6
  1.2.3 多道批处理系统......................................7
  1.2.4 分时系统.................................................9
  1.2.5 实时系统............................................... 11
  1.2.6 微机操作系统的发展............................12
  1.3 操作系统的基本特性...................................14
  1.3.1 并发性...................................................14
  1.3.2 共享性...................................................15
  1.3.3 虚拟技术...............................................16
  1.3.4 异步性...................................................17
  1.4 操作系统的主要功能...................................18
  1.4.1 处理机管理功能....................................18
  1.4.2 存储器管理功能....................................19
  1.4.3 设备管理功能........................................21
  1.4.4 文件管理功能........................................21
  1.4.5 操作系统与用户之间的接口.................22
  1.5 OS结构设计................................................24
  1.5.1 传统的操作系统结构............................24
  1.5.2 客户/服务器模式...................................26
  1.5.3 面向对象的程序设计............................27
  1.5.4 微内核OS结构.....................................29
  习题......................................................................33
  2.1 进程的基本概念..........................................34
  2.1.1 程序的顺序执行及其特征.....................34
  2.1.2 前趋图...................................................35
  2.1.3 程序的并发执行及其特征.....................36
  2.1.4 进程的特征与状态................................37
  2.1.5 进程控制块...........................................41
  2.2 进程控制.....................................................43
  2.2.1 进程的创建...........................................43
  2.2.2 进程的终止...........................................45
  2.2.3 进程的阻塞与唤醒................................46
  2.2.4 进程的挂起与激活................................47
  2.3 进程同步.....................................................47
  2.3.1 进程同步的基本概念............................47
  2.3.2 信号量机制...........................................50
  2.3.3 信号量的应用.......................................53
  2.3.4 管程机制...............................................55
  2.4 经典进程的同步问题...................................58
  2.4.1 生产者—消费者问题............................58
  2.4.2 哲学家进餐问题....................................61
  2.4.3 读者—写者问题....................................63
  2.5 进程通信......................................................65
  2.5.1 进程通信的类型....................................65
  2.5.2 消息传递通信的实现方法.....................66
  2.5.3 消息传递系统实现中的若干问题..........68
  2.5.4 消息缓冲队列通信机制.........................69
  2.6 线程.............................................................71
  2.6.1 线程的基本概念....................................72
  2.6.2 线程间的同步和通信............................75
  2.6.3 线程的实现方式....................................77
  2.6.4 线程的实现...........................................78
  习题......................................................................81
  3.1 处理机调度的层次......................................84
  3.1.1 高级调度...............................................84
  3.1.2 低级调度...............................................86
  3.1.3 中级调度...............................................87
  3.2 调度队列模型和调度准则...........................88
  3.2.1 调度队列模型.......................................88
  3.2.2 选择调度方式和调度算法的若干准则......................................................90
  3.3 调度算法.....................................................91
  3.3.1 先来先服务和短作业(进程)优先调度算法...............................................91
  3.3.2 高优先权优先调度算法........................93
  3.3.3 基于时间片的轮转调度算法.................95
  3.4 实时调度.....................................................97
  3.4.1 实现实时调度的基本条件.....................97
  3.4.2 实时调度算法的分类............................99
  3.4.3 常用的几种实时调度算法...................100
  3.5 产生死锁的原因和必要条件......................103
  3.5.1 产生死锁的原因..................................103
  3.5.2 产生死锁的必要条件..........................105
  3.5.3 处理死锁的基本方法..........................105
  3.6 预防死锁的方法.........................................106
  3.6.1 预防死锁.............................................106
  3.6.2 系统安全状态......................................107
  3.6.3 利用银行家算法避免死锁...................108
  3.7 死锁的检测与解除..................................... 111
  3.7.1 死锁的检测......................................... 111
  3.7.2 死锁的解除.........................................113
  习题....................................................................114
  4.1 存储器的层次结构.................................... 116
  4.1.1 多级存储器结构.................................. 116
  4.1.2 主存储器与寄存器.............................. 117
  4.1.3 高速缓存和磁盘缓存.......................... 117
  4.2 程序的装入和链接.................................... 118
  4.2.1 程序的装入......................................... 118
  4.2.2 程序的链接.........................................120
  4.3 连续分配方式............................................121
  4.3.1 单一连续分配.....................................121
  4.3.2 固定分区分配.....................................122
  4.3.3 动态分区分配.....................................123
  4.3.4 伙伴系统.............................................126
  4.3.5 哈希算法.............................................126
  4.3.6 可重定位分区分配..............................127
  4.3.7 对换....................................................129
  4.4 基本分页存储管理方式.............................130
  4.4.1 页面与页表.........................................130
  4.4.2 地址变换机构.....................................131
  4.4.3 两级和多级页表..................................133
  4.5 基本分段存储管理方式.............................135
  4.5.1 分段存储管理方式的引入...................135
  4.5.2 分段系统的基本原理..........................136
  4.5.3 信息共享.............................................138
  4.5.4 段页式存储管理方式..........................140
  4.6 虚拟存储器的基本概念.............................141
  4.6.1 虚拟存储器的引入..............................142
  4.6.2 虚拟存储器的实现方法.......................143
  4.6.3 虚拟存储器的特征..............................144
  4.7 请求分页存储管理方式.............................144
  4.7.1 请求分页中的硬件支持.......................144
  4.7.2 内存分配策略和分配算法...................147
  4.7.3 调页策略.............................................148
  4.8 页面置换算法............................................149
  4.8.1 最佳置换算法和先进先出置换算法....150
  4.8.2 最近最久未使用(LRU)置换算法.........151
  4.8.3 Clock置换算法...................................153
  4.8.4 其它置换算法.....................................154
  4.9 请求分段存储管理方式.............................155
  4.9.1 请求分段中的硬件支持......................155
  4.9.2 分段的共享与保护..............................157
  习题....................................................................159
  5.1 I/O系统.....................................................160
  5.1.1 I/O设备..............................................160
  5.1.2 设备控制器.........................................162
  5.1.3 I/O通道..............................................164
  5.1.4 总线系统.............................................166
  5.2 I/O控制方式.............................................167
  5.2.1 程序I/O方式......................................167
  5.2.2 中断驱动I/O控制方式.......................168
  5.2.3 直接存储器访问(DMA)I/O控制方式....................................................169
  5.2.4 I/O通道控制方式...............................170
  5.3 缓冲管理...................................................171
  5.3.1 缓冲的引入.........................................171
  5.3.2 单缓冲和双缓冲..................................172
  5.3.3 循环缓冲.............................................174
  5.3.4 缓冲池.................................................175
  5.4 I/O软件.....................................................177
  5.4.1 I/O 软件的设计目标和原则................177
  5.4.2 中断处理程序......................................179
  5.4.3 设备驱动程序......................................181
  5.4.4 设备独立性软件..................................184
  5.4.5 用户层的I/O软件...............................186
  5.5 设备分配....................................................186
  5.5.1 设备分配中的数据结构.......................186
  5.5.2 设备分配时应考虑的因素...................187
  5.5.3 独占设备的分配程序..........................188
  5.5.4 SPOOLing技术...................................189
  5.6 磁盘存储器的管理.....................................191
  5.6.1 磁盘性能简述......................................191
  5.6.2 磁盘调度.............................................194
  5.6.3 磁盘高速缓存......................................197
  5.6.4 提高磁盘I/O速度的其它方法............199
  5.6.5 廉价磁盘冗余阵列..............................200
  习题....................................................................202
  6.1 文件和文件系统........................................203
  6.1.1 文件、记录和数据项..........................203
  6.1.2 文件类型和文件系统模型...................205
  6.1.3 文件操作.............................................206
  6.2 文件的逻辑结构........................................208
  6.2.1 文件逻辑结构的类型..........................208
  6.2.2 顺序文件.............................................209
  6.2.3 索引文件.............................................210
  6.2.4 索引顺序文件..................................... 211
  6.2.5 直接文件和哈希文件..........................212
  6.3 外存分配方式............................................213
  6.3.1 连续分配.............................................213
  6.3.2 链接分配.............................................215
  6.3.3 FAT 和NTFS技术...............................216
  6.3.4 索引分配.............................................221
  6.4 目录管理....................................................223
  6.4.1 文件控制块和索引结点.......................224
  6.4.2 目录结构.............................................226
  6.4.3 目录查询技术......................................229
  6.5 文件存储空间的管理.................................231
  6.5.1 空闲表法和空闲链表法.......................231
  6.5.2 位示图法.............................................232
  6.5.3 成组链接法.........................................233
  6.6 文件共享与文件保护.................................234
  6.6.1 基于索引结点的共享方式...................234
  6.6.2 利用符号链实现文件共享...................236
  6.6.3 磁盘容错技术.....................................237
  6.7 数据一致性控制........................................240
  6.7.1 事务....................................................241
  6.7.2 检查点.................................................242
  6.7.3 并发控制.............................................243
  6.7.4 重复数据的数据一致性问题...............243
  习题....................................................................246
  7.1 联机用户接口............................................248
  7.1.1 联机用户接口.....................................248
  7.1.2 联机命令的类型..................................250
  7.1.3 键盘终端处理程序..............................252
  7.1.4 命令解释程序.....................................254
  7.2 Shell命令语言...........................................255
  7.2.1 简单命令.............................................255
  7.2.2 重定向与管道命令..............................258
  7.2.3 通信命令.............................................259
  7.2.4 后台命令.............................................260
  7.3 系统调用...................................................260
  7.3.1 系统调用的基本概念..........................261
  7.3.2 系统调用的类型..................................263
  7.3.3 POSIX标准.........................................265
  7.3.4 系统调用的实现..................................266
  7.4 UNIX系统调用..........................................268
  7.4.1 UNIX系统调用的类型........................269
  7.4.2 被中断进程的环境保护.......................271
  7.4.3 系统调用陷入后需处理的公共问题.............................................272
  7.5 图形用户接口............................................273
  7.5.1 图形化用户界面..................................273
  7.5.2 桌面、图标和任务栏..........................274
  7.5.3 窗口.....................................................276
  7.5.4 对话框.................................................277
  习题....................................................................279
  8.1 计算机网络概述........................................281
  8.1.1 计算机网络的拓扑结构......................281
  8.1.2 计算机广域网络..................................284
  8.1.3 计算机局域网络..................................287
  8.1.4 网络互连.............................................288
  8.2 网络体系结构............................................290
  8.2.1 网络体系结构的基本概念...................290
  8.2.2 OSI/RM中的低三层...........................292
  8.2.3 OSI/RM中的高四层...........................294
  8.2.4 TCP/IP 网络体系结构........................295
  8.2.5 LAN网络体系结构.............................297
  8.3 Internet 与Intranet .....................................299
  8.3.1 Internet 简介........................................300
  8.3.2 Internet 提供的传统信息服务.............301
  8.3.3 Web服务.............................................303
  8.4 客户/服务器模式.......................................304
  8.4.1 两层结构客户/服务器模式的局限性.................................................304
  8.4.2 三层结构的客户/服务器模式..............305
  8.4.3 两层客户/服务器与三层客户/服务器的比较.....................................................306
  8.4.4 浏览器/服务器(Browser/Server)模式.....................................................307
  8.5 网络操作系统的功能.................................308
  8.5.1 数据通信功能......................................308
  8.5.2 网络资源共享功能..............................309
  8.5.3 应用互操作功能..................................312
  8.5.4 网络管理功能......................................314
  8.6 网络操作系统提供的服务..........................315
  8.6.1 域名系统(DNS) ...................................315
  8.6.2 目录服务.............................................317
  8.6.3 支持Internet提供的服务....................319
  习题...................................................................320
  9.1 系统安全的基本概念.................................322
  9.1.1 系统安全性的内容和性质...................322
  9.1.2 系统安全威胁的类型..........................323
  9.1.3 信息技术安全评价公共准则...............324
  9.2 数据加密技术............................................325
  9.2.1 数据加密的基本概念..........................325
  9.2.2 对称加密算法与非对称加密算法.......328
  9.2.3 数字签名和数字证明书......................329
  9.2.4 网络加密技术.....................................331
  9.3 认证技术...................................................332
  9.3.1 基于口令的身份认证..........................333
  9.3.2 基于物理标志的认证技术...................335
  9.3.3 基于生物标志的认证技术...................337
  9.3.4 基于公开密钥的认证技术...................339
  9.4 访问控制技术............................................340
  9.4.1 访问矩阵.............................................340
  9.4.2 访问矩阵的修改..................................342
  9.4.3 访问控制矩阵的实现..........................343
  9.5 计算机病毒................................................345
  9.5.1 计算机病毒的基本概念.......................345
  9.5.2 计算机病毒的类型..............................346
  9.5.3 病毒的隐藏方式..................................348
  9.5.4 病毒的预防和检测..............................350
  习题....................................................................351
  10.1 UNIX系统概述.......................................353
  10.1.1 UNIX系统的发展史.........................353
  10.1.2 UNIX系统的特征.............................355
  10.1.3 UNIX系统的内核结构.....................356
  10.2 进程的描述和控制...................................357
  10.2.1 进程控制块.......................................357
  10.2.2 进程状态与进程映像........................359
  10.2.3 进程控制...........................................361
  10.2.4 进程调度与切换................................363
  10.3 进程的同步与通信...................................364
  10.3.1 sleep与wakeup同步机制.................364
  10.3.2 信号机制...........................................365
  10.3.3 管道机制...........................................365
  10.3.4 消息机制...........................................367
  10.3.5 共享存储区机制................................368
  10.3.6 信号量集机制...................................369
  10.4 存储器管理..............................................370
  10.4.1 请求调页管理的数据结构.................370
  10.4.2 换页进程...........................................372
  10.4.3 请求调页...........................................373
  10.5 设备管理..................................................374
  10.5.1 字符设备缓冲区管理.........................374
  10.5.2 块设备缓冲区管理............................375
  10.5.3 内核与驱动程序接口.........................377
  10.5.4 磁盘驱动程序....................................379
  10.5.5 磁盘读/写程序...................................380
  10.6 文件管理..................................................381
  10.6.1 UNIX文件系统概述..........................381
  10.6.2 文件的物理结构................................383
  10.6.3 索引结点的管理................................385
  10.6.4 空闲磁盘空间的管理.........................386
  10.6.5 文件表的管理....................................388
  10.6.6 目录管理...........................................389
  习题....................................................................390
  参考文献.........................................................392
  ```

  - getchar.c

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #define	MAX_SIZE 100
  
  char *read_line(char const *filename)
  {
  	FILE *pfile = fopen(filename,"r");
  	char *str = NULL;
  	str = (char *)malloc(50 * sizeof(char));
  	
  	if(str)
  	{
  		fgets(str, MAX_SIZE - 1, pfile);
  		return str;
  
  	}else{
  		return NULL;
  	}
  	// fclose(pfile);
  }
  
  int main(int argc, char const *argv[])
  {
  	char *filename = "test.txt";
  	char *str = read_line(filename);
  	printf("%s\n", str);
  	puts("请输入一串字符：");
  	fgets(str, 2, stdin);	//读取第二个参数，即指定输出长度减一个，设为k个字符，若k大于给定字符串str的长度则输出整个字符串。
  	printf("%s\n", str);
  	return 0;
  }
  ```

  - 运行结果：

      1.1 操作系统的目标和作用.................................1

      请输入一串字符：
      dsdsad ⇲
      dsdsad

- 示例2：

  ```c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #define MAX_SIZE 100
  
  
  char *read_line(char const *filename)
  {
  	// char *filename = "test.txt";
  	FILE *pfile = fopen(filename,"rb");
  	//char *str = {NULL};
  	char *str = NULL;
  	str = (char *)malloc(50 * sizeof(char));
  	if(str)
  	{
  		while(fgets(str, MAX_SIZE - 1, pfile) != NULL){
  		//while(fgets(str, printf("%d",strlen(str)), pfile) != NULL){
  			//printf("strlenth is: %d\n",strlen(str));
  			printf("%s", str);
  			}
  	}else{
  		printf("memory is empty");
  	}
  	perror(filename);
  	// fclose(pfile);	// 为什么一关闭就报错？？？？？？?
  }
  
  
  int main(int argc, char const *argv[])
  {	
  	char *filename = "test.txt";
  	read_line(filename);
  	return 0;
  }
  ```

  - 运行结果：
    1.1 操作系统的目标和作用.................................1
1.1.1 操作系统的目标......................................1
1.1.2 操作系统的作用......................................2
1.1.3 推动操作系统发展的主要动力...............4
1.2 操作系统的发展过程.....................................5
1.2.1 无操作系统的计算机系统.......................5
1.2.2 单道批处理系统......................................6
1.2.3 多道批处理系统......................................7
1.2.4 分时系统.................................................9
1.2.5 实时系统............................................... 11
1.2.6 微机操作系统的发展............................12
1.3 操作系统的基本特性...................................14
1.3.1 并发性...................................................14
1.3.2 共享性...................................................15
1.3.3 虚拟技术...............................................16
1.3.4 异步性...................................................17
1.4 操作系统的主要功能...................................18
1.4.1 处理机管理功能....................................18
1.4.2 存储器管理功能....................................19
1.4.3 设备管理功能........................................21
1.4.4 文件管理功能........................................21
1.4.5 操作系统与用户之间的接口.................22
1.5 OS结构设计................................................24
1.5.1 传统的操作系统结构............................24
1.5.2 客户/服务器模式...................................26
1.5.3 面向对象的程序设计............................27
1.5.4 微内核OS结构.....................................29
习题......................................................................33
2.1 进程的基本概念..........................................34
2.1.1 程序的顺序执行及其特征.....................34
2.1.2 前趋图...................................................35
2.1.3 程序的并发执行及其特征.....................36
2.1.4 进程的特征与状态................................37
2.1.5 进程控制块...........................................41
2.2 进程控制.....................................................43
2.2.1 进程的创建...........................................43
2.2.2 进程的终止...........................................45
2.2.3 进程的阻塞与唤醒................................46
2.2.4 进程的挂起与激活................................47
2.3 进程同步.....................................................47
2.3.1 进程同步的基本概念............................47
2.3.2 信号量机制...........................................50
2.3.3 信号量的应用.......................................53
2.3.4 管程机制...............................................55
2.4 经典进程的同步问题...................................58
2.4.1 生产者—消费者问题............................58
2.4.2 哲学家进餐问题....................................61
2.4.3 读者—写者问题....................................63
2.5 进程通信......................................................65
2.5.1 进程通信的类型....................................65
2.5.2 消息传递通信的实现方法.....................66
2.5.3 消息传递系统实现中的若干问题..........68
2.5.4 消息缓冲队列通信机制.........................69
2.6 线程.............................................................71
2.6.1 线程的基本概念....................................72
2.6.2 线程间的同步和通信............................75
2.6.3 线程的实现方式....................................77
2.6.4 线程的实现...........................................78
习题......................................................................81
3.1 处理机调度的层次......................................84
3.1.1 高级调度...............................................84
3.1.2 低级调度...............................................86
3.1.3 中级调度...............................................87
3.2 调度队列模型和调度准则...........................88
3.2.1 调度队列模型.......................................88
3.2.2 选择调度方式和调度算法的若干准则......................................................90
3.3 调度算法.....................................................91
3.3.1 先来先服务和短作业(进程)优先调度算法...............................................91
3.3.2 高优先权优先调度算法........................93
3.3.3 基于时间片的轮转调度算法.................95
3.4 实时调度.....................................................97
3.4.1 实现实时调度的基本条件.....................97
3.4.2 实时调度算法的分类............................99
3.4.3 常用的几种实时调度算法...................100
3.5 产生死锁的原因和必要条件......................103
3.5.1 产生死锁的原因..................................103
3.5.2 产生死锁的必要条件..........................105
3.5.3 处理死锁的基本方法..........................105
3.6 预防死锁的方法.........................................106
3.6.1 预防死锁.............................................106
3.6.2 系统安全状态......................................107
3.6.3 利用银行家算法避免死锁...................108
3.7 死锁的检测与解除..................................... 111
3.7.1 死锁的检测......................................... 111
3.7.2 死锁的解除.........................................113
习题....................................................................114
4.1 存储器的层次结构.................................... 116
4.1.1 多级存储器结构.................................. 116
4.1.2 主存储器与寄存器.............................. 117
4.1.3 高速缓存和磁盘缓存.......................... 117
4.2 程序的装入和链接.................................... 118
4.2.1 程序的装入......................................... 118
4.2.2 程序的链接.........................................120
4.3 连续分配方式............................................121
4.3.1 单一连续分配.....................................121
4.3.2 固定分区分配.....................................122
4.3.3 动态分区分配.....................................123
4.3.4 伙伴系统.............................................126
4.3.5 哈希算法.............................................126
4.3.6 可重定位分区分配..............................127
4.3.7 对换....................................................129
4.4 基本分页存储管理方式.............................130
4.4.1 页面与页表.........................................130
4.4.2 地址变换机构.....................................131
4.4.3 两级和多级页表..................................133
4.5 基本分段存储管理方式.............................135
4.5.1 分段存储管理方式的引入...................135
4.5.2 分段系统的基本原理..........................136
4.5.3 信息共享.............................................138
4.5.4 段页式存储管理方式..........................140
4.6 虚拟存储器的基本概念.............................141
4.6.1 虚拟存储器的引入..............................142
4.6.2 虚拟存储器的实现方法.......................143
4.6.3 虚拟存储器的特征..............................144
4.7 请求分页存储管理方式.............................144
4.7.1 请求分页中的硬件支持.......................144
4.7.2 内存分配策略和分配算法...................147
4.7.3 调页策略.............................................148
4.8 页面置换算法............................................149
4.8.1 最佳置换算法和先进先出置换算法....150
4.8.2 最近最久未使用(LRU)置换算法.........151
4.8.3 Clock置换算法...................................153
4.8.4 其它置换算法.....................................154
4.9 请求分段存储管理方式.............................155
4.9.1 请求分段中的硬件支持......................155
4.9.2 分段的共享与保护..............................157
习题....................................................................159
5.1 I/O系统.....................................................160
5.1.1 I/O设备..............................................160
5.1.2 设备控制器.........................................162
5.1.3 I/O通道..............................................164
5.1.4 总线系统.............................................166
5.2 I/O控制方式.............................................167
5.2.1 程序I/O方式......................................167
5.2.2 中断驱动I/O控制方式.......................168
5.2.3 直接存储器访问(DMA)I/O控制方式....................................................169
5.2.4 I/O通道控制方式...............................170
5.3 缓冲管理...................................................171
5.3.1 缓冲的引入.........................................171
5.3.2 单缓冲和双缓冲..................................172
5.3.3 循环缓冲.............................................174
5.3.4 缓冲池.................................................175
5.4 I/O软件.....................................................177
5.4.1 I/O 软件的设计目标和原则................177
5.4.2 中断处理程序......................................179
5.4.3 设备驱动程序......................................181
5.4.4 设备独立性软件..................................184
5.4.5 用户层的I/O软件...............................186
5.5 设备分配....................................................186
5.5.1 设备分配中的数据结构.......................186
5.5.2 设备分配时应考虑的因素...................187
5.5.3 独占设备的分配程序..........................188
5.5.4 SPOOLing技术...................................189
5.6 磁盘存储器的管理.....................................191
5.6.1 磁盘性能简述......................................191
5.6.2 磁盘调度.............................................194
5.6.3 磁盘高速缓存......................................197
5.6.4 提高磁盘I/O速度的其它方法............199
5.6.5 廉价磁盘冗余阵列..............................200
习题....................................................................202
6.1 文件和文件系统........................................203
6.1.1 文件、记录和数据项..........................203
6.1.2 文件类型和文件系统模型...................205
6.1.3 文件操作.............................................206
6.2 文件的逻辑结构........................................208
6.2.1 文件逻辑结构的类型..........................208
6.2.2 顺序文件.............................................209
6.2.3 索引文件.............................................210
6.2.4 索引顺序文件..................................... 211
6.2.5 直接文件和哈希文件..........................212
6.3 外存分配方式............................................213
6.3.1 连续分配.............................................213
6.3.2 链接分配.............................................215
6.3.3 FAT 和NTFS技术...............................216
6.3.4 索引分配.............................................221
6.4 目录管理....................................................223
6.4.1 文件控制块和索引结点.......................224
6.4.2 目录结构.............................................226
6.4.3 目录查询技术......................................229
6.5 文件存储空间的管理.................................231
6.5.1 空闲表法和空闲链表法.......................231
6.5.2 位示图法.............................................232
6.5.3 成组链接法.........................................233
6.6 文件共享与文件保护.................................234
6.6.1 基于索引结点的共享方式...................234
6.6.2 利用符号链实现文件共享...................236
6.6.3 磁盘容错技术.....................................237
6.7 数据一致性控制........................................240
6.7.1 事务....................................................241
6.7.2 检查点.................................................242
6.7.3 并发控制.............................................243
6.7.4 重复数据的数据一致性问题...............243
习题....................................................................246
7.1 联机用户接口............................................248
7.1.1 联机用户接口.....................................248
7.1.2 联机命令的类型..................................250
7.1.3 键盘终端处理程序..............................252
7.1.4 命令解释程序.....................................254
7.2 Shell命令语言...........................................255
7.2.1 简单命令.............................................255
7.2.2 重定向与管道命令..............................258
7.2.3 通信命令.............................................259
7.2.4 后台命令.............................................260
7.3 系统调用...................................................260
7.3.1 系统调用的基本概念..........................261
7.3.2 系统调用的类型..................................263
7.3.3 POSIX标准.........................................265
7.3.4 系统调用的实现..................................266
7.4 UNIX系统调用..........................................268
7.4.1 UNIX系统调用的类型........................269
7.4.2 被中断进程的环境保护.......................271
7.4.3 系统调用陷入后需处理的公共问题.............................................272
7.5 图形用户接口............................................273
7.5.1 图形化用户界面..................................273
7.5.2 桌面、图标和任务栏..........................274
7.5.3 窗口.....................................................276
7.5.4 对话框.................................................277
习题....................................................................279
8.1 计算机网络概述........................................281
8.1.1 计算机网络的拓扑结构......................281
8.1.2 计算机广域网络..................................284
8.1.3 计算机局域网络..................................287
8.1.4 网络互连.............................................288
8.2 网络体系结构............................................290
8.2.1 网络体系结构的基本概念...................290
8.2.2 OSI/RM中的低三层...........................292
8.2.3 OSI/RM中的高四层...........................294
8.2.4 TCP/IP 网络体系结构........................295
8.2.5 LAN网络体系结构.............................297
8.3 Internet 与Intranet .....................................299
8.3.1 Internet 简介........................................300
8.3.2 Internet 提供的传统信息服务.............301
8.3.3 Web服务.............................................303
8.4 客户/服务器模式.......................................304
8.4.1 两层结构客户/服务器模式的局限性.................................................304
8.4.2 三层结构的客户/服务器模式..............305
8.4.3 两层客户/服务器与三层客户/服务器的比较.....................................................306
8.4.4 浏览器/服务器(Browser/Server)模式.....................................................307
8.5 网络操作系统的功能.................................308
8.5.1 数据通信功能......................................30









�络资���共享功能..8.5.3 应用互操作功能..................................312
8.5.4 网络管理功能......................................314
8.6 网络操作系统提供的服务..........................315
8.6.1 域名系统(DNS) ...................................315
8.6.2 目录服务.............................................317
8.6.3 支持Internet提供的服务....................319
习题...................................................................320
9.1 系统安全的基本概念.................................322
9.1.1 系统安全性的内容和性质...................322
9.1.2 系统安全威胁的类型..........................323
9.1.3 信息技术安全评价公共准则...............324
9.2 数据加密技术............................................325
9.2.1 数据加密的基本概念..........................325
9.2.2 对称加密算法与非对称加密算法.......328
9.2.3 数字签名和数字证明书......................329
9.2.4 网络加密技术.....................................331
9.3 认证技术...................................................332
9.3.1 基于口令的身份认证..........................333
9.3.2 基于物理标志的认证技术...................335
9.3.3 基于生物标志的认证技术...................337
9.3.4 基于公开密钥的认证技术...................339
9.4 访问控制技术............................................340
9.4.1 访问矩阵.............................................340
9.4.2 访问矩阵的修改..................................342
9.4.3 访问控制矩阵的实现..........................343
9.5 计算机病毒................................................345
9.5.1 计算机病毒的基本概念.......................345
9.5.2 计算机病毒的类型..............................346
9.5.3 病毒的隐藏方式..................................348
9.5.4 病毒的预防和检测..............................350
习题....................................................................351
10.1 UNIX系统概述.......................................353
10.1.1 UNIX系统的发展史.........................353
10.1.2 UNIX系统的特征.............................355
10.1.3 UNIX系统的内核结构.....................356
10.2 进程的描述和控制...................................357
10.2.1 进程控制块.......................................357
10.2.2 进程状态与进程映像........................359
10.2.3 进程控制...........................................361
10.2.4 进程调度与切换................................363
10.3 进程的同步与通信...................................364
10.3.1 sleep与wakeup同步机制.................364
10.3.2 信号机制...........................................365
10.3.3 管道机制...........................................365
10.3.4 消息机制...........................................367
10.3.5 共享存储区机制................................368
10.3.6 信号量集机制...................................369
10.4 存储器管理..............................................370
10.4.1 请求调页管理的数据结构.................370
10.4.2 换页进程...........................................372
10.4.3 请求调页...........................................373
10.5 设备管理..................................................374
10.5.1 字符设备缓冲区管理.........................374
10.5.2 块设备缓冲区管理............................375
10.5.3 内核与驱动程序接口.........................377
10.5.4 磁盘驱动程序....................................379
10.5.5 磁盘读/写程序...................................380
10.6 文件管理..................................................381
10.6.1 UNIX文件系统概述..........................381
10.6.2 文件的物理结构................................383
10.6.3 索引结点的管理................................385
10.6.4 空闲磁盘空间的管理.........................386
10.6.5 文件表的管理....................................388
10.6.6 目录管理...........................................389
习题....................................................................390
参考文献.........................................................392
    
    
    
    

- 解析：

  - fgets() 函数：

    ```c
  char *fgets( char *buffer, int buffer_size, FILE *stream);
    ```

    ​       fgets() 函数接收三个参数，第一个参数是需要接收的来自文件指针读取字符行的字符串变量，第二个指定读入的长度，第三个参数是 文件读取指针。

    > ​	当读到一个换行符，或者缓冲区内存存储的字符数达到 buffer_size-1 个时停止读取。如果在任何字符读取前就到达了文件尾，缓冲区就未进修改，fgets() 函数返回一个 NULL 指针。否则返回它的第一个参数(指向缓冲区的指针)。这个返回值通常只用于检查文件是否到达文件尾。
  
    **注意**：fgets() 函数的第二个参数，读取字符的实际长度是 其值减去一，因为字符串变量的最后一个字符是结束符 '\0',因此当此参数的值为 **1** 时，将**不会读取任何字符**；当第二个参数减去一的值仍大于第一个参数（字符串）的长度时，将会输出整个字符串。
  
    ​		
  
  - *gets() 函数
  
    > 由于gets() 函数没有缓冲区长度参数，因此gets无法判断缓冲区的长度，如果一个长度很大的字符被读取到一个很短的缓冲区，多出的字符将被写入到缓冲取后面的内存位置，这将破环其他变量的值。这导致gets函数只能适用于玩具程序，因为防止输入缓冲区溢出的方法就是声明一个巨大的缓冲区。
    
    ​	 因此，在最新的 C11 标准中直接删除这个函数而是用gets_s() 函数替代，但是由于这个新函数时一个扩展选项因此很多编译器还不支持，在GCC编译器中，gets() 函数也不允许被使用。
    
    如上例1所示，fgets()函数还可以重定向到 stdin（从键盘输入）
    
  - 各种错误问题：
  
    - 关闭文件指针报错问题，文件只读的方式打开，为什么关闭还会报错？
  
    - 读取文件乱码问题。如上例，文本文件比较长时，在 “8.5.1”附近出了乱码的问题，但是当将文本分割出其附近内容读取时，又发现输出结果完全正常！
  
      **以上问题悬而未决，暂时超出知识范围，有待深究。**
#### 4.5 格式化的行 I/O

#### TO BE CONTINUE

#### 4.6 二进制 I/O

> ​       把数据写道文件效率最高的方法是用二进制形式写入。二进制输出避免了在数值转换为字符串过程中所涉及的开销和精度损失。但二进制并非人眼所能阅读，所以这个技巧只有当数据将被另一个程序按顺序读取时才能使用。
>
> ​		fread 函数用于读取二进制数据，fwrite 函数用于写入二进制数据。它们的原型如下所示：
>
> ```c
> size_t fread(void *buffer, size_t size, size_t count, FILE *stream)
> size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream)
> ```
>
> ​		buffer 是一个指向用于保存数据的内存位置的指针，size 是缓冲区中每个元素的字节数， count 是读取或写入的元素数， stream是读取或写入的流。
>
> ​		buffer 参数被解释为**一个或多个值的数组**，count 参数指定数组中有多少个值，所以**读取或写入一个标量时，count 的 值应为1**。函数的返回值时实际读取或写入的元素（并非字节）数目。如果输入过程中遇到文件结尾或者输出过程中出现了错误，这个数字可能比请i去的元素数目小。

- 示例：fwrite()

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
	
	char *filename = "myfile.bin";

	FILE *pfile = fopen(filename, "wb");
	long pdata[] = {212323L,2123L,42435L};
	int num_items = sizeof(pdata) / sizeof(long);
	size_t  wcount = fwrite(pdata, sizeof(long), num_items, pfile);
	printf("%ld\n", wcount);
}
```

- 运行结果：

  ​	3

myfile.bin

```
633d 0300 0000 0000 4b08 0000 0000 0000
c3a5 0000 0000 0000 
```

- 示例：fread()

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
	
	char *filename = "myfile.bin";

	long *data = (long *)malloc(sizeof(long));
	// long *data;
    // long data[10];
	FILE *ppfile = fopen(filename, "rb");
	fread(data, sizeof(long), 3, ppfile);
	printf("%ld\n", *(data + 2));
	fclose(ppfile);
	return 0;
}
```

- 运行结果：

​		42435

- 解析：

  fread() 函数的第一个参数是从 stream 流中读取的指定 大小和 长度 的数组的首地址赋予（第一个参数）的值。

- NOTICE:

  在**定义一个指针变量时必须要将其初始化** ，如本例一开始只声明了一个 long 类型的指针变量，并没有将其初始化，因此，编译器并不能直到这个指针指向了内存的什么位置，这就导致了 运行后出现了 寄存器错误。因此，在需要接收一个指针类型的变量时，可以按以下两种情况对指针进行初始化：

  ​	`1`在知道接收的变量大小，直接定一个合适长度的数组。

  ​	`2`在不知道该变量的大小的情况下，使用 **<stdlib.h>** 和 **malloc() 等方法 动态分配内存大小**

#### 小结

​		在运行程序时经常会出现 **bash: 行 1: 17752 段错误               (核心已转储) **的问题，其绝大部分是由于，fopen() 函数找不到文件路径所致。可以 使用定义在 **<stdio.h>** 头文件中定义的 **perror(char* s)** 函数 打印错误信息，perror() 会把参数 **s** 和错误信息一起打印输出。

#### 4.7其他文件操作
#### TO BE CONTINUE


